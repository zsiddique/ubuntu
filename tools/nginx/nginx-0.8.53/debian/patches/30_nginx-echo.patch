Index: 0.8/modules/nginx-echo/LICENSE
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/LICENSE	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,30 @@
+Copyright (c) 2009, Taobao Inc., Alibaba Group ( http://www.taobao.com ).
+Copyright (c) 2009, agentzh <agentzh@gmail.com>.
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+    * Redistributions of source code must retain the above copyright
+    notice, this list of conditions and the following disclaimer.
+
+    * Redistributions in binary form must reproduce the above copyright
+    notice, this list of conditions and the following disclaimer in the
+    documentation and/or other materials provided with the distribution.
+
+    * Neither the name of the Taobao Inc. nor the names of its
+    contributors may be used to endorse or promote products derived from
+    this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
Index: 0.8/modules/nginx-echo/README
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/README	2010-10-31 07:35:47.698338000 +0000
@@ -0,0 +1,1740 @@
+Name
+    ngx_echo - Brings "echo", "sleep", "time", "exec" and more shell-style
+    goodies to Nginx config file.
+
+    *This module is not distributed with the Nginx source.* See the
+    installation instructions.
+
+Version
+    This document describes echo-nginx-module v0.34
+    (<http://github.com/agentzh/echo-nginx-module/tarball/v0.34 >) released
+    on September 14, 2010.
+
+Synopsis
+      location /hello {
+        echo "hello, world!";
+      }
+
+      location /hello {
+        echo -n "hello, "
+        echo "world!";
+      }
+
+      location /timed_hello {
+        echo_reset_timer;
+        echo hello world;
+        echo "'hello world' takes about $echo_timer_elapsed sec.";
+        echo hiya igor;
+        echo "'hiya igor' takes about $echo_timer_elapsed sec.";
+      }
+
+      location /echo_with_sleep {
+        echo hello;
+        echo_flush;  # ensure the client can see previous output immediately
+        echo_sleep   2.5;  # in sec
+        echo world;
+      }
+
+      # in the following example, accessing /echo yields
+      #   hello
+      #   world
+      #   blah
+      #   hiya
+      #   igor
+      location /echo {
+          echo_before_body hello;
+          echo_before_body world;
+          proxy_pass $scheme://127.0.0.1:$server_port$request_uri/more;
+          echo_after_body hiya;
+          echo_after_body igor;
+      }
+      location /echo/more {
+          echo blah;
+      }
+
+      # the output of /main might be
+      #   hello
+      #   world
+      #   took 0.000 sec for total.
+      # and the whole request would take about 2 sec to complete.
+      location /main {
+          echo_reset_timer;
+
+          # subrequests in parallel
+          echo_location_async /sub1;
+          echo_location_async /sub2;
+
+          echo "took $echo_timer_elapsed sec for total.";
+      }
+      location /sub1 {
+          echo_sleep 2;
+          echo hello;
+      }
+      location /sub2 {
+          echo_sleep 1;
+          echo world;
+      }
+
+      # the output of /main might be
+      #   hello
+      #   world
+      #   took 3.003 sec for total.
+      # and the whole request would take about 3 sec to complete.
+      location /main {
+          echo_reset_timer;
+
+          # subrequests in series (chained by CPS)
+          echo_location /sub1;
+          echo_location /sub2;
+
+          echo "took $echo_timer_elapsed sec for total.";
+      }
+      location /sub1 {
+          echo_sleep 2;
+          echo hello;
+      }
+      location /sub2 {
+          echo_sleep 1;
+          echo world;
+      }
+
+      # Accessing /dup gives
+      #   ------ END ------
+      location /dup {
+        echo_duplicate 3 "--";
+        echo_duplicate 1 " END ";
+        echo_duplicate 3 "--";
+        echo;
+      }
+
+      # /bighello will generate 1000,000,000 hello's.
+      location /bighello {
+        echo_duplicate 1000_000_000 'hello';
+      }
+
+      # echo back the client request
+      location /echoback {
+        echo_duplicate 1 $echo_client_request_headers;
+        echo "\r";
+
+        echo_read_request_body;
+
+        echo_request_body;
+      }
+
+      # GET /multi will yields
+      #   querystring: foo=Foo
+      #   method: POST
+      #   body: hi
+      #   content length: 2
+      #   ///
+      #   querystring: bar=Bar
+      #   method: PUT
+      #   body: hello
+      #   content length: 5
+      #   ///
+      location /multi {
+          echo_subrequest_async POST '/sub' -q 'foo=Foo' -b 'hi';
+          echo_subrequest_async PUT '/sub' -q 'bar=Bar' -b 'hello';
+      }
+      location /sub {
+          echo "querystring: $query_string";
+          echo "method: $echo_request_method";
+          echo "body: $echo_request_body";
+          echo "content length: $http_content_length";
+          echo '///';
+      }
+
+      # GET /merge?/foo.js&/bar/blah.js&/yui/baz.js will merge the .js resources together
+      location /merge {
+          default_type 'text/javascript';
+          echo_foreach_split '&' $query_string;
+              echo "/* JS File $echo_it */";
+              echo_location_async $echo_it;
+              echo;
+          echo_end;
+      }
+
+      # accessing /if?val=abc yields the "hit" output
+      # while /if?val=bcd yields "miss":
+      location ^~ /if {
+          set $res miss;
+          if ($arg_val ~* '^a') {
+              set $res hit;
+              echo $res;
+          }
+          echo $res;
+      }
+
+Description
+    This module wraps lots of Nginx internal APIs for streaming input and
+    output, parallel/sequential subrequests, timers and sleeping, as well as
+    various meta data accessing.
+
+    Basically it provides various utilities that help testing and debugging
+    of other modules by trivially emulating different kinds of faked
+    subrequest locations.
+
+    People will also find it useful in real-world applications that need to
+
+    1.  serve static contents directly from memory (loading from the Nginx
+        config file).
+
+    2.  wrap the upstream response with custom header and footer (kinda like
+        the addition module but with contents read directly from the config
+        file and Nginx variables).
+
+    3.  merge contents of various "Nginx locations" (i.e., subrequests)
+        together in a single main request (using echo_location and its
+        friends).
+
+    This is a special dual-role module that can *lazily* serve as a content
+    handler or register itself as an output filter only upon demand. By
+    default, this module does not do anything at all.
+
+    Use of any of this module's directives (no matter content handler
+    directives or filter directives) will force the chunked encoding to be
+    used for the HTTP response due to the streaming nature of this module
+    (unless HTTP 1.0 is enforced by the client and the Content-Length header
+    will be set to the size of the first handler directive that generates
+    contents).
+
+    Technially, this module has also demonstrated the following techniques
+    that might be helpful for module writers:
+
+    1.  Issue parallel subreqeusts directly from content handler.
+
+    2.  Issue chained subrequests directly from content handler, by passing
+        continuation along the subrequest chain.
+
+    3.  Issue subrequests with all HTTP 1.1 methods and even an optional
+        faked HTTP request body.
+
+    4.  Interact with the Nginx event model directly from content handler
+        using custom events and timers, and resume the content handler back
+        if necessary.
+
+    5.  Dual-role module that can (lazily) serve as a content handler or an
+        output filter or both.
+
+    6.  Nginx config file variable creation and interpolation.
+
+    7.  Streaming output control using output_chain, flush and its friends.
+
+    8.  Read client request body from the content handler, and returns back
+        (asynchronously) to the content handler after completion.
+
+    9.  Use Perl-based declarative test suite to drive the development of
+        Nginx C modules.
+
+Content Handler Directives
+    Use of the following directives register this module to the current
+    Nginx location as a content handler. If you want to use another module,
+    like the standard proxy module, as the content handler, use the filter
+    directives provided by this module.
+
+    All the content handler directives can be mixed together in a single
+    Nginx location and they're supposed to run sequentially just as in the
+    Bash scripting language.
+
+    Every content handler directive supports variable interpolation in its
+    arguments (if any).
+
+    The MIME type set by the standard default_type directive is respected by
+    this module, as in:
+
+      location /hello {
+        default_type text/plain;
+        echo hello;
+      }
+
+    Then on the client side:
+
+      $ curl -I 'http://localhost/echo'
+      HTTP/1.1 200 OK
+      Server: nginx/0.8.20
+      Date: Sat, 17 Oct 2009 03:40:19 GMT
+      Content-Type: text/plain
+      Connection: keep-alive
+
+    Since the v0.22 release, all of the directives are allowed in the
+    rewrite module's if directive block, for instance:
+
+        location ^~ /if {
+            set $res miss;
+            if ($arg_val ~* '^a') {
+                set $res hit;
+                echo $res;
+            }
+            echo $res;
+        }
+
+  echo
+    syntax: *echo [options] <string>...*
+
+    default: *no*
+
+    context: *location*
+
+    Sends arguments joined by spaces, along with a trailing newline, out to
+    the client.
+
+    Note that the data might be buffered by Nginx's underlying buffer. To
+    force the output data flushed immediately, use the echo_flush command
+    just after "echo", as in
+
+       echo hello world;
+       echo_flush;
+
+    When no argument is specified, *echo* emits the trailing newline alone,
+    just like the *echo* command in shell.
+
+    Variables may appear in the arguments. An example is
+
+       echo The current request uri is $request_uri;
+
+    where $request_uri is a variable exposed by the [[NginxHttpCoreModule]].
+
+    This command can be used multiple times in a single location
+    configuration, as in
+
+        location /echo {
+            echo hello;
+            echo world;
+        }
+
+    The output on the client side looks like this
+
+        $ curl 'http://localhost/echo'
+        hello
+        world
+
+    Special characters like newlines ("\n") and tabs ("\t") can be escaped
+    using C-style escaping sequences. But a notable exception is the dollar
+    sign ("$"). As of Nginx 0.8.20, there's still no clean way to esacpe
+    this characters. (A work-around might be to use a $echo_dollor variable
+    that is always evaluated to the constant "$" character. This feature
+    will possibly be introduced in a future version of this module.)
+
+    As of the echo v0.28 release, one can suppress the trailing newline
+    character in the output by using the "-n" option, as in
+
+        location /echo {
+            echo -n "hello, ";
+            echo "world";
+        }
+
+    Accessing "/echo" gives
+
+        $ curl 'http://localhost/echo'
+        hello, world
+
+    Leading "-n" in variable values won't take effect and will be emitted
+    literally, as in
+
+        location /echo {
+            set $opt -n;
+            echo $opt "hello,";
+            echo "world";
+        }
+
+    This gives the following output
+
+        $ curl 'http://localhost/echo'
+        -n hello,
+        world
+
+    One can output leading "-n" literals and other options using the special
+    "--" option like this
+
+        location /echo {
+            echo -- -n is an option;
+        }
+
+    which yields
+
+        $ curl 'http://localhost/echo'
+        -n is an option
+
+  echo_duplicate
+    syntax: *echo_duplicate <count> <string>*
+
+    default: *no*
+
+    context: *location*
+
+    Outputs duplication of a string indicated by the second argument, using
+    the times specified in the first argument.
+
+    For instance,
+
+      location /dup {
+          echo_duplicate 3 "abc";
+      }
+
+    will lead to an output of "abcabcabc".
+
+    Underscores are allowed in the count number, just like in Perl. For
+    example, to emit 1000,000,000 instances of "hello, world":
+
+      location /many_hellos {
+          echo_duplicate 1000_000_000 "hello, world";
+      }
+
+    The "count" argument could be zero, but not negative. The second
+    "string" argument could be an empty string ("") likewise.
+
+    Unlike the echo directive, no trailing newline is appended to the
+    result. So it's possible to "abuse" this directive as a
+    no-trailing-newline version of echo by using "count" 1, as in
+
+      location /echo_art {
+          echo_duplicate 2 '---';
+          echo_duplicate 1 ' END ';  # we don't want a trailing newline here
+          echo_duplicate 2 '---';
+          echo;  # we want a trailing newline here...
+      }
+
+    You get
+
+      ------ END ------
+
+    This directive was first introduced in version 0.11.
+
+  echo_flush
+    syntax: *echo_flush*
+
+    default: *no*
+
+    context: *location*
+
+    Forces the data potentially buffered by underlying Nginx output filters
+    to send immediately to the client side via socket.
+
+    Note that techically the command just emits a ngx_buf_t object with
+    "flush" slot set to 1, so certain weird third-party output filter module
+    could still block it before it reaches Nginx's (last) write filter.
+
+    This directive does not take any argument.
+
+    Consider the following example:
+
+      location /flush {
+         echo hello;
+
+         echo_flush;
+
+         echo_sleep 1;
+         echo world;
+      }
+
+    Then on the client side, using curl to access "/flush", you'll see the
+    "hello" line immediately, but only after 1 second, the last "world"
+    line. Without calling "echo_flush" in the example above, you'll most
+    likely see no output until 1 second is elapsed due to the internal
+    buffering of Nginx.
+
+    This directive will fail to flush the output buffer in case of
+    subrequests get involved. Consider the following example:
+
+      location /main {
+          echo_location_async /sub;
+          echo hello;
+          echo_flush;
+      }
+      location /sub {
+          echo_sleep 1;
+      }
+
+    Then the client won't see "hello" appear even if "echo_flush" has been
+    executed before the subrequest to "/sub" has actually started executing.
+    The outputs of "/main" that are sent *after* echo_location_async will be
+    postponed and buffered firmly.
+
+    This does *not* apply to outputs sent before the subrequest initiated.
+    For a modified version of the example given above:
+
+      location /main {
+          echo hello;
+          echo_flush;
+          echo_location_async /sub;
+      }
+      location /sub {
+          echo_sleep 1;
+      }
+
+    The client will immediately see "hello" before "/sub" enters sleeping.
+
+    See also echo, echo_sleep, and echo_location_async.
+
+  echo_sleep
+    syntax: *echo_sleep <seconds>*
+
+    default: *no*
+
+    context: *location*
+
+    Sleeps for the time period specified by the argument, which is in
+    seconds.
+
+    This operation is non-blocking on server side, so unlike the
+    echo_blocking_sleep directive, it won't block the whole Nginx worker
+    process.
+
+    The period might takes three digits after the decimal point and must be
+    greater than 0.001.
+
+    An example is
+
+       location /echo_after_sleep {
+           echo_sleep 1.234;
+           echo resumed!;
+       }
+
+    Behind the scene, it sets up a per-request "sleep" ngx_event_t object,
+    and adds a timer using that custom event to the Nginx event model and
+    just waits for a timeout on that event. Because the "sleep" event is
+    per-request, this directive can work in parallel subrequests.
+
+  echo_blocking_sleep
+    syntax: *echo_blocking_sleep <seconds>*
+
+    default: *no*
+
+    context: *location*
+
+    This is a blocking version of the echo_sleep directive.
+
+    See the documentation of echo_sleep for more detail.
+
+    Behind the curtain, it calls the ngx_msleep macro provided by the Nginx
+    core which maps to usleep on POSIX-compliant systems.
+
+    Note that this directive will block the current Nginx worker process
+    completely while being executed, so never use it in production
+    environment.
+
+  echo_reset_timer
+    syntax: *echo_reset_timer*
+
+    default: *no*
+
+    context: *location*
+
+    Reset the timer begin time to *now*, i.e., the time when this command is
+    executed during request.
+
+    The timer begin time is default to the starting time of the current
+    request and can be overridden by this directive, potentially multiple
+    times in a single location. For example:
+
+      location /timed_sleep {
+          echo_sleep 0.03;
+          echo "$echo_timer_elapsed sec elapsed.";
+
+          echo_reset_timer;
+
+          echo_sleep 0.02;
+          echo "$echo_timer_elapsed sec elapsed.";
+      }
+
+    The output on the client side might be
+
+        $ curl 'http://localhost/timed_sleep'
+        0.032 sec elapsed.
+        0.020 sec elapsed.
+
+    The actual figures you get on your side may vary a bit due to your
+    system's current activities.
+
+    Invocation of this directive will force the underlying Nginx timer to
+    get updated to the current system time (regardless the timer resolution
+    specified elsewhere in the config file). Furthermore, references of the
+    $echo_timer_elapsed variable will also trigger timer update forcibly.
+
+    See also echo_sleep and $echo_timer_elapsed.
+
+  echo_read_request_body
+    Explicitly reads request body so that the $request_body variable will
+    always have non-empty values (unless the body is so big that it has been
+    saved by Nginx to a local temporary file).
+
+    Note that this might not be the original client request body because the
+    current request might be a subrequest with a "artificial" body specified
+    by its parent.
+
+    This directive does not generate any output itself, just like
+    echo_sleep.
+
+    Here's an example for echo'ing back the original HTTP client request
+    (both headers and body are included):
+
+      location /echoback {
+        echo_duplicate 1 $echo_client_request_headers;
+        echo "\r";
+        echo_read_request_body;
+        echo $request_body;
+      }
+
+    The content of "/echoback" looks like this on my side (I was using
+    Perl's LWP utility to access this location on the server):
+
+      $ (echo hello; echo world) | lwp-request -m POST 'http://localhost/echoback'
+      POST /echoback HTTP/1.1
+      TE: deflate,gzip;q=0.3
+      Connection: TE, close
+      Host: localhost
+      User-Agent: lwp-request/5.818 libwww-perl/5.820
+      Content-Length: 12
+      Content-Type: application/x-www-form-urlencoded
+
+      hello
+      world
+
+    Because "/echoback" is the main request, $request_body holds the
+    original client request body.
+
+    Before Nginx 0.7.56, it makes no sense to use this directive because
+    $request_body was first introduced in Nginx 0.7.58.
+
+    This directive itself was first introduced in the echo module's v0.14
+    release.
+
+  echo_location_async
+    syntax: *echo_location_async <location> [<url_args>]*
+
+    default: *no*
+
+    context: *location*
+
+    Issue GET subrequest to the location specified (first argument) with
+    optional url arguments specified in the second argument.
+
+    As of Nginx 0.8.20, the "location" argument does *not* support named
+    location, due to a limitation in the "ngx_http_subrequest" function. The
+    same is true for its brother, the echo_location directive.
+
+    A very simple example is
+
+        location /main {
+            echo_location_async /sub;
+            echo world;
+        }
+        location /sub {
+            echo hello;
+        }
+
+    Accessing "/main" gets
+
+      hello
+      world
+
+    Calling multiple locations in parallel is also possible:
+
+        location /main {
+            echo_reset_timer;
+            echo_location_async /sub1;
+            echo_location_async /sub2;
+            echo "took $echo_timer_elapsed sec for total.";
+        }
+        location /sub1 {
+            echo_sleep 2; # sleeps 2 sec
+            echo hello;
+        }
+        location /sub2 {
+            echo_sleep 1; # sleeps 1 sec
+            echo world;
+        }
+
+    Accessing "/main" yields
+
+      $ time curl 'http://localhost/main'
+      hello
+      world
+      took 0.000 sec for total.
+
+      real  0m2.006s
+      user  0m0.000s
+      sys   0m0.004s
+
+    You can see that the main handler "/main" does *not* wait the
+    subrequests "/sub1" and "/sub2" to complete and quickly goes on, hence
+    the "0.000 sec" timing result. The whole request, however takes
+    approximately 2 sec in total to complete because "/sub1" and "/sub2" run
+    in parallel (or "concurrently" to be more accurate).
+
+    If you use echo_blocking_sleep in the previous example instead, then
+    you'll get the same output, but with 3 sec total response time, because
+    "blocking sleep" blocks the whole Nginx worker process.
+
+    Locations can also take an optional querystring argument, for instance
+
+        location /main {
+            echo_location_async /sub 'foo=Foo&bar=Bar';
+        }
+        location /sub {
+            echo $arg_foo $arg_bar;
+        }
+
+    Accessing "/main" yields
+
+      $ curl 'http://localhost/main'
+      Foo Bar
+
+    Querystrings is *not* allowed to be concatenated onto the "location"
+    argument with "?" directly, for example, "/sub?foo=Foo&bar=Bar" is an
+    invalid location, and shouldn't be fed as the first argument to this
+    directive.
+
+    Due to an unknown bug in Nginx (it still exists in Nginx 0.8.20), the
+    standard SSI module is required to ensure that the contents of the
+    subrequests issued by this directive are correctly merged into the
+    output chains of the main one. Fortunately, the SSI module is enabled by
+    default during Nginx's "configure" process.
+
+    If calling this directive without SSI module enabled, you'll get
+    truncated response without contents of any subrequests and get an alert
+    message in your Nginx's "error.log", like this:
+
+      [alert] 24212#0: *1 the http output chain is empty, client: 127.0.0.1, ...
+
+    Technically speaking, this directive is an example that Nginx content
+    handler issues one or more subrequests directly. AFAIK, the fancyindex
+    module (<https://connectical.com/projects/ngx-fancyindex/wiki >) also
+    does such kind of things ;)
+
+    Nginx named locations like @foo is *not* supported here.
+
+    This directive is logically equivalent to the GET version of
+    echo_subrequest_async. For example,
+
+      echo_location_async /foo 'bar=Bar';
+
+    is logically equivalent to
+
+      echo_subrequest_async GET /foo -q 'bar=Bar';
+
+    But calling this directive is slightly faster than calling
+    echo_subrequest_async using "GET" because we don't have to parse the
+    HTTP method names like "GET" and options like "-q".
+
+    This directive is first introduced in version 0.09 of this module and
+    requires at least Nginx 0.7.46.
+
+  echo_location
+    syntax: *echo_location <location> [<url_args>]*
+
+    default: *no*
+
+    context: *location*
+
+    Just like the echo_location_async directive, but "echo_location" issues
+    subrequests *in series* rather than in parallel. That is, the content
+    handler directives following this directive won't be executed until the
+    subrequest issued by this directive completes.
+
+    The final response body is almost always equivalent to the case when
+    echo_location_async is used instead, only if timing variables is used in
+    the outputs.
+
+    Consider the following example:
+
+        location /main {
+            echo_reset_timer;
+            echo_location /sub1;
+            echo_location /sub2;
+            echo "took $echo_timer_elapsed sec for total.";
+        }
+        location /sub1 {
+            echo_sleep 2;
+            echo hello;
+        }
+        location /sub2 {
+            echo_sleep 1;
+            echo world;
+        }
+
+    The location "/main" above will take for total 3 sec to complete
+    (compared to 2 sec if echo_location_async is used instead here). Here's
+    the result in action on my machine:
+
+      $ curl 'http://localhost/main'
+      hello
+      world
+      took 3.003 sec for total.
+
+      real  0m3.027s
+      user  0m0.020s
+      sys   0m0.004s
+
+    This directive is logically equivalent to the GET version of
+    echo_subrequest. For example,
+
+      echo_location /foo 'bar=Bar';
+
+    is logically equivalent to
+
+      echo_subrequest GET /foo -q 'bar=Bar';
+
+    But calling this directive is slightly faster than calling
+    echo_subrequest using "GET" because we don't have to parse the HTTP
+    method names like "GET" and options like "-q".
+
+    Behind the scene, it creates an "ngx_http_post_subrequest_t" object as a
+    *continuation* and passes it into the "ngx_http_subrequest" function
+    call. Nginx will later reopen this "continuation" in the subrequest's
+    "ngx_http_finalize_request" function call. We resumes the execution of
+    the parent-request's content handler and starts to run the next
+    directive (command) if any.
+
+    Nginx named locations like @foo is *not* supported here.
+
+    This directive was first introduced in the release v0.12.
+
+    See also echo_location_async for more details about the meaning of the
+    arguments.
+
+  echo_subrequest_async
+    syntax: *echo_subrequest_async <HTTP_method> <location> [-q <url_args>]
+    [-b <request_body>]*
+
+    default: *no*
+
+    context: *location*
+
+    Initiate an asynchronous subrequest using HTTP method, an optional url
+    arguments (or querystring), and an option request body.
+
+    This directive is very much like a generalized version of the
+    echo_location_async directive.
+
+    Here's a small example demonstrating its usage:
+
+        location /multi {
+            echo_subrequest_async POST '/sub' -q 'foo=Foo' -b 'hi';
+            echo_subrequest_async PUT '/sub' -q 'bar=Bar' -b 'hello';
+        }
+        location /sub {
+            echo "querystring: $query_string";
+            echo "method: $echo_request_method";
+            echo "body: $echo_request_body";
+            echo "content length: $http_content_length";
+            echo '///';
+        }
+
+    Then on the client side:
+
+      $ curl 'http://localhost/multi'
+      querystring: foo=Foo
+      method: POST
+      body: hi
+      content length: 2
+      ///
+      querystring: bar=Bar
+      method: PUT
+      body: hello
+      content length: 5
+      ///
+
+    Here's more funny example using the standard proxy module to handle the
+    subrequest:
+
+        location /main {
+            echo_subrequest_async POST /sub -b 'hello, world';
+        }
+        location /sub {
+            proxy_pass $scheme://127.0.0.1:$server_port/proxied;
+        }
+        location /proxied {
+            echo "method: $echo_request_method.";
+
+            # we need to read body explicitly here...or $echo_request_body
+            #   will evaluate to empty ("")
+            echo_read_request_body;
+
+            echo "body: $echo_request_body.";
+        }
+
+    Then on the client side, we can see that
+
+      $ curl 'http://localhost/main'
+      method: POST.
+      body: hello, world.
+
+    Nginx named locations like @foo is *not* supported here.
+
+    This directive was first introduced in the release v0.15.
+
+    See also the echo_subrequest and echo_location_async directives.
+
+  echo_subrequest
+    syntax: *echo_subrequest_async <HTTP_method> <location> [-q <url_args>]
+    [-b <request_body>]*
+
+    default: *no*
+
+    context: *location*
+
+    This is the synchronous version of the echo_subrequest_async directive.
+    And just like echo_location, it does not block the Nginx worker process
+    (while echo_blocking_sleep does), rather, it uses continuation to pass
+    control along the subrequest chain.
+
+    See echo_subrequest_async for more details.
+
+    Nginx named locations like @foo is *not* supported here.
+
+    This directive was first introduced in the release v0.15.
+
+  echo_foreach_split
+    syntax: *echo_foreach_split <delimiter> <string>*
+
+    default: *no*
+
+    context: *location*
+
+    Split the second argument "string" using the delimiter specified in the
+    first argument, and then iterate through the resulting items. For
+    instance:
+
+      location /loop {
+        echo_foreach_split ',' $arg_list;
+          echo "item: $echo_it";
+        echo_end;
+      }
+
+    Accessing /main yields
+
+      $ curl 'http://localhost/loop?list=cat,dog,mouse'
+      item: cat
+      item: dog
+      item: mouse
+
+    As seen in the previous example, this directive should always be
+    accompanied by an echo_end directive.
+
+    Parallel "echo_foreach_split" loops are allowed, but nested ones are
+    currently forbidden.
+
+    The "delimiter" argument could contain *multiple* arbitrary characters,
+    like
+
+      echo_foreach_split '-a-' 'cat-a-dog-a-mouse';
+        echo $echo_it;
+      echo_end;
+
+    Logically speaking, this looping structure is just the "foreach" loop
+    combined with a "split" function call in Perl (using the previous
+    example):
+
+       foreach (split ',', $arg_list) {
+           print "item $_\n";
+       }
+
+    People will also find it useful in merging multiple ".js" or ".css"
+    resources into a whole. Here's an example:
+
+      location /merge {
+          default_type 'text/javascript';
+
+          echo_foreach_split '&' $query_string;
+              echo "/* JS File $echo_it */";
+              echo_location_async $echo_it;
+              echo;
+          echo_end;
+      }
+
+    Then accessing /merge to merge the ".js" resources specified in the
+    query string:
+
+      $ curl 'http://localhost/merge?/foo/bar.js&/yui/blah.js&/baz.js'
+
+    One can also use third-party Nginx cache module to cache the merged
+    response generated by the "/merge" location in the previous example.
+
+    This directive was first introduced in the release v0.17.
+
+  echo_end
+    syntax: *echo_end*
+
+    default: *no*
+
+    context: *location*
+
+    This directive is used to terminate the body of looping and conditional
+    control structures like echo_foreach_split.
+
+    This directive was first introduced in the release v0.17.
+
+  echo_request_body
+    syntax: *echo_request_body*
+
+    default: *no*
+
+    context: *location*
+
+    Outputs the contents of the request body previous read.
+
+    Behind the scene, it's implemented roughly like this:
+
+      if (r->request_body && r->request_body->bufs) {
+          return ngx_http_output_filter(r, r->request_body->bufs);
+      }
+
+    Unlike the $echo_request_body and $request_body variables, this
+    directive will show the whole request body even if some parts or all
+    parts of it are saved in temporary files on the disk.
+
+    It is a "no-op" if no request body has been read yet.
+
+    This directive was first introduced in the release v0.18.
+
+    See also echo_read_request_body and the chunkin module.
+
+  echo_exec
+    syntax: *echo_exec <location> [<query_string>]*
+
+    syntax: *echo_exec <named_location>*
+
+    default: *no*
+
+    context: *location*
+
+    Does an internal redirect to the location specified. An optional query
+    string can be specified for normal locations, as in
+
+      location /foo {
+          echo_exec /bar weight=5;
+      }
+      location /bar {
+          echo $arg_weight;
+      }
+
+    Or equivalently
+
+      location /foo {
+          echo_exec /bar?weight=5;
+      }
+      location /bar {
+          echo $arg_weight;
+      }
+
+    Named locations are also supported. Here's an example:
+
+      location /foo {
+          echo_exec @bar;
+      }
+      location @bar {
+          # you'll get /foo rather than @bar
+          #  due to a potential bug in nginx.
+          echo $echo_request_uri;
+      }
+
+    But query string (if any) will always be ignored for named location
+    redirects due to a limitation in the "ngx_http_named_location" function.
+
+    Never try to echo things before the "echo_exec" directive or you won't
+    see the proper response of the location you want to redirect to. Because
+    any echoing will cause the original location handler to send HTTP
+    headers before the redirection happens.
+
+    Technically speaking, this directive exposes the Nginx internal API
+    functions "ngx_http_internal_redirect" and "ngx_http_named_location".
+
+    This directive was first introduced in the v0.21 release.
+
+Filter Directives
+    Use of the following directives trigger the filter registration of this
+    module. By default, no filter will be registered by this module.
+
+    Every filter directive supports variable interpolation in its arguments
+    (if any).
+
+  echo_before_body
+    syntax: *echo_before_body [options] [argument]...*
+
+    default: *no*
+
+    context: *location*
+
+    It's the filter version of the echo directive, and prepends its output
+    to the beginning of the original outputs generated by the underlying
+    content handler.
+
+    An example is
+
+        location /echo {
+            echo_before_body hello;
+            proxy_pass $scheme://127.0.0.1:$server_port$request_uri/more;
+        }
+        location /echo/more {
+            echo world
+        }
+
+    Accessing "/echo" from the client side yields
+
+      hello
+      world
+
+    In the previous sample, we borrow the standard proxy module to serve as
+    the underlying content handler that generates the "main contents".
+
+    Multiple instances of this filter directive are also allowed, as in:
+
+        location /echo {
+            echo_before_body hello;
+            echo_before_body world;
+            echo !;
+        }
+
+    On the client side, the output is like
+
+      $ curl 'http://localhost/echo'
+      hello
+      world
+      !
+
+    In this example, we also use the content handler directives provided by
+    this module as the underlying content handler.
+
+    This directive also supports the "-n" and "--" options like the echo
+    directive.
+
+    This directive can be mixed with its brother directive echo_after_body.
+
+  echo_after_body
+    syntax: *echo_after_body [argument]...*
+
+    default: *no*
+
+    context: *location*
+
+    WARNING this directive does not work for nginx >= 0.7.65.
+
+    It's very much like the echo_before_body directive, but *appends* its
+    output to the end of the original outputs generated by the underlying
+    content handler.
+
+    Here's a simple example:
+
+        location /echo {
+            echo_after_body hello;
+            proxy_pass http://127.0.0.1:$server_port$request_uri/more;
+        }
+        location /echo/more {
+            echo world
+        }
+
+    Accessing "/echo" from the client side yields
+
+      world
+      hello
+
+    Multiple instances are allowed, as in:
+
+        location /echo {
+            echo_after_body hello;
+            echo_after_body world;
+            echo i;
+            echo say;
+        }
+
+    The output on the client side while accessing the "/echo" location looks
+    like
+
+      i
+      say
+      hello
+      world
+
+    This directive also supports the "-n" and "--" options like the echo
+    directive.
+
+    When this directive is used in a location accessed by a subrequest, it
+    replies on the "sync" flag set in a chain buffer to indicate the end of
+    the output for nginx >= 0.8.7. This is a hack because Nginx does not
+    provide a reliable way to determine the end of the output chain in a
+    subrequest's output filter. Use it in subrequests with care.
+
+    This directive can be mixed with its brother directive echo_before_body.
+
+Variables
+  $echo_it
+    This is a "topic variable" used by echo_foreach_split, just like the $_
+    variable in Perl.
+
+  $echo_timer_elapsed
+    This variable holds the seconds elapsed since the start of the current
+    request (might be a subrequest though) or the last invocation of the
+    echo_reset_timer command.
+
+    The timing result takes three digits after the decimal point.
+
+    References of this variable will force the underlying Nginx timer to
+    update to the current system time, regardless the timer resolution
+    settings elsewhere in the config file, just like the echo_reset_timer
+    directive.
+
+  $echo_request_body
+    Evaluates to the current (sub)request's request body previously read if
+    no part of the body has been saved to a temporary file. To always show
+    the request body even if it's very large, use the echo_request_body
+    directive.
+
+  $echo_request_method
+    Evaluates to the HTTP request method of the current request (it can be a
+    subrequest).
+
+    Behind the scene, it just takes the string data stored in
+    "r->method_name".
+
+    Compare it to the $echo_client_request_method variable.
+
+    At least for Nginx 0.8.20 and older, the $request_method variable
+    provided by the http core module is actually doing what our
+    $echo_client_request_method is doing.
+
+    This variable was first introduced in our v0.15 release.
+
+  $echo_client_request_method
+    Always evaluates to the main request's HTTP method even if the current
+    request is a subrequest.
+
+    Behind the scene, it just takes the string data stored in
+    "r->main->method_name".
+
+    Compare it to the $echo_request_method variable.
+
+    This variable was first introduced in our v0.15 release.
+
+  $echo_client_request_headers
+    Evaluates to the original client request's headers.
+
+    Just as the name suggests, it will always take the main request (or the
+    client request) even if it's currently executed in a subrequest.
+
+    A simple example is below:
+
+      location /echoback {
+         echo "headers are:"
+         echo $echo_client_request_headers;
+      }
+
+    Accessing "/echoback" yields
+
+      $ curl 'http://localhost/echoback'
+      headers are
+      GET /echoback HTTP/1.1
+      User-Agent: curl/7.18.2 (i486-pc-linux-gnu) libcurl/7.18.2 OpenSSL/0.9.8g
+      Host: localhost:1984
+      Accept: */*
+
+    Behind the scene, it recovers "r->main->header_in" on the C level and
+    does not construct the headers itself by traversing parsed results in
+    the request object, and strips the last (trailing) CRLF.
+
+    This variable was first introduced in version 0.15.
+
+  $echo_cacheable_request_uri
+    Evaluates to the parsed form of the URI (usually led by "/") of the
+    current (sub-)request. Unlike the $echo_request_uri variable, it is
+    cacheable.
+
+    See $echo_request_uri for more details.
+
+    This variable was first introduced in version 0.17.
+
+  $echo_request_uri
+    Evaluates to the parsed form of the URI (usually led by "/") of the
+    current (sub-)request. Unlike the $echo_cacheable_request_uri variable,
+    it is *not* cacheable.
+
+    This is quite different from the $request_uri variable exported by the
+    [[NginxHttpCoreModule]], because $request_uri is the *unparsed* form of
+    the current request's URI.
+
+    This variable was first introduced in version 0.17.
+
+  $echo_incr
+    It is a counter that always generate the current counting number,
+    starting from 1. The counter is always associated with the main request
+    even if it is accessed within a subrequest.
+
+    Consider the following example
+
+        location /main {
+            echo "main pre: $echo_incr";
+            echo_location_async /sub;
+            echo_location_async /sub;
+            echo "main post: $echo_incr";
+        }
+        location /sub {
+            echo "sub: $echo_incr";
+        }
+
+    Accessing "/main" yields
+
+        main pre: 1
+        sub: 3
+        sub: 4
+        main post: 2
+
+    This directive was first introduced in the v0.18 release.
+
+  $echo_response_status
+    Evaluates to the status code of the current (sub)request, null if not
+    any.
+
+    Behind the scene, it's just the textual representation of
+    "r->headers_out->status".
+
+    This directive was first introduced in the v0.23 release.
+
+Installation
+    Grab the nginx source code from nginx.net (<http://nginx.net/ >), for
+    example, the version 0.8.41 (see nginx compatibility), and then build
+    the source with this module:
+
+        $ wget 'http://sysoev.ru/nginx/nginx-0.8.41.tar.gz'
+        $ tar -xzvf nginx-0.8.41.tar.gz
+        $ cd nginx-0.8.41/
+
+        # Here we assume you would install you nginx under /opt/nginx/.
+        $ ./configure --prefix=/opt/nginx \
+            --add-module=/path/to/echo-nginx-module
+
+        $ make -j2
+        $ make install
+
+    Download the latest version of the release tarball of this module from
+    echo-nginx-module file list
+    (<http://github.com/agentzh/echo-nginx-module/downloads >).
+
+Compatibility
+    The following versions of Nginx should work with this module:
+
+    *   0.8.x (last tested version is 0.8.40)
+
+    *   0.7.x >= 0.7.21 (last tested version is 0.7.66)
+
+    In particular,
+
+    *   the directive echo_location_async and its brother
+        echo_subrequest_async do *not* work with 0.7.x < 0.7.46.
+
+    *   the echo_after_body directive does *not* work at all with nginx <
+        0.8.7.
+
+    *   the echo_sleep directive cannot be used after echo_location or
+        echo_subrequest for nginx < 0.8.11.
+
+    Earlier versions of Nginx like 0.6.x and 0.5.x will *not* work at all.
+
+    If you find that any particular version of Nginx above 0.7.21 does not
+    work with this module, please consider reporting a bug.
+
+Modules that use this module for testing
+    The following modules take advantage of this "echo" module in their test
+    suite:
+
+    *   The memc module that supports almost the whole memcached TCP
+        protocol.
+
+    *   The chunkin module that adds HTTP 1.1 chunked input support to
+        Nginx.
+
+    *   The headers_more module that allows you to add, set, and clear input
+        and output headers under the conditions that you specify.
+
+    *   The "echo" module itself.
+
+    Please mail me other modules that use "echo" in any form and I'll add
+    them to the list above :)
+
+Report Bugs
+    Although a lot of effort has been put into testing and code tuning,
+    there must be some serious bugs lurking somewhere in this module. So
+    whenever you are bitten by any quirks, please don't hesitate to
+
+    1.  send a bug report or even patches to <agentzh@gmail.com>,
+
+    2.  or create a ticket on the issue tracking interface
+        (<http://github.com/agentzh/echo-nginx-module/issues >) provided by
+        GitHub.
+
+Source Repository
+    Available on github at agentzh/echo-nginx-module
+    (<http://github.com/agentzh/echo-nginx-module >).
+
+ChangeLog
+  v0.34
+    *   we no longer use the problematic "ngx_strXcmp" macros in our source
+        because it may cause invalid reads and thus segmentation faults.
+        thanks Piotr Sikora.
+
+  v0.33
+    *   fixed compatibility with nginx 0.7.66+ because the ngx_time_update
+        macro's parameter list has changed. Thanks Guang Feng (蔡镜明).
+
+  v0.32
+    *   we should have used "ngx_calloc_buf" instead of "ngx_alloc_buf" for
+        the last chunk generated for echo_after_body. thanks valgrind's
+        memcheck tool.
+
+    *   we should initialize flags before feeding it into
+        "ngx_http_parse_unsafe_uri". thanks valgrind's memcheck tool.
+
+    *   fixed a minor issue in the echo_location/echo_subrequest
+        implementation, which used to have race conditions.
+
+  v0.31
+    *   the echo wev handler should not proceed if it is still waiting for
+        some sequential subrequest or has just processed one to avoid
+        bouncing issues.
+
+    *   fixed a segfault for echo_exec for 0.7.x: we should check "r->done"
+        before proceeding.
+
+    *   no longer explicitly set "r->write_event_handler" to
+        "ngx_http_request_empty_handler" because it's totally wrong for the
+        state machine.
+
+    *   fixed the sequential subrequest model bugs: we should ensure the
+        "pr->write_event_handler" gets called immediately after the
+        "post_subrequest" callback when the subrequest finalizes.
+
+  v0.30
+    *   fixed the echo_exec directive for nginx >= 0.8.11. we didn't get the
+        "r->main->count" right in the previous version.
+
+  v0.29
+    *   refactored the core of this module. now the implementation of
+        echo_location, echo_subrequest, echo_sleep, and
+        echo_read_request_body finally fit well with the nginx event model
+        and Igor Sysoev's way of thinking.
+
+  v0.28
+    *   added support for the "-n" and "--" options to the echo,
+        echo_before_body, and echo_after_body directives.
+
+  v0.27
+    *   applied the patch from Sergey A. Osokin to work with nginx 0.8.35.
+
+  v0.26
+    *   bug fix: we should bypass upstream filters in our echo filters. an
+        output filter should ever call "ngx_http_output_filter" nor
+        "ngx_http_send_special".
+
+  v0.25
+    *   now we register a request cleanup handler to ensure our sleep
+        event's timer will always get properly deleted even if the request
+        is quit prematurely. this affects the echo_sleep directive.
+
+    *   use ngx_null_string whenever possible in the source.
+
+    *   sync'd the bundled test scaffold to Test::Nginx 0.07.
+
+  v0.24
+    *   various source file name and coding style fixes. (the code now looks
+        more like Igor Sysoev's.)
+
+  v0.23
+    *   now the subrequest can read the client request body directly (for
+        the main request) because we made subrequests inherit its parent's
+        "r->header_in" as well. This affects the echo_read_request_body
+        directive.
+
+    *   fixed echo_after_body in subrequests by using a hack (checking
+        "cl->buf->sync" for the last buf) for nginx 0.8.7+ only.
+
+    *   added new varaible $echo_response_status to help testing the status
+        code of a subrequest. (The memc module makes use of it.)
+
+    *   use the "ngx_calloc_buf" macro to allocate new bufs in the code
+        rather than explicit "ngx_pcalloc" calls for safety.
+
+  v0.22
+    *   Now we allowed all the directives appear in the rewrite module's if
+        block. But so far I've only tested the echo directive.
+
+  v0.21
+    *   Added a new directive named echo_exec which does internal redirect
+        to other (named) locations.
+
+  v0.20
+    *   Fixed a bug in echo_sleep's "r->main->count" handling for nginx
+        0.8.x. This bug will cause the server to hang when proxing a
+        location with echo_sleep.
+
+    *   Applied the "ngx_str3cmp", "ngx_str4cmp", and "ngx_str6cmp"
+        optimizing macros to the "parse_method_name" function, as suggested
+        by Marcus Clyne.
+
+    *   Added TODO items regarding $echo_random and "echo_repeat" suggested
+        by Marcus Clyne.
+
+  v0.19
+    *   Fixed the CPS-style chained subrequest model for the echo_location
+        and echo_subrequest directives. they are now working perfectly and
+        will not hang the server with the recent nginx 0.8.21 ~ 0.8.27
+        releases. To be specifically, the chained subrequest should call
+        "ngx_http_finalize_request" on its parent request if the content
+        handler of the parent request does not return "NGX_DONE".
+
+    *   Undeprecated the echo_location and echo_subrequest directives.
+
+  v0.18
+    *   Fixed the "zero size buf in output" alerts in error.log.
+
+    *   Added the new directive echo_request_body.
+
+    *   Now we use the "ngx_http_parse_unsafe_uri" function to check the
+        locations to echo_location_async and its friends. Thanks Arvind
+        Jayaprakash for suggesting this fix.
+
+    *   Deprecated the echo_location and echo_subrequest directives.
+
+    *   For HTTP 1.0 clients, use the buf length of the first chain link as
+        the output header Content-Length.
+
+    *   Implemented new variable $echo_incr.
+
+  v0.17
+    *   Added new directives echo_foreach_split and echo_end. Also
+        introduced a "topic variable" named $echo_it.
+
+    *   Added new variables $echo_request_uri and
+        $echo_cacheable_request_uri.
+
+  v0.16
+    *   Now the subrequests issued by the echo_location_async and
+        echo_location directives no longer inherit cached variable values
+        from its parent request. (The underlying "ngx_http_subrequest"
+        function, however, does automatic cachable variable value
+        inheritance.)
+
+    *   Added an undocumented variable *echo_cached_request_uri* to help
+        testing of this module.
+
+  v0.15
+    *   Added new directives echo_subrequest and echo_subrequest_async for
+        the full nginx subrequest API.
+
+    *   Removed the "echo_client_request_headers" directive, and provided
+        the $echo_client_request_headers variable instead.
+
+    *   Added new variables $echo_request_method and
+        $echo_client_request_method.
+
+  v0.14
+    *   Added new directive echo_read_request_body to explicitly read client
+        request body so that the [[NginxHttpCoreModule#$request_body]]
+        variable will always have non-empty values.
+
+    *   Now we shuffer test cases automatically in .t files and fixed bugs
+        in the tests themselves which are hidden by config reload fallback
+        in failure.
+
+  v0.13
+    *   Fixed the special cases when the outputs of a echo_duplicate
+        directive is empty.
+
+    *   Now we explicitly clear content length and accept ranges headers in
+        the content handler.
+
+  v0.12
+    *   Implemented the echo_location directive, which can issue chained GET
+        subrequests in the Continuation Passing Style (CPS), rather than the
+        parallel subrequest issued by the echo_location_async directive.
+
+  v0.11
+    *   Implemented the echo_duplicate directive to help generating large
+        chunk of data for testing.
+
+  v0.10
+    *   Fixed compilation regression against Nginx 0.7.21. This bug appears
+        in version 0.09.
+
+    *   Refactored the codebase by splitting source into various small
+        files.
+
+  v0.09
+    *   Reimplement the echo_sleep directive using per-request event and
+        timer; the old implementation uses the global connection's
+        read/write event to register timer, so it will break horribly when
+        multiple subrequests "sleep" at the same time.
+
+    *   Added the echo_location_async directive which can issue a GET
+        subrequest and insert its contents herein.
+
+  v0.08
+    *   echo_sleep: now we delete our "write event timer" in the
+        "post_sleep" handle.
+
+    *   Added "doc/manpage.wiki" which tracks changes in the wiki page
+        (<http://wiki.nginx.org/NginxHttpEchoModule >).
+
+    *   Added the "util/wiki2pod.pl" script to convert "doc/manpage.wiki" to
+        "README".
+
+    *   Disabled the "DDEBUG" macro in the C source by default.
+
+Test Suite
+    This module comes with a Perl-driven test suite. The test cases
+    (<http://github.com/agentzh/echo-nginx-module/tree/master/test/t/ >) are
+    declarative
+    (<http://github.com/agentzh/echo-nginx-module/blob/master/test/t/echo.t >
+    ) too. Thanks to the Test::Base
+    (<http://search.cpan.org/perldoc?Test::Base >) module in the Perl world.
+
+    To run it on your side:
+
+        $ cd test
+        $ PATH=/path/to/your/nginx-with-echo-module:$PATH prove -r t
+
+    You need to terminate any Nginx processes before running the test suite
+    if you have changed the Nginx server binary.
+
+    At the moment, LWP::UserAgent
+    (<http://search.cpan.org/perldoc?LWP::UserAgent >) is used by the test
+    scaffold
+    (<http://github.com/agentzh/echo-nginx-module/blob/master/test/lib/Test/
+    Nginx/Echo.pm>) for simplicity and it's rather weak in testing
+    *streaming* behavior of Nginx (I'm using "curl" to test these aspects
+    manually for now). I'm considering coding up my own Perl HTTP client
+    library based on IO::Select
+    (<http://search.cpan.org/perldoc?IO::Select >) and IO::Socket
+    (<http://search.cpan.org/perldoc?IO::Socket >) (there might be already
+    one around?).
+
+    Because a single nginx server (by default, "localhost:1984") is used
+    across all the test scripts (".t" files), it's meaningless to run the
+    test suite in parallel by specifying "-jN" when invoking the "prove"
+    utility.
+
+    Some parts of the test suite requires standard modules proxy, rewrite
+    and SSI to be enabled as well when building Nginx.
+
+TODO
+    *   Fix the echo_after_body directive in subrequests.
+
+    *   Add directives *echo_read_client_request_body* and
+        *echo_request_headers*.
+
+    *   Add new directive *echo_log* to use Nginx's logging facility
+        directly from the config file and specific loglevel can be
+        specified, as in
+
+      echo_log debug "I am being called.";
+
+    *   Add support for options "-h" and "-t" to echo_subrequest_async and
+        echo_subrequest. For example
+
+      echo_subrequest POST /sub -q 'foo=Foo&bar=Bar' -b 'hello' -t 'text/plan' -h 'X-My-Header: blah blah'
+
+    *   Add options to control whether a subrequest should inherit cached
+        variables from its parent request (i.e. the current request that is
+        calling the subrequest in question). Currently none of the
+        subrequests issued by this module inherit the cached variables from
+        the parent request.
+
+    *   Add new variable *$echo_active_subrequests* to show "r->main->count
+        - 1".
+
+    *   Add the *echo_file* and *echo_cached_file* directives.
+
+    *   Add new varaible *$echo_request_headers* to accompany the existing
+        $echo_client_request_headers variable.
+
+    *   Add new directive *echo_foreach*, as in
+
+      echo_foreach 'cat' 'dog' 'mouse';
+        echo_location_async "/animals/$echo_it";
+      echo_end;
+
+    *   Add new directive *echo_foreach_range*, as in
+
+      echo_foreach_range '[1..100]' '[a-zA-z0-9]';
+        echo_location_async "/item/$echo_it";
+      echo_end;
+
+    *   Add new directive *echo_repeat*, as in
+
+      echo_repeat 10 $i {
+          echo "Page $i";
+          echo_location "/path/to/page/$i";
+      }
+
+    This is just another way of saying
+
+      echo_foreach_range $i [1..10];
+          echo "Page $i";
+          echo_location "/path/to/page/$i";
+      echo_end;
+
+    Thanks Marcus Clyne for providing this idea.
+
+    *   Add new variable $echo_random which always returns a random
+        non-negative integer with the lower/upper limit specified by the new
+        directives "echo_random_min" and "echo_random_max". For example,
+
+      echo_random_min  10
+      echo_random_max  200
+      echo "random number: $echo_random";
+
+    Thanks Marcus Clyne for providing this idea.
+
+Getting involved
+    You'll be very welcomed to submit patches to the author or just ask for
+    a commit bit to the source repository on GitHub.
+
+Author
+    agentzh (章亦春) *<agentzh@gmail.com>*
+
+    This wiki page is also maintained by the author himself, and everybody
+    is encouraged to improve this page as well.
+
+Copyright & License
+    Copyright (c) 2009, Taobao Inc., Alibaba Group ( http://www.taobao.com
+    ).
+
+    Copyright (c) 2009, agentzh <agentzh@gmail.com>.
+
+    This module is licensed under the terms of the BSD license.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    *   Redistributions of source code must retain the above copyright
+        notice, this list of conditions and the following disclaimer.
+
+    *   Redistributions in binary form must reproduce the above copyright
+        notice, this list of conditions and the following disclaimer in the
+        documentation and/or other materials provided with the distribution.
+
+    *   Neither the name of the Taobao Inc. nor the names of its
+        contributors may be used to endorse or promote products derived from
+        this software without specific prior written permission.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+    TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+    PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+    LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+    NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+    SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+See Also
+    *   The original blog post
+        (<http://agentzh.spaces.live.com/blog/cns!FF3A735632E41548!478.entry
+        >) about this module's initial development.
+
+    *   The standard addition filter module.
+
+    *   The standard proxy module.
+
Index: 0.8/modules/nginx-echo/config
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/config	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,5 @@
+ngx_addon_name=ngx_http_echo_module
+HTTP_AUX_FILTER_MODULES="$HTTP_AUX_FILTER_MODULES ngx_http_echo_module"
+NGX_ADDON_SRCS="$NGX_ADDON_SRCS $ngx_addon_dir/src/ngx_http_echo_module.c $ngx_addon_dir/src/ngx_http_echo_util.c $ngx_addon_dir/src/ngx_http_echo_timer.c $ngx_addon_dir/src/ngx_http_echo_var.c $ngx_addon_dir/src/ngx_http_echo_handler.c $ngx_addon_dir/src/ngx_http_echo_filter.c $ngx_addon_dir/src/ngx_http_echo_sleep.c $ngx_addon_dir/src/ngx_http_echo_location.c $ngx_addon_dir/src/ngx_http_echo_echo.c $ngx_addon_dir/src/ngx_http_echo_request_info.c $ngx_addon_dir/src/ngx_http_echo_subrequest.c $ngx_addon_dir/src/ngx_http_echo_foreach.c"
+NGX_ADDON_DEPS="$NGX_ADDON_DEPS $ngx_addon_dir/src/ngx_http_echo_module.h $ngx_addon_dir/src/ddebug.h $ngx_addon_dir/src/ngx_http_echo_handler.h $ngx_addon_dir/src/ngx_http_echo_util.h $ngx_addon_dir/src/ngx_http_echo_sleep.h $ngx_addon_dir/src/ngx_http_echo_filter.h $ngx_addon_dir/src/ngx_http_echo_var.h $ngx_addon_dir/src/ngx_http_echo_location.h $ngx_addon_dir/src/ngx_http_echo_echo.h $ngx_addon_dir/src/ngx_http_echo_request_info.h $ngx_addon_dir/src/ngx_http_echo_subrequest.h $ngx_addon_dir/src/ngx_http_echo_foreach.h"
+
Index: 0.8/modules/nginx-echo/doc/manpage.wiki
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/doc/manpage.wiki	2010-10-31 07:35:47.708338000 +0000
@@ -0,0 +1,1545 @@
+﻿= Name =
+
+'''ngx_echo''' - Brings "echo", "sleep", "time", "exec" and more shell-style goodies to Nginx config file.
+
+''This module is not distributed with the Nginx source.'' See [[#Installation|the installation instructions]].
+
+= Version =
+
+This document describes echo-nginx-module [http://github.com/agentzh/echo-nginx-module/tarball/v0.34 v0.34] released on September 14, 2010.
+
+= Synopsis =
+
+<geshi lang="nginx">
+  location /hello {
+    echo "hello, world!";
+  }
+</geshi>
+
+<geshi lang="nginx">
+  location /hello {
+    echo -n "hello, "
+    echo "world!";
+  }
+</geshi>
+
+<geshi lang="nginx">
+  location /timed_hello {
+    echo_reset_timer;
+    echo hello world;
+    echo "'hello world' takes about $echo_timer_elapsed sec.";
+    echo hiya igor;
+    echo "'hiya igor' takes about $echo_timer_elapsed sec.";
+  }
+</geshi>
+
+<geshi lang="nginx">
+  location /echo_with_sleep {
+    echo hello;
+    echo_flush;  # ensure the client can see previous output immediately
+    echo_sleep   2.5;  # in sec
+    echo world;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # in the following example, accessing /echo yields
+  #   hello
+  #   world
+  #   blah
+  #   hiya
+  #   igor
+  location /echo {
+      echo_before_body hello;
+      echo_before_body world;
+      proxy_pass $scheme://127.0.0.1:$server_port$request_uri/more;
+      echo_after_body hiya;
+      echo_after_body igor;
+  }
+  location /echo/more {
+      echo blah;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # the output of /main might be
+  #   hello
+  #   world
+  #   took 0.000 sec for total.
+  # and the whole request would take about 2 sec to complete.
+  location /main {
+      echo_reset_timer;
+
+      # subrequests in parallel
+      echo_location_async /sub1;
+      echo_location_async /sub2;
+
+      echo "took $echo_timer_elapsed sec for total.";
+  }
+  location /sub1 {
+      echo_sleep 2;
+      echo hello;
+  }
+  location /sub2 {
+      echo_sleep 1;
+      echo world;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # the output of /main might be
+  #   hello
+  #   world
+  #   took 3.003 sec for total.
+  # and the whole request would take about 3 sec to complete.
+  location /main {
+      echo_reset_timer;
+
+      # subrequests in series (chained by CPS)
+      echo_location /sub1;
+      echo_location /sub2;
+
+      echo "took $echo_timer_elapsed sec for total.";
+  }
+  location /sub1 {
+      echo_sleep 2;
+      echo hello;
+  }
+  location /sub2 {
+      echo_sleep 1;
+      echo world;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # Accessing /dup gives
+  #   ------ END ------
+  location /dup {
+    echo_duplicate 3 "--";
+    echo_duplicate 1 " END ";
+    echo_duplicate 3 "--";
+    echo;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # /bighello will generate 1000,000,000 hello's.
+  location /bighello {
+    echo_duplicate 1000_000_000 'hello';
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # echo back the client request
+  location /echoback {
+    echo_duplicate 1 $echo_client_request_headers;
+    echo "\r";
+
+    echo_read_request_body;
+
+    echo_request_body;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # GET /multi will yields
+  #   querystring: foo=Foo
+  #   method: POST
+  #   body: hi
+  #   content length: 2
+  #   ///
+  #   querystring: bar=Bar
+  #   method: PUT
+  #   body: hello
+  #   content length: 5
+  #   ///
+  location /multi {
+      echo_subrequest_async POST '/sub' -q 'foo=Foo' -b 'hi';
+      echo_subrequest_async PUT '/sub' -q 'bar=Bar' -b 'hello';
+  }
+  location /sub {
+      echo "querystring: $query_string";
+      echo "method: $echo_request_method";
+      echo "body: $echo_request_body";
+      echo "content length: $http_content_length";
+      echo '///';
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # GET /merge?/foo.js&/bar/blah.js&/yui/baz.js will merge the .js resources together
+  location /merge {
+      default_type 'text/javascript';
+      echo_foreach_split '&' $query_string;
+          echo "/* JS File $echo_it */";
+          echo_location_async $echo_it;
+          echo;
+      echo_end;
+  }
+</geshi>
+
+<geshi lang="nginx">
+  # accessing /if?val=abc yields the "hit" output
+  # while /if?val=bcd yields "miss":
+  location ^~ /if {
+      set $res miss;
+      if ($arg_val ~* '^a') {
+          set $res hit;
+          echo $res;
+      }
+      echo $res;
+  }
+</geshi>
+
+= Description =
+
+This module wraps lots of Nginx internal APIs for streaming input and output, parallel/sequential subrequests, timers and sleeping, as well as various meta data accessing.
+
+Basically it provides various utilities that help testing and debugging of other modules by trivially emulating different kinds of faked subrequest locations.
+
+People will also find it useful in real-world applications that need to
+
+# serve static contents directly from memory (loading from the Nginx config file).
+# wrap the upstream response with custom header and footer (kinda like the [[NginxHttpAdditionModule|addition module]] but with contents read directly from the config file and Nginx variables).
+# merge contents of various "Nginx locations" (i.e., subrequests) together in a single main request (using [[#echo_location|echo_location]] and its friends).
+
+This is a special dual-role module that can ''lazily'' serve as a content handler or register itself as an output filter only upon demand. By default, this module does not do anything at all.
+
+Use of any of this module's directives (no matter [[#Content Handler Directives|content handler directives]] or [[#Filter Directives|filter directives]]) will force the chunked encoding to be used for the HTTP response due to the streaming nature of this module (unless HTTP 1.0 is enforced by the client and the Content-Length header will be set to the size of the first handler directive that generates contents).
+
+Technially, this module has also demonstrated the following techniques that might be helpful for module writers:
+
+# Issue parallel subreqeusts directly from content handler.
+# Issue chained subrequests directly from content handler, by passing continuation along the subrequest chain.
+# Issue subrequests with all HTTP 1.1 methods and even an optional faked HTTP request body.
+# Interact with the Nginx event model directly from content handler using custom events and timers, and resume the content handler back if necessary.
+# Dual-role module that can (lazily) serve as a content handler or an output filter or both.
+# Nginx config file variable creation and interpolation.
+# Streaming output control using output_chain, flush and its friends.
+# Read client request body from the content handler, and returns back (asynchronously) to the content handler after completion.
+# Use Perl-based declarative [[#Test Suite|test suite]] to drive the development of Nginx C modules.
+
+= Content Handler Directives =
+
+Use of the following directives register this module to the current Nginx location as a content handler. If you want to use another module, like the [[NginxHttpProxyModule|standard proxy module]], as the content handler, use the [[#Filter Directives|filter directives]] provided by this module.
+
+All the content handler directives can be mixed together in a single Nginx location and they're supposed to run sequentially just as in the Bash scripting language.
+
+Every content handler directive supports variable interpolation in its arguments (if any).
+
+The MIME type set by the [[NginxHttpCoreModule#default_type|standard default_type directive]] is respected by this module, as in:
+
+<geshi lang="nginx">
+  location /hello {
+    default_type text/plain;
+    echo hello;
+  }
+</geshi>
+
+Then on the client side:
+
+<geshi lang="bash">
+  $ curl -I 'http://localhost/echo'
+  HTTP/1.1 200 OK
+  Server: nginx/0.8.20
+  Date: Sat, 17 Oct 2009 03:40:19 GMT
+  Content-Type: text/plain
+  Connection: keep-alive
+</geshi>
+
+Since the [[#v0.22|v0.22]] release, all of the directives are allowed in the [[NginxHttpRewriteModule|rewrite module]]'s [[NginxHttpRewriteModule#if|if]] directive block, for instance:
+
+<geshi lang="nginx">
+    location ^~ /if {
+        set $res miss;
+        if ($arg_val ~* '^a') {
+            set $res hit;
+            echo $res;
+        }
+        echo $res;
+    }
+</geshi>
+
+== echo ==
+'''syntax:''' ''echo [options] <string>...''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Sends arguments joined by spaces, along with a trailing newline, out to the client.
+
+Note that the data might be buffered by Nginx's underlying buffer. To force the output data flushed immediately, use the [[#echo_flush|echo_flush]] command just after <code>echo</code>, as in
+
+<geshi lang="nginx">
+   echo hello world;
+   echo_flush;
+</geshi>
+
+When no argument is specified, ''echo'' emits the trailing newline alone, just like the ''echo'' command in shell.
+
+Variables may appear in the arguments. An example is
+
+<geshi lang="nginx">
+   echo The current request uri is $request_uri;
+</geshi>
+
+where [[NginxHttpCoreModule#$request_uri|$request_uri]] is a variable exposed by the [[NginxHttpCoreModule]].
+
+This command can be used multiple times in a single location configuration, as in
+
+<geshi lang="nginx">
+    location /echo {
+        echo hello;
+        echo world;
+    }
+</geshi>
+
+The output on the client side looks like this
+
+<geshi lang="bash">
+    $ curl 'http://localhost/echo'
+    hello
+    world
+</geshi>
+
+Special characters like newlines (<code>\n</code>) and tabs (<code>\t</code>) can be escaped using C-style escaping sequences. But a notable exception is the dollar sign (<code>$</code>). As of Nginx 0.8.20, there's still no clean way to esacpe this characters. (A work-around might be to use a <code>$echo_dollor</code> variable that is always evaluated to the constant <code>$</code> character. This feature will possibly be introduced in a future version of this module.)
+
+As of the echo [[#v0.28|v0.28]] release, one can suppress the trailing newline character in the output by using the <code>-n</code> option, as in
+
+<geshi lang="nginx">
+    location /echo {
+        echo -n "hello, ";
+        echo "world";
+    }
+</geshi>
+
+Accessing <code>/echo</code> gives
+
+<geshi lang="bash">
+    $ curl 'http://localhost/echo'
+    hello, world
+</geshi>
+
+Leading <code>-n</code> in variable values won't take effect and will be emitted literally, as in
+
+<geshi lang="nginx">
+    location /echo {
+        set $opt -n;
+        echo $opt "hello,";
+        echo "world";
+    }
+</geshi>
+
+This gives the following output
+
+<geshi lang="bash">
+    $ curl 'http://localhost/echo'
+    -n hello,
+    world
+</geshi>
+
+One can output leading <code>-n</code> literals and other options using the special <code>--</code> option like this
+
+<geshi lang="nginx">
+    location /echo {
+        echo -- -n is an option;
+    }
+</geshi>
+
+which yields
+
+<geshi lang="bash">
+    $ curl 'http://localhost/echo'
+    -n is an option
+</geshi>
+
+== echo_duplicate ==
+'''syntax:''' ''echo_duplicate <count> <string>''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Outputs duplication of a string indicated by the second argument, using the times specified in the first argument.
+
+For instance,
+
+<geshi lang="nginx">
+  location /dup {
+      echo_duplicate 3 "abc";
+  }
+</geshi>
+
+will lead to an output of <code>"abcabcabc"</code>.
+
+Underscores are allowed in the count number, just like in Perl. For example, to emit 1000,000,000 instances of <code>"hello, world"</code>:
+
+<geshi lang="nginx">
+  location /many_hellos {
+      echo_duplicate 1000_000_000 "hello, world";
+  }
+</geshi>
+
+The <code>count</code> argument could be zero, but not negative. The second <code>string</code> argument could be an empty string ("") likewise.
+
+Unlike the [[#echo|echo]] directive, no trailing newline is appended to the result. So it's possible to "abuse" this directive as a no-trailing-newline version of [[#echo|echo]] by using "count" 1, as in
+
+<geshi lang="nginx">
+  location /echo_art {
+      echo_duplicate 2 '---';
+      echo_duplicate 1 ' END ';  # we don't want a trailing newline here
+      echo_duplicate 2 '---';
+      echo;  # we want a trailing newline here...
+  }
+</geshi>
+
+You get
+
+  ------ END ------
+
+This directive was first introduced in [[#v0.11|version 0.11]].
+
+== echo_flush ==
+'''syntax:''' ''echo_flush''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Forces the data potentially buffered by underlying Nginx output filters to send immediately to the client side via socket.
+
+Note that techically the command just emits a ngx_buf_t object with <code>flush</code> slot set to 1, so certain weird third-party output filter module could still block it before it reaches Nginx's (last) write filter.
+
+This directive does not take any argument.
+
+Consider the following example:
+
+<geshi lang="nginx">
+  location /flush {
+     echo hello;
+
+     echo_flush;
+
+     echo_sleep 1;
+     echo world;
+  }
+</geshi>
+
+Then on the client side, using curl to access <code>/flush</code>, you'll see the "hello" line immediately, but only after 1 second, the last "world" line. Without calling <code>echo_flush</code> in the example above, you'll most likely see no output until 1 second is elapsed due to the internal buffering of Nginx.
+
+This directive will fail to flush the output buffer in case of subrequests get involved. Consider the following example:
+
+  location /main {
+      echo_location_async /sub;
+      echo hello;
+      echo_flush;
+  }
+  location /sub {
+      echo_sleep 1;
+  }
+
+Then the client won't see "hello" appear even if <code>echo_flush</code> has been executed before the subrequest to <code>/sub</code> has actually started executing. The outputs of <code>/main</code> that are sent ''after'' [[#echo_location_async|echo_location_async]] will be postponed and buffered firmly.
+
+This does ''not'' apply to outputs sent before the subrequest initiated. For a modified version of the example given above:
+
+  location /main {
+      echo hello;
+      echo_flush;
+      echo_location_async /sub;
+  }
+  location /sub {
+      echo_sleep 1;
+  }
+
+The client will immediately see "hello" before <code>/sub</code> enters sleeping.
+
+See also [[#echo|echo]], [[#echo_sleep|echo_sleep]], and [[#echo_location_async|echo_location_async]].
+
+== echo_sleep ==
+'''syntax:''' ''echo_sleep <seconds>''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Sleeps for the time period specified by the argument, which is in seconds.
+
+This operation is non-blocking on server side, so unlike the [[#echo_blocking_sleep|echo_blocking_sleep]] directive, it won't block the whole Nginx worker process.
+
+The period might takes three digits after the decimal point and must be greater than 0.001.
+
+An example is
+
+<geshi lang="nginx">
+   location /echo_after_sleep {
+       echo_sleep 1.234;
+       echo resumed!;
+   }
+</geshi>
+
+Behind the scene, it sets up a per-request "sleep" ngx_event_t object, and adds a timer using that custom event to the Nginx event model and just waits for a timeout on that event. Because the "sleep" event is per-request, this directive can work in parallel subrequests.
+
+== echo_blocking_sleep ==
+'''syntax:''' ''echo_blocking_sleep <seconds>''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+This is a blocking version of the [[#echo_sleep|echo_sleep]] directive.
+
+See the documentation of [[#echo_sleep|echo_sleep]] for more detail.
+
+Behind the curtain, it calls the ngx_msleep macro provided by the Nginx core which maps to usleep on POSIX-compliant systems.
+
+Note that this directive will block the current Nginx worker process completely while being executed, so never use it in production environment.
+
+== echo_reset_timer ==
+'''syntax:''' ''echo_reset_timer''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Reset the timer begin time to ''now'', i.e., the time when this command is executed during request.
+
+The timer begin time is default to the starting time of the current request and can be overridden by this directive, potentially multiple times in a single location. For example:
+
+<geshi lang="nginx">
+  location /timed_sleep {
+      echo_sleep 0.03;
+      echo "$echo_timer_elapsed sec elapsed.";
+
+      echo_reset_timer;
+
+      echo_sleep 0.02;
+      echo "$echo_timer_elapsed sec elapsed.";
+  }
+</geshi>
+
+The output on the client side might be
+
+<geshi lang="bash">
+    $ curl 'http://localhost/timed_sleep'
+    0.032 sec elapsed.
+    0.020 sec elapsed.
+</geshi>
+
+The actual figures you get on your side may vary a bit due to your system's current activities.
+
+Invocation of this directive will force the underlying Nginx timer to get updated to the current system time (regardless the timer resolution specified elsewhere in the config file). Furthermore, references of the [[#$echo_timer_elapsed|$echo_timer_elapsed]] variable will also trigger timer update forcibly.
+
+See also [[#echo_sleep|echo_sleep]] and [[#$echo_timer_elapsed|$echo_timer_elapsed]].
+
+== echo_read_request_body ==
+
+Explicitly reads request body so that the [[NginxHttpCoreModule#$request_body|$request_body]] variable will always have non-empty values (unless the body is so big that it has been saved by Nginx to a local temporary file).
+
+Note that this might not be the original client request body because the current request might be a subrequest with a "artificial" body specified by its parent.
+
+This directive does not generate any output itself, just like [[#echo_sleep|echo_sleep]].
+
+Here's an example for echo'ing back the original HTTP client request (both headers and body are included):
+
+<geshi lang="nginx">
+  location /echoback {
+    echo_duplicate 1 $echo_client_request_headers;
+    echo "\r";
+    echo_read_request_body;
+    echo $request_body;
+  }
+</geshi>
+
+The content of <code>/echoback</code> looks like this on my side (I was using Perl's LWP utility to access this location on the server):
+
+<geshi lang="bash">
+  $ (echo hello; echo world) | lwp-request -m POST 'http://localhost/echoback'
+  POST /echoback HTTP/1.1
+  TE: deflate,gzip;q=0.3
+  Connection: TE, close
+  Host: localhost
+  User-Agent: lwp-request/5.818 libwww-perl/5.820
+  Content-Length: 12
+  Content-Type: application/x-www-form-urlencoded
+
+  hello
+  world
+</geshi>
+
+Because <code>/echoback</code> is the main request, [[NginxHttpCoreModule#$request_body|$request_body]] holds the original client request body.
+
+Before Nginx 0.7.56, it makes no sense to use this directive because [[NginxHttpCoreModule#$request_body|$request_body]] was first introduced in Nginx 0.7.58.
+
+This directive itself was first introduced in the echo module's [[#v0.14|v0.14 release]].
+
+== echo_location_async ==
+'''syntax:''' ''echo_location_async <location> [<url_args>]''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Issue GET subrequest to the location specified (first argument) with optional url arguments specified in the second argument.
+
+As of Nginx 0.8.20, the <code>location</code> argument does ''not'' support named location, due to a limitation in the <code>ngx_http_subrequest</code> function. The same is true for its brother, the [[#echo_location|echo_location]] directive.
+
+A very simple example is
+
+<geshi lang="nginx">
+    location /main {
+        echo_location_async /sub;
+        echo world;
+    }
+    location /sub {
+        echo hello;
+    }
+</geshi>
+
+Accessing <code>/main</code> gets
+
+  hello
+  world
+
+Calling multiple locations in parallel is also possible:
+
+<geshi lang="nginx">
+    location /main {
+        echo_reset_timer;
+        echo_location_async /sub1;
+        echo_location_async /sub2;
+        echo "took $echo_timer_elapsed sec for total.";
+    }
+    location /sub1 {
+        echo_sleep 2; # sleeps 2 sec
+        echo hello;
+    }
+    location /sub2 {
+        echo_sleep 1; # sleeps 1 sec
+        echo world;
+    }
+</geshi>
+
+Accessing <code>/main</code> yields
+
+<geshi lang="bash">
+  $ time curl 'http://localhost/main'
+  hello
+  world
+  took 0.000 sec for total.
+
+  real	0m2.006s
+  user	0m0.000s
+  sys	0m0.004s
+</geshi>
+
+You can see that the main handler <code>/main</code> does ''not'' wait the subrequests <code>/sub1</code> and <code>/sub2</code> to complete and quickly goes on, hence the "0.000 sec" timing result. The whole request, however takes approximately 2 sec in total to complete because <code>/sub1</code> and <code>/sub2</code> run in parallel (or "concurrently" to be more accurate).
+
+If you use [[#echo_blocking_sleep|echo_blocking_sleep]] in the previous example instead, then you'll get the same output, but with 3 sec total response time, because "blocking sleep" blocks the whole Nginx worker process.
+
+Locations can also take an optional querystring argument, for instance
+
+<geshi lang="nginx">
+    location /main {
+        echo_location_async /sub 'foo=Foo&bar=Bar';
+    }
+    location /sub {
+        echo $arg_foo $arg_bar;
+    }
+</geshi>
+
+Accessing <code>/main</code> yields
+
+<geshi lang="bash">
+  $ curl 'http://localhost/main'
+  Foo Bar
+</geshi>
+
+Querystrings is ''not'' allowed to be concatenated onto the <code>location</code> argument with "?" directly, for example, <code>/sub?foo=Foo&bar=Bar</code> is an invalid location, and shouldn't be fed as the first argument to this directive.
+
+Due to an unknown bug in Nginx (it still exists in Nginx 0.8.20), the [[NginxHttpSsiModule|standard SSI module]] is required to ensure that the contents of the subrequests issued by this directive are correctly merged into the output chains of the main one. Fortunately, the SSI module is enabled by default during Nginx's <code>configure</code> process.
+
+If calling this directive without SSI module enabled, you'll get truncated response without contents of any subrequests and get an alert message in your Nginx's <code>error.log</code>, like this:
+
+  [alert] 24212#0: *1 the http output chain is empty, client: 127.0.0.1, ...
+
+Technically speaking, this directive is an example that Nginx content handler issues one or more subrequests directly. AFAIK, the [https://connectical.com/projects/ngx-fancyindex/wiki fancyindex module] also does such kind of things ;)
+
+Nginx named locations like <code>@foo</code> is ''not'' supported here.
+
+This directive is logically equivalent to the GET version of [[#echo_subrequest_async|echo_subrequest_async]]. For example,
+
+  echo_location_async /foo 'bar=Bar';
+
+is logically equivalent to
+
+  echo_subrequest_async GET /foo -q 'bar=Bar';
+
+But calling this directive is slightly faster than calling [[#echo_subrequest_async|echo_subrequest_async]] using <code>GET</code> because we don't have to parse the HTTP method names like <code>GET</code> and options like <code>-q</code>.
+
+This directive is first introduced in [[#v0.09|version 0.09]] of this module and requires at least Nginx 0.7.46.
+
+== echo_location ==
+'''syntax:''' ''echo_location <location> [<url_args>]''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Just like the [[#echo_location_async|echo_location_async]] directive, but <code>echo_location</code> issues subrequests ''in series'' rather than in parallel. That is, the content handler directives following this directive won't be executed until the subrequest issued by this directive completes.
+
+The final response body is almost always equivalent to the case when [[#echo_location_async|echo_location_async]] is used instead, only if timing variables is used in the outputs.
+
+Consider the following example:
+
+    location /main {
+        echo_reset_timer;
+        echo_location /sub1;
+        echo_location /sub2;
+        echo "took $echo_timer_elapsed sec for total.";
+    }
+    location /sub1 {
+        echo_sleep 2;
+        echo hello;
+    }
+    location /sub2 {
+        echo_sleep 1;
+        echo world;
+    }
+
+The location <code>/main</code> above will take for total 3 sec to complete (compared to 2 sec if [[#echo_location_async|echo_location_async]] is used instead here). Here's the result in action on my machine:
+
+  $ curl 'http://localhost/main'
+  hello
+  world
+  took 3.003 sec for total.
+
+  real	0m3.027s
+  user	0m0.020s
+  sys	0m0.004s
+
+This directive is logically equivalent to the GET version of [[#echo_subrequest|echo_subrequest]]. For example,
+
+  echo_location /foo 'bar=Bar';
+
+is logically equivalent to
+
+  echo_subrequest GET /foo -q 'bar=Bar';
+
+But calling this directive is slightly faster than calling [[#echo_subrequest|echo_subrequest]] using <code>GET</code> because we don't have to parse the HTTP method names like <code>GET</code> and options like <code>-q</code>.
+
+Behind the scene, it creates an <code>ngx_http_post_subrequest_t</code> object as a ''continuation'' and passes it into the <code>ngx_http_subrequest</code> function call. Nginx will later reopen this "continuation" in the subrequest's <code>ngx_http_finalize_request</code> function call. We resumes the execution of the parent-request's content handler and starts to run the next directive (command) if any.
+
+Nginx named locations like <code>@foo</code> is ''not'' supported here.
+
+This directive was first introduced in the [[#v0.12|release v0.12]].
+
+See also [[#echo_location_async|echo_location_async]] for more details about the meaning of the arguments.
+
+== echo_subrequest_async ==
+'''syntax:''' ''echo_subrequest_async <HTTP_method> <location> [-q <url_args>] [-b <request_body>]''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Initiate an asynchronous subrequest using HTTP method, an optional url arguments (or querystring), and an option request body.
+
+This directive is very much like a generalized version of the [[#echo_location_async|echo_location_async]] directive.
+
+Here's a small example demonstrating its usage:
+
+<geshi lang="nginx">
+    location /multi {
+        echo_subrequest_async POST '/sub' -q 'foo=Foo' -b 'hi';
+        echo_subrequest_async PUT '/sub' -q 'bar=Bar' -b 'hello';
+    }
+    location /sub {
+        echo "querystring: $query_string";
+        echo "method: $echo_request_method";
+        echo "body: $echo_request_body";
+        echo "content length: $http_content_length";
+        echo '///';
+    }
+</geshi>
+
+Then on the client side:
+
+<geshi lang="bash">
+  $ curl 'http://localhost/multi'
+  querystring: foo=Foo
+  method: POST
+  body: hi
+  content length: 2
+  ///
+  querystring: bar=Bar
+  method: PUT
+  body: hello
+  content length: 5
+  ///
+</geshi>
+
+Here's more funny example using the standard [[#NginxHttpProxyModule|proxy module]] to handle the subrequest:
+
+<geshi lang="nginx">
+    location /main {
+        echo_subrequest_async POST /sub -b 'hello, world';
+    }
+    location /sub {
+        proxy_pass $scheme://127.0.0.1:$server_port/proxied;
+    }
+    location /proxied {
+        echo "method: $echo_request_method.";
+
+        # we need to read body explicitly here...or $echo_request_body
+        #   will evaluate to empty ("")
+        echo_read_request_body;
+
+        echo "body: $echo_request_body.";
+    }
+</geshi>
+
+Then on the client side, we can see that
+
+<geshi lang="bash">
+  $ curl 'http://localhost/main'
+  method: POST.
+  body: hello, world.
+</geshi>
+
+Nginx named locations like <code>@foo</code> is ''not'' supported here.
+
+This directive was first introduced in the [[#v0.15|release v0.15]].
+
+See also the [[#echo_subrequest|echo_subrequest]] and [[#echo_location_async|echo_location_async]] directives.
+
+== echo_subrequest ==
+'''syntax:''' ''echo_subrequest_async <HTTP_method> <location> [-q <url_args>] [-b <request_body>]''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+This is the synchronous version of the [[#echo_subrequest_async|echo_subrequest_async]] directive. And just like [[#echo_location|echo_location]], it does not block the Nginx worker process (while [[#echo_blocking_sleep|echo_blocking_sleep]] does), rather, it uses continuation to pass control along the subrequest chain.
+
+See [[#echo_subrequest_async|echo_subrequest_async]] for more details.
+
+Nginx named locations like <code>@foo</code> is ''not'' supported here.
+
+This directive was first introduced in the [[#v0.15|release v0.15]].
+
+== echo_foreach_split ==
+'''syntax:''' ''echo_foreach_split <delimiter> <string>''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Split the second argument <code>string</code> using the delimiter specified in the first argument, and then iterate through the resulting items. For instance:
+
+<geshi lang="nginx">
+  location /loop {
+    echo_foreach_split ',' $arg_list;
+      echo "item: $echo_it";
+    echo_end;
+  }
+</geshi>
+
+Accessing /main yields
+
+<geshi lang="bash">
+  $ curl 'http://localhost/loop?list=cat,dog,mouse'
+  item: cat
+  item: dog
+  item: mouse
+</geshi>
+
+As seen in the previous example, this directive should always be accompanied by an [[#echo_end|echo_end]] directive.
+
+Parallel <code>echo_foreach_split</code> loops are allowed, but nested ones are currently forbidden.
+
+The <code>delimiter</code> argument could contain ''multiple'' arbitrary characters, like
+
+<geshi lang="nginx">
+  echo_foreach_split '-a-' 'cat-a-dog-a-mouse';
+    echo $echo_it;
+  echo_end;
+</geshi>
+
+Logically speaking, this looping structure is just the <code>foreach</code> loop combined with a <code>split</code> function call in Perl (using the previous example):
+
+<geshi lang="perl">
+   foreach (split ',', $arg_list) {
+       print "item $_\n";
+   }
+</geshi>
+
+People will also find it useful in merging multiple <code>.js</code> or <code>.css</code> resources into a whole. Here's an example:
+
+<geshi lang="nginx">
+  location /merge {
+      default_type 'text/javascript';
+
+      echo_foreach_split '&' $query_string;
+          echo "/* JS File $echo_it */";
+          echo_location_async $echo_it;
+          echo;
+      echo_end;
+  }
+</geshi>
+
+Then accessing /merge to merge the <code>.js</code> resources specified in the query string:
+
+<geshi lang="bash">
+  $ curl 'http://localhost/merge?/foo/bar.js&/yui/blah.js&/baz.js'
+</geshi>
+
+One can also use third-party Nginx cache module to cache the merged response generated by the <code>/merge</code> location in the previous example.
+
+This directive was first introduced in the [[#v0.17|release v0.17]].
+
+== echo_end ==
+'''syntax:''' ''echo_end''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+This directive is used to terminate the body of looping and conditional control structures like [[#echo_foreach_split|echo_foreach_split]].
+
+This directive was first introduced in the [[#v0.17|release v0.17]].
+
+== echo_request_body ==
+'''syntax:''' ''echo_request_body''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Outputs the contents of the request body previous read.
+
+Behind the scene, it's implemented roughly like this:
+
+<geshi lang="C">
+  if (r->request_body && r->request_body->bufs) {
+      return ngx_http_output_filter(r, r->request_body->bufs);
+  }
+</geshi>
+
+Unlike the [[#$echo_request_body|$echo_request_body]] and $request_body variables, this directive will show the whole request body even if some parts or all parts of it are saved in temporary files on the disk.
+
+It is a "no-op" if no request body has been read yet.
+
+This directive was first introduced in the [[#v0.18|release v0.18]].
+
+See also [[#echo_read_request_body|echo_read_request_body]] and the [[NginxHttpChunkinModule|chunkin module]].
+
+== echo_exec ==
+'''syntax:''' ''echo_exec <location> [<query_string>]''
+
+'''syntax:''' ''echo_exec <named_location>''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+Does an internal redirect to the location specified. An optional query string can be specified for normal locations, as in
+
+<geshi lang="nginx">
+  location /foo {
+      echo_exec /bar weight=5;
+  }
+  location /bar {
+      echo $arg_weight;
+  }
+</geshi>
+
+Or equivalently
+
+<geshi lang="nginx">
+  location /foo {
+      echo_exec /bar?weight=5;
+  }
+  location /bar {
+      echo $arg_weight;
+  }
+</geshi>
+
+Named locations are also supported. Here's an example:
+
+<geshi lang="nginx">
+  location /foo {
+      echo_exec @bar;
+  }
+  location @bar {
+      # you'll get /foo rather than @bar
+      #  due to a potential bug in nginx.
+      echo $echo_request_uri;
+  }
+</geshi>
+
+But query string (if any) will always be ignored for named location redirects due to a limitation in the <code>ngx_http_named_location</code> function.
+
+Never try to echo things before the <code>echo_exec</code> directive or you won't see the proper response of the location you want to redirect to. Because any echoing will cause the original location handler to send HTTP headers before the redirection happens.
+
+Technically speaking, this directive exposes the Nginx internal API functions <code>ngx_http_internal_redirect</code> and <code>ngx_http_named_location</code>.
+
+This directive was first introduced in the [[#v0.21|v0.21 release]].
+
+= Filter Directives =
+
+Use of the following directives trigger the filter registration of this module. By default, no filter will be registered by this module.
+
+Every filter directive supports variable interpolation in its arguments (if any).
+
+== echo_before_body ==
+'''syntax:''' ''echo_before_body [options] [argument]...''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+It's the filter version of the [[#echo|echo]] directive, and prepends its output to the beginning of the original outputs generated by the underlying content handler.
+
+An example is
+
+<geshi lang="nginx">
+    location /echo {
+        echo_before_body hello;
+        proxy_pass $scheme://127.0.0.1:$server_port$request_uri/more;
+    }
+    location /echo/more {
+        echo world
+    }
+</geshi>
+
+Accessing <code>/echo</code> from the client side yields
+
+  hello
+  world
+
+In the previous sample, we borrow the [[NginxHttpProxyModule|standard proxy module]] to serve as the underlying content handler that generates the "main contents".
+
+Multiple instances of this filter directive are also allowed, as in:
+
+<geshi lang="nginx">
+    location /echo {
+        echo_before_body hello;
+        echo_before_body world;
+        echo !;
+    }
+</geshi>
+
+On the client side, the output is like
+
+<geshi lang="bash">
+  $ curl 'http://localhost/echo'
+  hello
+  world
+  !
+</geshi>
+
+In this example, we also use the [[#Content Handler Directives|content handler directives]] provided by this module as the underlying content handler.
+
+This directive also supports the <code>-n</code> and <code>--</code> options like the [[#echo|echo]] directive.
+
+This directive can be mixed with its brother directive [[#echo_after_body|echo_after_body]].
+
+== echo_after_body ==
+'''syntax:''' ''echo_after_body [argument]...''
+
+'''default:''' ''no''
+
+'''context:''' ''location''
+
+'''WARNING''' this directive does not work for nginx >= 0.7.65.
+
+It's very much like the [[#echo_before_body|echo_before_body]] directive, but ''appends'' its output to the end of the original outputs generated by the underlying content handler.
+
+Here's a simple example:
+
+<geshi lang="nginx">
+    location /echo {
+        echo_after_body hello;
+        proxy_pass http://127.0.0.1:$server_port$request_uri/more;
+    }
+    location /echo/more {
+        echo world
+    }
+</geshi>
+
+Accessing <code>/echo</code> from the client side yields
+
+  world
+  hello
+
+Multiple instances are allowed, as in:
+
+<geshi lang="nginx">
+    location /echo {
+        echo_after_body hello;
+        echo_after_body world;
+        echo i;
+        echo say;
+    }
+</geshi>
+
+The output on the client side while accessing the <code>/echo</code> location looks like
+
+<geshi lang="bash">
+  i
+  say
+  hello
+  world
+</geshi>
+
+This directive also supports the <code>-n</code> and <code>--</code> options like the [[#echo|echo]] directive.
+
+When this directive is used in a location accessed by a subrequest, it replies on the <code>sync</code> flag set in a chain buffer to indicate the end of the output for nginx >= 0.8.7. This is a hack because Nginx does not provide a reliable way to determine the end of the output chain in a subrequest's output filter. Use it in subrequests with care.
+
+This directive can be mixed with its brother directive [[#echo_before_body|echo_before_body]].
+
+= Variables =
+
+== $echo_it ==
+
+This is a "topic variable" used by [[#echo_foreach_split|echo_foreach_split]], just like the <code>$_</code> variable in Perl.
+
+== $echo_timer_elapsed ==
+
+This variable holds the seconds elapsed since the start of the current request (might be a subrequest though) or the last invocation of the [[#echo_reset_timer|echo_reset_timer]] command.
+
+The timing result takes three digits after the decimal point.
+
+References of this variable will force the underlying Nginx timer to update to the current system time, regardless the timer resolution settings elsewhere in the config file, just like the [[#echo_reset_timer|echo_reset_timer]] directive.
+
+== $echo_request_body ==
+
+Evaluates to the current (sub)request's request body previously read if no part of the body has been saved to a temporary file. To always show the request body even if it's very large, use the [[#echo_request_body|echo_request_body]] directive.
+
+== $echo_request_method ==
+
+Evaluates to the HTTP request method of the current request (it can be a subrequest).
+
+Behind the scene, it just takes the string data stored in <code>r->method_name</code>.
+
+Compare it to the [[#$echo_client_request_method|$echo_client_request_method]] variable.
+
+At least for Nginx 0.8.20 and older, the [[NginxHttpCoreModule#$request_method|$request_method]] variable provided by the [[NginxHttpCoreModule|http core module]] is actually doing what our [[#$echo_client_request_method|$echo_client_request_method]] is doing.
+
+This variable was first introduced in our [[#v0.15|v0.15 release]].
+
+== $echo_client_request_method ==
+
+Always evaluates to the main request's HTTP method even if the current request is a subrequest.
+
+Behind the scene, it just takes the string data stored in <code>r->main->method_name</code>.
+
+Compare it to the [[#$echo_request_method|$echo_request_method]] variable.
+
+This variable was first introduced in our [[#v0.15|v0.15 release]].
+
+== $echo_client_request_headers ==
+
+Evaluates to the original client request's headers.
+
+Just as the name suggests, it will always take the main request (or the client request) even if it's currently executed in a subrequest.
+
+A simple example is below:
+
+<geshi lang="nginx">
+  location /echoback {
+     echo "headers are:"
+     echo $echo_client_request_headers;
+  }
+</geshi>
+
+Accessing <code>/echoback</code> yields
+
+<geshi lang="bash">
+  $ curl 'http://localhost/echoback'
+  headers are
+  GET /echoback HTTP/1.1
+  User-Agent: curl/7.18.2 (i486-pc-linux-gnu) libcurl/7.18.2 OpenSSL/0.9.8g
+  Host: localhost:1984
+  Accept: */*
+</geshi>
+
+Behind the scene, it recovers <code>r->main->header_in</code> on the C level and does not construct the headers itself by traversing parsed results in the request object, and strips the last (trailing) CRLF.
+
+This variable was first introduced in [[#v0.15|version 0.15]].
+
+== $echo_cacheable_request_uri ==
+
+Evaluates to the parsed form of the URI (usually led by <code>/</code>) of the current (sub-)request. Unlike the [[#$echo_request_uri|$echo_request_uri]] variable, it is cacheable.
+
+See [[#$echo_request_uri|$echo_request_uri]] for more details.
+
+This variable was first introduced in [[#v0.17|version 0.17]].
+
+== $echo_request_uri ==
+
+Evaluates to the parsed form of the URI (usually led by <code>/</code>) of the current (sub-)request. Unlike the [[#$echo_cacheable_request_uri|$echo_cacheable_request_uri]] variable, it is ''not'' cacheable.
+
+This is quite different from the [[NginxHttpCoreModule#$request_uri|$request_uri]] variable exported by the [[NginxHttpCoreModule]], because <code>$request_uri</code> is the ''unparsed'' form of the current request's URI.
+
+This variable was first introduced in [[#v0.17|version 0.17]].
+
+== $echo_incr ==
+
+It is a counter that always generate the current counting number, starting from 1. The counter is always associated with the main request even if it is accessed within a subrequest.
+
+Consider the following example
+
+<geshi lang="Nginx">
+    location /main {
+        echo "main pre: $echo_incr";
+        echo_location_async /sub;
+        echo_location_async /sub;
+        echo "main post: $echo_incr";
+    }
+    location /sub {
+        echo "sub: $echo_incr";
+    }
+</geshi>
+
+Accessing <code>/main</code> yields
+
+    main pre: 1
+    sub: 3
+    sub: 4
+    main post: 2
+
+This directive was first introduced in the [[#v0.18|v0.18 release]].
+
+== $echo_response_status ==
+
+Evaluates to the status code of the current (sub)request, null if not any.
+
+Behind the scene, it's just the textual representation of <code>r->headers_out->status</code>.
+
+This directive was first introduced in the [[#v0.23|v0.23 release]].
+
+= Installation =
+
+Grab the nginx source code from [http://nginx.net/ nginx.net], for example,
+the version 0.8.41 (see [[#Compatibility|nginx compatibility]]), and then build the source with this module:
+
+<geshi lang="bash">
+    $ wget 'http://sysoev.ru/nginx/nginx-0.8.41.tar.gz'
+    $ tar -xzvf nginx-0.8.41.tar.gz
+    $ cd nginx-0.8.41/
+
+    # Here we assume you would install you nginx under /opt/nginx/.
+    $ ./configure --prefix=/opt/nginx \
+        --add-module=/path/to/echo-nginx-module
+
+    $ make -j2
+    $ make install
+</geshi>
+
+Download the latest version of the release tarball of this module from [http://github.com/agentzh/echo-nginx-module/downloads echo-nginx-module file list].
+
+= Compatibility =
+
+The following versions of Nginx should work with this module:
+
+* '''0.8.x'''                       (last tested version is 0.8.40)
+* '''0.7.x >= 0.7.21'''             (last tested version is 0.7.66)
+
+In particular,
+
+* the directive [[#echo_location_async|echo_location_async]] and its brother [[#echo_subrequest_async|echo_subrequest_async]] do ''not'' work with '''0.7.x < 0.7.46'''.
+* the [[#echo_after_body|echo_after_body]] directive does ''not'' work at all with nginx '''< 0.8.7'''.
+* the [[#echo_sleep|echo_sleep]] directive cannot be used after [[#echo_location|echo_location]] or [[#echo_subrequest|echo_subrequest]] for nginx '''< 0.8.11'''.
+
+Earlier versions of Nginx like 0.6.x and 0.5.x will ''not'' work at all.
+
+If you find that any particular version of Nginx above 0.7.21 does not work with this module, please consider [[#Report Bugs|reporting a bug]].
+
+= Modules that use this module for testing =
+
+The following modules take advantage of this <code>echo</code> module in their test suite:
+
+* The [[NginxHttpMemcModule|memc]] module that supports almost the whole memcached TCP protocol.
+* The [[NginxHttpChunkinModule|chunkin]] module that adds HTTP 1.1 chunked input support to Nginx.
+* The [[NginxHttpHeadersMoreModule|headers_more]] module that allows you to add, set, and clear input and output headers under the conditions that you specify.
+* The <code>echo</code> module itself.
+
+Please mail me other modules that use <code>echo</code> in any form and I'll add them to the list above :)
+
+= Report Bugs =
+
+Although a lot of effort has been put into testing and code tuning, there must be some serious bugs lurking somewhere in this module. So whenever you are bitten by any quirks, please don't hesitate to
+
+# send a bug report or even patches to <agentzh@gmail.com>,
+# or create a ticket on the [http://github.com/agentzh/echo-nginx-module/issues issue tracking interface] provided by GitHub.
+
+= Source Repository =
+
+Available on github at [http://github.com/agentzh/echo-nginx-module agentzh/echo-nginx-module].
+
+= ChangeLog =
+
+== v0.34 ==
+* we no longer use the problematic <code>ngx_strXcmp</code> macros in our source because it may cause invalid reads and thus segmentation faults. thanks Piotr Sikora.
+
+== v0.33 ==
+* fixed compatibility with nginx 0.7.66+ because the ngx_time_update macro's parameter list has changed. Thanks Guang Feng (蔡镜明).
+
+== v0.32 ==
+* we should have used <code>ngx_calloc_buf</code> instead of <code>ngx_alloc_buf</code> for the last chunk generated for [[#echo_after_body|echo_after_body]]. thanks valgrind's memcheck tool.
+* we should initialize flags before feeding it into <code>ngx_http_parse_unsafe_uri</code>. thanks valgrind's memcheck tool.
+* fixed a minor issue in the [[#echo_location|echo_location]]/[[#echo_subrequest|echo_subrequest]] implementation, which used to have race conditions.
+
+== v0.31 ==
+
+* the echo wev handler should not proceed if it is still waiting for some sequential subrequest or has just processed one to avoid bouncing issues.
+* fixed a segfault for echo_exec for 0.7.x: we should check <code>r->done</code> before proceeding.
+* no longer explicitly set <code>r->write_event_handler</code> to <code>ngx_http_request_empty_handler</code> because it's totally wrong for the state machine.
+* fixed the sequential subrequest model bugs: we should ensure the <code>pr->write_event_handler</code> gets called immediately after the <code>post_subrequest</code> callback when the subrequest finalizes.
+
+== v0.30 ==
+
+* fixed the [[#echo_exec|echo_exec]] directive for nginx >= 0.8.11. we didn't get the <code>r->main->count</code> right in the previous version.
+
+== v0.29 ==
+
+* refactored the core of this module. now the implementation of [[#echo_location|echo_location]], [[#echo_subrequest|echo_subrequest]], [[#echo_sleep|echo_sleep]], and [[#echo_read_request_body|echo_read_request_body]] finally fit well with the nginx event model and Igor Sysoev's way of thinking.
+
+== v0.28 ==
+
+* added support for the <code>-n</code> and <code>--</code> options to the [[#echo|echo]], [[#echo_before_body|echo_before_body]], and [[#echo_after_body|echo_after_body]] directives.
+
+== v0.27 ==
+
+* applied the patch from Sergey A. Osokin to work with nginx 0.8.35.
+
+== v0.26 ==
+
+* bug fix: we should bypass upstream filters in our echo filters. an output filter should ever call <code>ngx_http_output_filter</code> nor <code>ngx_http_send_special</code>.
+
+== v0.25 ==
+
+* now we register a request cleanup handler to ensure our sleep event's timer will always get properly deleted even if the request is quit prematurely. this affects the echo_sleep directive.
+* use ngx_null_string whenever possible in the source.
+* sync'd the bundled test scaffold to Test::Nginx 0.07.
+
+== v0.24 ==
+
+* various source file name and coding style fixes. (the code now looks more like Igor Sysoev's.)
+
+== v0.23 ==
+
+* now the subrequest can read the client request body directly (for the main request) because we made subrequests inherit its parent's <code>r->header_in</code> as well. This affects the [[#echo_read_request_body|echo_read_request_body]] directive.
+* fixed [[#echo_after_body|echo_after_body]] in subrequests by using a hack (checking <code>cl->buf->sync</code> for the last buf) for nginx 0.8.7+ only.
+* added new varaible [[#$echo_response_status|$echo_response_status]] to help testing the status code of a subrequest. (The [[NginxHttpMemcModule|memc]] module makes use of it.)
+* use the <code>ngx_calloc_buf</code> macro to allocate new bufs in the code rather than explicit <code>ngx_pcalloc</code> calls for safety.
+
+== v0.22 ==
+
+* Now we allowed all the directives appear in the [[NginxHttpRewriteModule|rewrite module]]'s [[NginxHttpRewriteModule#if|if]] block. But so far I've only tested the [[#echo|echo]] directive.
+
+== v0.21 ==
+
+* Added a new directive named [[#echo_exec|echo_exec]] which does internal redirect to other (named) locations.
+
+== v0.20 ==
+
+* Fixed a bug in [[#echo_sleep|echo_sleep]]'s <code>r->main->count</code> handling for nginx 0.8.x. This bug will cause the server to hang when proxing a location with [[#echo_sleep|echo_sleep]].
+* Applied the <code>ngx_str3cmp</code>, <code>ngx_str4cmp</code>, and <code>ngx_str6cmp</code> optimizing macros to the <code>parse_method_name</code> function, as suggested by Marcus Clyne.
+* Added [[#TODO|TODO items]] regarding <code>$echo_random</code> and <code>echo_repeat</code> suggested by Marcus Clyne.
+
+== v0.19 ==
+* Fixed the CPS-style chained subrequest model for the [[#echo_location|echo_location]] and [[#echo_subrequest|echo_subrequest]] directives. they are now working perfectly and will not hang the server with the recent nginx 0.8.21 ~ 0.8.27 releases. To be specifically, the chained subrequest should call <code>ngx_http_finalize_request</code> on its parent request if the content handler of the parent request does not return <code>NGX_DONE</code>.
+* Undeprecated the [[#echo_location|echo_location]] and [[#echo_subrequest|echo_subrequest]] directives.
+
+== v0.18 ==
+* Fixed the "zero size buf in output" alerts in error.log.
+* Added the new directive [[#echo_request_body|echo_request_body]].
+* Now we use the <code>ngx_http_parse_unsafe_uri</code> function to check the locations to [[#echo_location_async|echo_location_async]] and its friends. Thanks Arvind Jayaprakash for suggesting this fix.
+* Deprecated the [[#echo_location|echo_location]] and [[#echo_subrequest|echo_subrequest]] directives.
+* For HTTP 1.0 clients, use the buf length of the first chain link as the output header Content-Length.
+* Implemented new variable [[#$echo_incr|$echo_incr]].
+
+== v0.17 ==
+* Added new directives [[#echo_foreach_split|echo_foreach_split]] and [[#echo_end|echo_end]]. Also introduced a "topic variable" named [[#$echo_it|$echo_it]].
+* Added new variables [[#$echo_request_uri|$echo_request_uri]] and [[#$echo_cacheable_request_uri|$echo_cacheable_request_uri]].
+
+== v0.16 ==
+* Now the subrequests issued by the [[#echo_location|echo_location_async]] and [[#echo_location|echo_location]] directives no longer inherit cached variable values from its parent request. (The underlying <code>ngx_http_subrequest</code> function, however, does automatic cachable variable value inheritance.)
+* Added an undocumented variable ''echo_cached_request_uri'' to help testing of this module.
+
+== v0.15 ==
+
+* Added new directives [[#echo_subrequest|echo_subrequest]] and [[#echo_subrequest_async|echo_subrequest_async]] for the full nginx subrequest API.
+* Removed the <code>echo_client_request_headers</code> directive, and provided the [[#$echo_client_request_headers|$echo_client_request_headers]] variable instead.
+* Added new variables [[#$echo_request_method|$echo_request_method]] and [[#$echo_client_request_method|$echo_client_request_method]].
+
+== v0.14 ==
+
+* Added new directive [[#echo_read_request_body|echo_read_request_body]] to explicitly read client request body so that the [[NginxHttpCoreModule#$request_body]] variable will always have non-empty values.
+* Now we shuffer test cases automatically in .t files and fixed bugs in the tests themselves which are hidden by config reload fallback in failure.
+
+== v0.13 ==
+
+* Fixed the special cases when the outputs of a [[#echo_duplicate|echo_duplicate]] directive is empty.
+* Now we explicitly clear content length and accept ranges headers in the content handler.
+
+== v0.12 ==
+
+* Implemented the [[#echo_location|echo_location]] directive, which can issue chained GET subrequests in the Continuation Passing Style (CPS), rather than the parallel subrequest issued by the [[#echo_location_async|echo_location_async]] directive.
+
+== v0.11 ==
+
+* Implemented the [[#echo_duplicate|echo_duplicate]] directive to help generating large chunk of data for testing.
+
+== v0.10 ==
+
+* Fixed compilation regression against Nginx 0.7.21. This bug appears in version 0.09.
+* Refactored the codebase by splitting source into various small files.
+
+== v0.09 ==
+
+* Reimplement the [[#echo_sleep|echo_sleep]] directive using per-request event and timer; the old implementation uses the global connection's read/write event to register timer, so it will break horribly when multiple subrequests "sleep" at the same time.
+* Added the [[#echo_location_async|echo_location_async]] directive which can issue a GET subrequest and insert its contents herein.
+
+== v0.08 ==
+
+* [[#echo_sleep|echo_sleep]]: now we delete our <code>write event timer</code> in the <code>post_sleep</code> handle.
+* Added <code>doc/manpage.wiki</code> which tracks changes in the [http://wiki.nginx.org/NginxHttpEchoModule wiki page].
+* Added the <code>util/wiki2pod.pl</code> script to convert <code>doc/manpage.wiki</code> to <code>README</code>.
+* Disabled the <code>DDEBUG</code> macro in the C source by default.
+
+= Test Suite =
+
+This module comes with a Perl-driven test suite. The [http://github.com/agentzh/echo-nginx-module/tree/master/test/t/ test cases] are
+[http://github.com/agentzh/echo-nginx-module/blob/master/test/t/echo.t declarative] too. Thanks to the [http://search.cpan.org/perldoc?Test::Base Test::Base] module in the Perl world.
+
+To run it on your side:
+
+<geshi lang="bash">
+    $ cd test
+    $ PATH=/path/to/your/nginx-with-echo-module:$PATH prove -r t
+</geshi>
+
+You need to terminate any Nginx processes before running the test suite if you have changed the Nginx server binary.
+
+At the moment, [http://search.cpan.org/perldoc?LWP::UserAgent LWP::UserAgent] is used by the [http://github.com/agentzh/echo-nginx-module/blob/master/test/lib/Test/Nginx/Echo.pm test scaffold] for simplicity and it's rather weak in testing ''streaming'' behavior of Nginx (I'm using "curl" to test these aspects manually for now). I'm considering coding up my own Perl HTTP client library based on [http://search.cpan.org/perldoc?IO::Select IO::Select] and [http://search.cpan.org/perldoc?IO::Socket IO::Socket] (there might be already one around?).
+
+Because a single nginx server (by default, <code>localhost:1984</code>) is used across all the test scripts (<code>.t</code> files), it's meaningless to run the test suite in parallel by specifying <code>-jN</code> when invoking the <code>prove</code> utility.
+
+Some parts of the test suite requires standard modules [[NginxHttpProxyModule|proxy]], [[NginxHttpRewriteModule|rewrite]] and [[NginxHttpSsiModule|SSI]] to be enabled as well when building Nginx.
+
+= TODO =
+
+* Fix the [[#echo_after_body|echo_after_body]] directive in subrequests.
+* Add directives ''echo_read_client_request_body'' and ''echo_request_headers''.
+* Add new directive ''echo_log'' to use Nginx's logging facility directly from the config file and specific loglevel can be specified, as in
+
+<geshi lang="nginx">
+  echo_log debug "I am being called.";
+</geshi>
+
+* Add support for options <code>-h</code> and <code>-t</code> to [[#echo_subrequest_async|echo_subrequest_async]] and [[#echo_subrequest|echo_subrequest]]. For example
+
+<geshi lang="nginx">
+  echo_subrequest POST /sub -q 'foo=Foo&bar=Bar' -b 'hello' -t 'text/plan' -h 'X-My-Header: blah blah'
+</geshi>
+
+* Add options to control whether a subrequest should inherit cached variables from its parent request (i.e. the current request that is calling the subrequest in question). Currently none of the subrequests issued by this module inherit the cached variables from the parent request.
+* Add new variable ''$echo_active_subrequests'' to show <code>r->main->count - 1</code>.
+* Add the ''echo_file'' and ''echo_cached_file'' directives.
+* Add new varaible ''$echo_request_headers'' to accompany the existing [[#$echo_client_request_headers|$echo_client_request_headers]] variable.
+* Add new directive ''echo_foreach'', as in
+
+<geshi lang="nginx">
+  echo_foreach 'cat' 'dog' 'mouse';
+    echo_location_async "/animals/$echo_it";
+  echo_end;
+</geshi>
+
+* Add new directive ''echo_foreach_range'', as in
+
+<geshi lang="nginx">
+  echo_foreach_range '[1..100]' '[a-zA-z0-9]';
+    echo_location_async "/item/$echo_it";
+  echo_end;
+</geshi>
+
+* Add new directive ''echo_repeat'', as in
+
+<geshi lang="nginx">
+  echo_repeat 10 $i {
+      echo "Page $i";
+      echo_location "/path/to/page/$i";
+  }
+</geshi>
+
+This is just another way of saying
+
+<geshi lang="nginx">
+  echo_foreach_range $i [1..10];
+      echo "Page $i";
+      echo_location "/path/to/page/$i";
+  echo_end;
+</geshi>
+
+Thanks Marcus Clyne for providing this idea.
+
+* Add new variable $echo_random which always returns a random non-negative integer with the lower/upper limit specified by the new directives <code>echo_random_min</code> and <code>echo_random_max</code>. For example,
+
+<geshi lang="nginx">
+  echo_random_min  10
+  echo_random_max  200
+  echo "random number: $echo_random";
+</geshi>
+
+Thanks Marcus Clyne for providing this idea.
+
+= Getting involved =
+
+You'll be very welcomed to submit patches to the [[#Author|author]] or just ask for a commit bit to the [[#Source Repository|source repository]] on GitHub.
+
+
+
+= Author =
+
+agentzh (章亦春) ''<agentzh@gmail.com>''
+
+This wiki page is also maintained by the author himself, and everybody is encouraged to improve this page as well.
+
+= Copyright & License =
+
+Copyright (c) 2009, Taobao Inc., Alibaba Group ( http://www.taobao.com ).
+
+Copyright (c) 2009, agentzh <agentzh@gmail.com>.
+
+This module is licensed under the terms of the BSD license.
+
+Redistribution and use in source and binary forms, with or without
+modification, are permitted provided that the following conditions
+are met:
+
+* Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+* Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+* Neither the name of the Taobao Inc. nor the names of its contributors may be used to endorse or promote products derived from this software without specific prior written permission.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+"AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
+TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
+PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
+LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
+NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
+SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+= See Also =
+
+* The original [http://agentzh.spaces.live.com/blog/cns!FF3A735632E41548!478.entry blog post] about this module's initial development.
+* The standard [[NginxHttpAdditionModule|addition filter module]].
+* The standard [[NginxHttpProxyModule|proxy module]].
+
Index: 0.8/modules/nginx-echo/src/ddebug.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ddebug.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,109 @@
+#ifndef DDEBUG_H
+#define DDEBUG_H
+
+#include <ngx_core.h>
+#include <ngx_http.h>
+
+#if defined(DDEBUG) && (DDEBUG)
+
+#   if (NGX_HAVE_VARIADIC_MACROS)
+
+#       define dd(...) fprintf(stderr, "echo *** %s: ", __func__); \
+            fprintf(stderr, __VA_ARGS__); \
+            fprintf(stderr, " at %s line %d.\n", __FILE__, __LINE__)
+
+#   else
+
+#include <stdarg.h>
+#include <stdio.h>
+
+#include <stdarg.h>
+
+static void dd(const char * fmt, ...) {
+}
+
+#    endif
+
+#   if DDEBUG > 1
+
+#       define dd_enter() dd_enter_helper(r, __func__)
+
+static void dd_enter_helper(ngx_http_request_t *r, const char *func) {
+    ngx_http_posted_request_t       *pr;
+
+    fprintf(stderr, ">enter %s %.*s %.*s?%.*s c:%d m:%p r:%p ar:%p pr:%p",
+            func,
+            (int) r->method_name.len, r->method_name.data,
+            (int) r->uri.len, r->uri.data,
+            (int) r->args.len, r->args.data,
+            0/*(int) r->main->count*/, r->main,
+            r, r->connection->data, r->parent);
+
+    if (r->posted_requests) {
+        fprintf(stderr, " posted:");
+
+        for (pr = r->posted_requests; pr; pr = pr->next) {
+            fprintf(stderr, "%p,", pr);
+        }
+    }
+
+    fprintf(stderr, "\n");
+}
+
+#   else
+
+#       define dd_enter()
+
+#   endif
+
+#else
+
+#   if (NGX_HAVE_VARIADIC_MACROS)
+
+#       define dd(...)
+
+#       define dd_enter()
+
+#   else
+
+#include <stdarg.h>
+
+static void dd(const char * fmt, ...) {
+}
+
+static void dd_enter() {
+}
+
+#   endif
+
+#endif
+
+#if defined(DDEBUG) && (DDEBUG)
+
+#define dd_check_read_event_handler(r)   \
+    dd("r->read_event_handler = %s", \
+        r->read_event_handler == ngx_http_block_reading ? \
+            "ngx_http_block_reading" : \
+        r->read_event_handler == ngx_http_test_reading ? \
+            "ngx_http_test_reading" : \
+        r->read_event_handler == ngx_http_request_empty_handler ? \
+            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+#define dd_check_write_event_handler(r)   \
+    dd("r->write_event_handler = %s", \
+        r->write_event_handler == ngx_http_handler ? \
+            "ngx_http_handler" : \
+        r->write_event_handler == ngx_http_core_run_phases ? \
+            "ngx_http_core_run_phases" : \
+        r->write_event_handler == ngx_http_request_empty_handler ? \
+            "ngx_http_request_empty_handler" : "UNKNOWN")
+
+#else
+
+#define dd_check_read_event_handler(r)
+#define dd_check_write_event_handler(r)
+
+#endif
+
+#endif /* DDEBUG_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_echo.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_echo.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,270 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_echo.h"
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_filter.h"
+
+#include <nginx.h>
+
+static ngx_buf_t ngx_http_echo_space_buf;
+
+static ngx_buf_t ngx_http_echo_newline_buf;
+
+ngx_int_t
+ngx_http_echo_echo_init(ngx_conf_t *cf)
+{
+    static u_char space_str[]   = " ";
+    static u_char newline_str[] = "\n";
+
+    dd("global init...");
+
+    ngx_memzero(&ngx_http_echo_space_buf, sizeof(ngx_buf_t));
+    ngx_http_echo_space_buf.memory = 1;
+    ngx_http_echo_space_buf.start =
+        ngx_http_echo_space_buf.pos =
+            space_str;
+    ngx_http_echo_space_buf.end =
+        ngx_http_echo_space_buf.last =
+            space_str + sizeof(space_str) - 1;
+
+    ngx_memzero(&ngx_http_echo_newline_buf, sizeof(ngx_buf_t));
+    ngx_http_echo_newline_buf.memory = 1;
+    ngx_http_echo_newline_buf.start =
+        ngx_http_echo_newline_buf.pos =
+            newline_str;
+    ngx_http_echo_newline_buf.end =
+        ngx_http_echo_newline_buf.last =
+            newline_str + sizeof(newline_str) - 1;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args,
+        ngx_flag_t in_filter, ngx_array_t *opts)
+{
+    ngx_uint_t                  i;
+
+    ngx_buf_t                   *space_buf;
+    ngx_buf_t                   *newline_buf;
+    ngx_buf_t                   *buf;
+
+    ngx_str_t                   *computed_arg;
+    ngx_str_t                   *computed_arg_elts;
+    ngx_str_t                   *opt;
+
+    ngx_chain_t *cl  = NULL; /* the head of the chain link */
+    ngx_chain_t **ll = &cl;  /* always point to the address of the last link */
+
+
+    dd_enter();
+
+    if (computed_args == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    computed_arg_elts = computed_args->elts;
+    for (i = 0; i < computed_args->nelts; i++) {
+        computed_arg = &computed_arg_elts[i];
+
+        if (computed_arg->len == 0) {
+            buf = NULL;
+
+        } else {
+            buf = ngx_calloc_buf(r->pool);
+            if (buf == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            buf->start = buf->pos = computed_arg->data;
+            buf->last = buf->end = computed_arg->data +
+                computed_arg->len;
+
+            buf->memory = 1;
+        }
+
+        if (cl == NULL) {
+            cl = ngx_alloc_chain_link(r->pool);
+            if (cl == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+            cl->buf  = buf;
+            cl->next = NULL;
+            ll = &cl->next;
+        } else {
+            /* append a space first */
+            *ll = ngx_alloc_chain_link(r->pool);
+
+            if (*ll == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            space_buf = ngx_calloc_buf(r->pool);
+
+            if (space_buf == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            /* nginx clears buf flags at the end of each request handling,
+             * so we have to make a clone here. */
+            *space_buf = ngx_http_echo_space_buf;
+
+            (*ll)->buf = space_buf;
+            (*ll)->next = NULL;
+
+            ll = &(*ll)->next;
+
+            /* then append the buf only if it's non-empty */
+            if (buf) {
+                *ll = ngx_alloc_chain_link(r->pool);
+                if (*ll == NULL) {
+                    return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                }
+                (*ll)->buf  = buf;
+                (*ll)->next = NULL;
+
+                ll = &(*ll)->next;
+            }
+        }
+    } /* end for */
+
+    if (opts && opts->nelts > 0) {
+        opt = opts->elts;
+        if (opt[0].len == 1 && opt[0].data[0] == 'n') {
+            goto done;
+        }
+    }
+
+    /* append the newline character */
+
+    if (cl && cl->buf == NULL) {
+        cl = cl->next;
+    }
+
+    newline_buf = ngx_calloc_buf(r->pool);
+
+    if (newline_buf == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    *newline_buf = ngx_http_echo_newline_buf;
+
+    if (cl == NULL) {
+        cl = ngx_alloc_chain_link(r->pool);
+
+        if (cl == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        cl->buf = newline_buf;
+        cl->next = NULL;
+        /* ll = &cl->next; */
+
+    } else {
+        *ll = ngx_alloc_chain_link(r->pool);
+
+        if (*ll == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        (*ll)->buf  = newline_buf;
+        (*ll)->next = NULL;
+        /* ll = &(*ll)->next; */
+    }
+
+done:
+
+    if (cl == NULL || cl->buf == NULL) {
+        return NGX_OK;
+    }
+
+    if (in_filter) {
+        return ngx_http_echo_next_body_filter(r, cl);
+    }
+
+    return ngx_http_echo_send_chain_link(r, ctx, cl);
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_flush(ngx_http_request_t *r, ngx_http_echo_ctx_t *ctx)
+{
+    return ngx_http_send_special(r, NGX_HTTP_FLUSH);
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_request_body(ngx_http_request_t *r, ngx_http_echo_ctx_t *ctx)
+{
+    if (r->request_body && r->request_body->bufs) {
+        return ngx_http_echo_send_chain_link(r, ctx, r->request_body->bufs);
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_duplicate(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_str_t                   *computed_arg;
+    ngx_str_t                   *computed_arg_elts;
+    ssize_t                     i, count;
+    ngx_str_t                   *str;
+    u_char                      *p;
+    ngx_int_t                   rc;
+
+    ngx_buf_t                   *buf;
+    ngx_chain_t                 *cl;
+
+
+    dd_enter();
+
+    computed_arg_elts = computed_args->elts;
+
+    computed_arg = &computed_arg_elts[0];
+
+    count = ngx_http_echo_atosz(computed_arg->data, computed_arg->len);
+
+    if (count == NGX_ERROR) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                   "invalid size specified: \"%V\"", computed_arg);
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    str = &computed_arg_elts[1];
+
+    if (count == 0 || str->len == 0) {
+        rc = ngx_http_echo_send_header_if_needed(r, ctx);
+        if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+        return NGX_OK;
+    }
+
+    buf = ngx_create_temp_buf(r->pool, count * str->len);
+    if (buf == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    p = buf->pos;
+    for (i = 0; i < count; i++) {
+        p = ngx_copy(p, str->data, str->len);
+    }
+    buf->last = p;
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+    cl->next = NULL;
+    cl->buf = buf;
+
+    return ngx_http_echo_send_chain_link(r, ctx, cl);
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_echo.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_echo.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,22 @@
+#ifndef ECHO_ECHO_H
+#define ECHO_ECHO_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_echo_init(ngx_conf_t *cf);
+
+ngx_int_t ngx_http_echo_exec_echo(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args,
+        ngx_flag_t in_filter, ngx_array_t *opts);
+
+ngx_int_t ngx_http_echo_exec_echo_request_body(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_exec_echo_flush(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_exec_echo_duplicate(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+#endif /* ECHO_ECHO_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_filter.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_filter.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,240 @@
+#define DDEBUG 0
+
+#include "ddebug.h"
+#include "ngx_http_echo_filter.h"
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_echo.h"
+
+#include <ngx_log.h>
+
+ngx_flag_t ngx_http_echo_filter_used = 0;
+
+ngx_http_output_header_filter_pt ngx_http_echo_next_header_filter;
+
+ngx_http_output_body_filter_pt ngx_http_echo_next_body_filter;
+
+static ngx_int_t ngx_http_echo_header_filter(ngx_http_request_t *r);
+
+static ngx_int_t ngx_http_echo_body_filter(ngx_http_request_t *r, ngx_chain_t *in);
+
+/* filter handlers */
+static ngx_int_t ngx_http_echo_exec_filter_cmds(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *cmds, ngx_uint_t *iterator);
+
+
+ngx_int_t
+ngx_http_echo_filter_init (ngx_conf_t *cf)
+{
+    if (ngx_http_echo_filter_used) {
+        dd("top header filter: %ld", (unsigned long) ngx_http_top_header_filter);
+        ngx_http_echo_next_header_filter = ngx_http_top_header_filter;
+        ngx_http_top_header_filter  = ngx_http_echo_header_filter;
+
+        dd("top body filter: %ld", (unsigned long) ngx_http_top_body_filter);
+        ngx_http_echo_next_body_filter = ngx_http_top_body_filter;
+        ngx_http_top_body_filter  = ngx_http_echo_body_filter;
+    }
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_echo_header_filter(ngx_http_request_t *r)
+{
+    ngx_http_echo_loc_conf_t    *conf;
+    ngx_http_echo_ctx_t         *ctx;
+    ngx_int_t                   rc;
+
+    dd("We're in the header filter...");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    /* XXX we should add option to insert contents for responses
+     * of non-200 status code here... */
+    /*
+    if (r->headers_out.status != NGX_HTTP_OK) {
+        if (ctx != NULL) {
+            ctx->skip_filter = 1;
+        }
+        return ngx_http_echo_next_header_filter(r);
+    }
+    */
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
+    if (conf->before_body_cmds == NULL && conf->after_body_cmds == NULL) {
+        if (ctx != NULL) {
+            ctx->skip_filter = 1;
+        }
+        return ngx_http_echo_next_header_filter(r);
+    }
+
+    if (ctx == NULL) {
+        rc = ngx_http_echo_init_ctx(r, &ctx);
+        if (rc != NGX_OK) {
+            return NGX_ERROR;
+        }
+        ctx->headers_sent = 1;
+        ngx_http_set_ctx(r, ctx, ngx_http_echo_module);
+    }
+
+    /* enable streaming here (use chunked encoding) */
+    ngx_http_clear_content_length(r);
+    ngx_http_clear_accept_ranges(r);
+
+    return ngx_http_echo_next_header_filter(r);
+}
+
+
+static ngx_int_t
+ngx_http_echo_body_filter(ngx_http_request_t *r, ngx_chain_t *in)
+{
+    ngx_http_echo_ctx_t         *ctx;
+    ngx_int_t                    rc;
+    ngx_http_echo_loc_conf_t    *conf;
+    ngx_flag_t                   last;
+    ngx_chain_t                 *cl;
+    ngx_buf_t                   *buf;
+
+    if (in == NULL || r->header_only) {
+        return ngx_http_echo_next_body_filter(r, in);
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    if (ctx == NULL || ctx->skip_filter) {
+        return ngx_http_echo_next_body_filter(r, in);
+    }
+
+    conf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
+
+    if (!ctx->before_body_sent) {
+        ctx->before_body_sent = 1;
+
+        if (conf->before_body_cmds != NULL) {
+            rc = ngx_http_echo_exec_filter_cmds(r, ctx, conf->before_body_cmds,
+                    &ctx->next_before_body_cmd);
+            if (rc != NGX_OK) {
+                return NGX_ERROR;
+            }
+        }
+    }
+
+    if (conf->after_body_cmds == NULL) {
+        ctx->skip_filter = 1;
+        return ngx_http_echo_next_body_filter(r, in);
+    }
+
+    last = 0;
+
+    for (cl = in; cl; cl = cl->next) {
+        if (cl->buf->last_buf) {
+            cl->buf->last_buf = 0;
+            cl->buf->sync = 1;
+            last = 1;
+        } else if (r != r->main && cl->buf->sync) {
+            dd("Found sync buf");
+            last = 1;
+        }
+    }
+
+    rc = ngx_http_echo_next_body_filter(r, in);
+
+    if (rc == NGX_ERROR || !last) {
+        return rc;
+    }
+
+    dd("exec filter cmds for after body cmds");
+    rc = ngx_http_echo_exec_filter_cmds(r, ctx, conf->after_body_cmds, &ctx->next_after_body_cmd);
+    if (rc != NGX_OK) {
+        dd("FAILED: exec filter cmds for after body cmds");
+        return NGX_ERROR;
+    }
+
+    ctx->skip_filter = 1;
+
+    dd("after body cmds executed...terminating...");
+
+    /* XXX we can NOT use
+     * ngx_http_send_special(r, NGX_HTTP_LAST) here
+     * because we should bypass the upstream filters. */
+    if (r != r->main) {
+        return NGX_OK;
+    }
+
+    buf = ngx_calloc_buf(r->pool);
+    buf->last_buf = 1;
+
+    cl = ngx_alloc_chain_link(r->pool);
+    if (cl == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    cl->next = NULL;
+    cl->buf = buf;
+
+    return ngx_http_echo_next_body_filter(r, cl);
+}
+
+
+static ngx_int_t
+ngx_http_echo_exec_filter_cmds(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *cmds,
+        ngx_uint_t *iterator)
+{
+    ngx_int_t                    rc;
+    ngx_array_t                 *computed_args = NULL;
+    ngx_http_echo_cmd_t         *cmd;
+    ngx_http_echo_cmd_t         *cmd_elts;
+    ngx_array_t                 *opts = NULL;
+
+    for (cmd_elts = cmds->elts; *iterator < cmds->nelts; (*iterator)++) {
+        cmd = &cmd_elts[*iterator];
+
+        /* evaluate arguments for the current cmd (if any) */
+        if (cmd->args) {
+            computed_args = ngx_array_create(r->pool, cmd->args->nelts,
+                    sizeof(ngx_str_t));
+
+            if (computed_args == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            opts = ngx_array_create(r->pool, 1, sizeof(ngx_str_t));
+
+            if (opts == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            rc = ngx_http_echo_eval_cmd_args(r, cmd, computed_args, opts);
+
+            if (rc != NGX_OK) {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                        "Failed to evaluate arguments for "
+                        "the directive.");
+                return rc;
+            }
+        }
+
+        /* do command dispatch based on the opcode */
+        switch (cmd->opcode) {
+        case echo_opcode_echo_before_body:
+        case echo_opcode_echo_after_body:
+            dd("exec echo_before_body or echo_after_body...");
+
+            rc = ngx_http_echo_exec_echo(r, ctx, computed_args,
+                    1 /* in filter */, opts);
+
+            if (rc != NGX_OK) {
+                return rc;
+            }
+
+            break;
+        default:
+            break;
+        }
+    }
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_filter.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_filter.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,16 @@
+#ifndef ECHO_FILTER_H
+#define ECHO_FILTER_H
+
+#include "ngx_http_echo_module.h"
+
+extern ngx_flag_t ngx_http_echo_filter_used;
+
+extern ngx_http_output_header_filter_pt ngx_http_echo_next_header_filter;
+
+extern ngx_http_output_body_filter_pt ngx_http_echo_next_body_filter;
+
+
+ngx_int_t ngx_http_echo_filter_init (ngx_conf_t *cf);
+
+#endif /* ECHO_FILTER_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_foreach.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_foreach.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,174 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_foreach.h"
+#include "ngx_http_echo_util.h"
+
+#include <nginx.h>
+
+ngx_int_t
+ngx_http_echo_it_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_http_echo_ctx_t         *ctx;
+    ngx_uint_t                  i;
+    ngx_array_t                 *choices;
+    ngx_str_t                   *choice_elts, *choice;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    if (ctx->foreach != NULL) {
+        choices = ctx->foreach->choices;
+        i = ctx->foreach->next_choice;
+        if (i < choices->nelts) {
+            choice_elts = choices->elts;
+            choice = &choice_elts[i];
+
+            v->len = choice->len;
+            v->data = choice->data;
+            v->valid = 1;
+            v->no_cacheable = 1;
+            v->not_found = 0;
+        }
+
+        return NGX_OK;
+    }
+
+    v->not_found = 1;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_foreach_split(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_http_echo_loc_conf_t    *elcf;
+    ngx_str_t                   *delimiter, *compound;
+    u_char                      *pos, *last, *end;
+    ngx_str_t                   *choice;
+    ngx_str_t                   *computed_arg_elts;
+    ngx_array_t                 *cmds;
+    ngx_http_echo_cmd_t         *cmd;
+    ngx_http_echo_cmd_t         *cmd_elts;
+
+    if (ctx->foreach != NULL) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                "Nested echo_foreach not supported yet.");
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (computed_args->nelts < 2) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                "echo_foreach should take at least two arguments. "
+                "(if your delimiter starts with \"-\", preceding it with a "
+                "\"--\".)");
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    computed_arg_elts = computed_args->elts;
+
+    compound  = &computed_arg_elts[1];
+
+    dd("HEY coumpound len: %u", compound->len);
+
+    ctx->foreach = ngx_palloc(r->pool, sizeof(ngx_http_echo_foreach_ctx_t));
+
+    if (ctx->foreach == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->foreach->cmd_index = ctx->next_handler_cmd;
+
+    ctx->foreach->next_choice = 0;
+
+    ctx->foreach->choices = ngx_array_create(r->pool, 10, sizeof(ngx_str_t));
+    if (ctx->foreach->choices == NULL) {
+        return NGX_ERROR;
+    }
+
+    delimiter = &computed_arg_elts[0];
+
+    pos = compound->data;
+    end = compound->data + compound->len;
+    while ((last = ngx_http_echo_strlstrn(pos, end, delimiter->data, delimiter->len - 1))
+                != NULL) {
+        dd("entered the loop");
+
+        if (last == pos) {
+            dd("!!! len == 0");
+            pos = last + delimiter->len;
+            continue;
+        }
+
+        choice = ngx_array_push(ctx->foreach->choices);
+        if (choice == NULL) {
+            return NGX_ERROR;
+        }
+
+        choice->data = pos;
+        choice->len  = last - pos;
+        pos = last + delimiter->len;
+    }
+
+    if (pos < end) {
+        choice = ngx_array_push(ctx->foreach->choices);
+        if (choice == NULL) {
+            return NGX_ERROR;
+        }
+
+        choice->data = pos;
+        choice->len  = end - pos;
+    }
+
+    if (ctx->foreach->choices->nelts == 0) {
+        /* skip the foreach body entirely */
+        elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
+        cmds = elcf->handler_cmds;
+        cmd_elts = cmds->elts;
+        for (; ctx->next_handler_cmd < cmds->nelts;
+                ctx->next_handler_cmd++) {
+            cmd = &cmd_elts[ctx->next_handler_cmd + 1];
+            if (cmd->opcode == echo_opcode_echo_end) {
+                return NGX_OK;
+            }
+        }
+
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_end(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx)
+{
+    if (ctx->foreach == NULL) {
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                "Found a echo_end that has no corresponding echo_foreach "
+                "before it.");
+        return NGX_ERROR;
+    }
+
+    ctx->foreach->next_choice++;
+
+    if (ctx->foreach->next_choice >= ctx->foreach->choices->nelts) {
+        /* TODO We need to explicitly free the foreach ctx from
+         * the pool */
+        ctx->foreach = NULL;
+
+        return NGX_OK;
+    }
+
+    dd("echo_end: ++ next_choice (total: %u): %u", ctx->foreach->choices->nelts, ctx->foreach->next_choice);
+
+    /* the main handler dispatcher loop will increment
+     *   ctx->next_handler_cmd for us anyway. */
+    ctx->next_handler_cmd = ctx->foreach->cmd_index;
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_foreach.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_foreach.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,16 @@
+#ifndef ECHO_FOREACH_H
+#define ECHO_FOREACH_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_exec_echo_foreach_split(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+ngx_int_t ngx_http_echo_exec_echo_end(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_it_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+#endif /* ECHO_FOREACH_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_handler.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_handler.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,351 @@
+#define DDEBUG 0
+
+#include "ddebug.h"
+
+#include "ngx_http_echo_handler.h"
+#include "ngx_http_echo_echo.h"
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_sleep.h"
+#include "ngx_http_echo_var.h"
+#include "ngx_http_echo_timer.h"
+#include "ngx_http_echo_location.h"
+#include "ngx_http_echo_subrequest.h"
+#include "ngx_http_echo_request_info.h"
+#include "ngx_http_echo_foreach.h"
+
+#include <nginx.h>
+#include <ngx_log.h>
+
+ngx_int_t
+ngx_http_echo_handler_init(ngx_conf_t *cf)
+{
+    ngx_int_t         rc;
+
+    rc = ngx_http_echo_echo_init(cf);
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    return ngx_http_echo_add_variables(cf);
+}
+
+
+void
+ngx_http_echo_wev_handler(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_http_echo_ctx_t         *ctx;
+
+    dd_enter();
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    if (ctx == NULL) {
+        ngx_http_finalize_request(r, NGX_ERROR);
+        return;
+    }
+
+    if (ctx->waiting && ! ctx->done) {
+        if (r->main->posted_requests
+                && r->main->posted_requests->request != r)
+        {
+            dd("HOT SPIN");
+
+#if defined(nginx_version) && nginx_version >= 8012
+            ngx_http_post_request(r, NULL);
+#else
+            ngx_http_post_request(r);
+#endif
+
+            return;
+        }
+    }
+
+    ctx->done = 0;
+
+    ctx->next_handler_cmd++;
+
+    rc = ngx_http_echo_run_cmds(r);
+
+    dd("rc: %d", (int) rc);
+
+    if (rc == NGX_DONE) {
+        return;
+    }
+
+    if (rc == NGX_AGAIN) {
+        dd("mark busy %d", (int) ctx->next_handler_cmd);
+        ctx->waiting = 1;
+        ctx->done = 0;
+
+    } else {
+        dd("mark ready %d", (int) ctx->next_handler_cmd);
+        ctx->waiting = 0;
+        ctx->done = 1;
+
+        dd("finalizing with rc %d", (int) rc);
+
+        dd("finalize request %.*s with %d", (int) r->uri.len, r->uri.data, (int) rc);
+
+        ngx_http_finalize_request(r, rc);
+    }
+}
+
+
+ngx_int_t
+ngx_http_echo_handler(ngx_http_request_t *r)
+{
+    ngx_int_t                    rc;
+    ngx_http_echo_ctx_t         *ctx;
+
+    rc = ngx_http_echo_run_cmds(r);
+
+    if (rc == NGX_ERROR) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    if (rc == NGX_DONE) {
+        return NGX_DONE;
+    }
+
+    if (rc == NGX_AGAIN) {
+#if defined(nginx_version) && nginx_version >= 8011
+        r->main->count++;
+#endif
+
+        /* XXX we need this for 0.7.x and 0.8.x < 0.8.11 */
+        dd("%d", r->connection->destroyed);
+        dd("%d", r->done);
+
+        ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+        if (ctx) {
+            dd("mark busy %d", (int) ctx->next_handler_cmd);
+            ctx->waiting = 1;
+            ctx->done = 0;
+        }
+
+        return NGX_DONE;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_run_cmds(ngx_http_request_t *r)
+{
+    ngx_http_echo_loc_conf_t    *elcf;
+    ngx_http_echo_ctx_t         *ctx;
+    ngx_int_t                    rc;
+    ngx_array_t                 *cmds;
+    ngx_array_t                 *computed_args = NULL;
+    ngx_http_echo_cmd_t         *cmd;
+    ngx_http_echo_cmd_t         *cmd_elts;
+    ngx_array_t                 *opts = NULL;
+
+
+    elcf = ngx_http_get_module_loc_conf(r, ngx_http_echo_module);
+    cmds = elcf->handler_cmds;
+    if (cmds == NULL) {
+        return NGX_DECLINED;
+    }
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+    if (ctx == NULL) {
+        rc = ngx_http_echo_init_ctx(r, &ctx);
+        if (rc != NGX_OK) {
+            return rc;
+        }
+
+        ngx_http_set_ctx(r, ctx, ngx_http_echo_module);
+    }
+
+    dd("exec handler: %.*s: %i", (int) r->uri.len, r->uri.data,
+            (int) ctx->next_handler_cmd);
+
+    cmd_elts = cmds->elts;
+
+    for (; ctx->next_handler_cmd < cmds->nelts; ctx->next_handler_cmd++) {
+
+        cmd = &cmd_elts[ctx->next_handler_cmd];
+
+        /* evaluate arguments for the current cmd (if any) */
+        if (cmd->args) {
+            computed_args = ngx_array_create(r->pool, cmd->args->nelts,
+                    sizeof(ngx_str_t));
+
+            if (computed_args == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            opts = ngx_array_create(r->pool, 1, sizeof(ngx_str_t));
+
+            if (opts == NULL) {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            rc = ngx_http_echo_eval_cmd_args(r, cmd, computed_args, opts);
+            if (rc != NGX_OK) {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                        "Failed to evaluate arguments for "
+                        "the directive.");
+                return rc;
+            }
+        }
+
+        /* do command dispatch based on the opcode */
+        switch (cmd->opcode) {
+        case echo_opcode_echo:
+            /* XXX moved the following code to a separate
+             * function */
+            dd("found echo opcode");
+            rc = ngx_http_echo_exec_echo(r, ctx, computed_args,
+                    0 /* in filter */, opts);
+            break;
+
+        case echo_opcode_echo_request_body:
+            rc = ngx_http_echo_exec_echo_request_body(r, ctx);
+            break;
+
+        case echo_opcode_echo_location_async:
+            dd("found opcode echo location async...");
+            rc = ngx_http_echo_exec_echo_location_async(r, ctx,
+                    computed_args);
+            break;
+
+        case echo_opcode_echo_location:
+            return ngx_http_echo_exec_echo_location(r, ctx, computed_args);
+            break;
+
+        case echo_opcode_echo_subrequest_async:
+            dd("found opcode echo subrequest async...");
+            rc = ngx_http_echo_exec_echo_subrequest_async(r, ctx,
+                    computed_args);
+            break;
+
+        case echo_opcode_echo_subrequest:
+            return ngx_http_echo_exec_echo_subrequest(r, ctx, computed_args);
+            break;
+
+        case echo_opcode_echo_sleep:
+            return ngx_http_echo_exec_echo_sleep(r, ctx, computed_args);
+            break;
+
+        case echo_opcode_echo_flush:
+            rc = ngx_http_echo_exec_echo_flush(r, ctx);
+            break;
+
+        case echo_opcode_echo_blocking_sleep:
+            rc = ngx_http_echo_exec_echo_blocking_sleep(r, ctx,
+                    computed_args);
+            break;
+
+        case echo_opcode_echo_reset_timer:
+            rc = ngx_http_echo_exec_echo_reset_timer(r, ctx);
+            break;
+
+        case echo_opcode_echo_duplicate:
+            rc = ngx_http_echo_exec_echo_duplicate(r, ctx, computed_args);
+            break;
+
+        case echo_opcode_echo_read_request_body:
+            ctx->wait_read_request_body = 0;
+
+            rc = ngx_http_echo_exec_echo_read_request_body(r, ctx);
+
+#if defined(nginx_version) && nginx_version >= 8011
+            /* XXX read_client_request_body always increments the counter */
+            r->main->count--;
+#endif
+
+            dd("read request body: %d", (int) rc);
+
+            if (rc == NGX_OK) {
+                continue;
+            }
+
+            ctx->wait_read_request_body = 1;
+
+            /* r->write_event_handler = ngx_http_request_empty_handler; */
+
+            return rc;
+            break;
+
+        case echo_opcode_echo_foreach_split:
+            rc = ngx_http_echo_exec_echo_foreach_split(r, ctx, computed_args);
+            break;
+
+        case echo_opcode_echo_end:
+            rc = ngx_http_echo_exec_echo_end(r, ctx);
+            break;
+
+        case echo_opcode_echo_exec:
+            dd("echo_exec");
+            return ngx_http_echo_exec_exec(r, ctx, computed_args);
+            break;
+
+        default:
+            ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                    "Unknown opcode: %d", cmd->opcode);
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            break;
+        }
+
+        if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+    }
+
+    rc = ngx_http_echo_send_chain_link(r, ctx, NULL /* indicate LAST */);
+
+    if (rc == NGX_ERROR || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_post_subrequest(ngx_http_request_t *r,
+        void *data, ngx_int_t rc)
+{
+    ngx_http_request_t          *pr;
+    ngx_http_echo_ctx_t         *pr_ctx;
+
+
+    dd_enter();
+
+    pr = r->parent;
+
+    pr_ctx = ngx_http_get_module_ctx(pr, ngx_http_echo_module);
+    if (pr_ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    dd("mark ready %d", (int) pr_ctx->next_handler_cmd);
+
+    pr_ctx->waiting = 0;
+    pr_ctx->done = 1;
+
+    pr->write_event_handler = ngx_http_echo_wev_handler;
+
+    /* ensure that the parent request is (or will be)
+     *  posted out the head of the r->posted_requests chain */
+
+    if (r->main->posted_requests
+            && r->main->posted_requests->request != pr)
+    {
+        rc = ngx_http_echo_post_request_at_head(pr, NULL);
+        if (rc != NGX_OK) {
+            return NGX_ERROR;
+        }
+    }
+
+    return rc;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_handler.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_handler.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,20 @@
+#ifndef ECHO_HANDLER_H
+#define ECHO_HANDLER_H
+
+#include "ngx_http_echo_module.h"
+
+
+void ngx_http_echo_wev_handler(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_echo_handler_init(ngx_conf_t *cf);
+
+ngx_int_t ngx_http_echo_handler(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_echo_run_cmds(ngx_http_request_t *r);
+
+ngx_int_t ngx_http_echo_post_subrequest(ngx_http_request_t *r,
+        void *data, ngx_int_t rc);
+
+
+#endif /* ECHO_HANDLER_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_location.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_location.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,183 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_location.h"
+#include "ngx_http_echo_handler.h"
+
+#include <nginx.h>
+
+
+static ngx_int_t ngx_http_echo_adjust_subrequest(ngx_http_request_t *sr);
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_location_async(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_int_t                    rc;
+    ngx_http_request_t          *sr; /* subrequest object */
+    ngx_str_t                   *computed_arg_elts;
+    ngx_str_t                    location;
+    ngx_str_t                   *url_args;
+    ngx_str_t                    args;
+    ngx_uint_t                   flags = 0;
+
+
+    dd_enter();
+
+    computed_arg_elts = computed_args->elts;
+
+    location = computed_arg_elts[0];
+
+    if (location.len == 0) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (computed_args->nelts > 1) {
+        url_args = &computed_arg_elts[1];
+    } else {
+        url_args = NULL;
+    }
+
+    dd("location: %s", location.data);
+    dd("location args: %s", (char*) (url_args ? url_args->data : (u_char*)"NULL"));
+
+    args.data = NULL;
+    args.len = 0;
+
+    if (ngx_http_parse_unsafe_uri(r, &location, &args, &flags) != NGX_OK) {
+        ctx->headers_sent = 1;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (args.len > 0 && url_args == NULL) {
+        url_args = &args;
+    }
+
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+    if (r->header_only) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    rc = ngx_http_subrequest(r, &location, url_args, &sr, NULL, 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_echo_adjust_subrequest(sr);
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_location(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_int_t                            rc;
+    ngx_http_request_t                  *sr; /* subrequest object */
+    ngx_str_t                           *computed_arg_elts;
+    ngx_str_t                            location;
+    ngx_str_t                           *url_args;
+    ngx_http_post_subrequest_t          *psr;
+    ngx_str_t                            args;
+    ngx_uint_t                           flags = 0;
+
+
+    dd_enter();
+
+    computed_arg_elts = computed_args->elts;
+
+    location = computed_arg_elts[0];
+
+    if (location.len == 0) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (computed_args->nelts > 1) {
+        url_args = &computed_arg_elts[1];
+    } else {
+        url_args = NULL;
+    }
+
+    args.data = NULL;
+    args.len = 0;
+
+    if (ngx_http_parse_unsafe_uri(r, &location, &args, &flags) != NGX_OK) {
+        ctx->headers_sent = 1;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (args.len > 0 && url_args == NULL) {
+        url_args = &args;
+    }
+
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+
+    if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    psr = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t));
+
+    if (psr == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    psr->handler = ngx_http_echo_post_subrequest;
+    psr->data = ctx;
+
+    rc = ngx_http_subrequest(r, &location, url_args, &sr, psr, 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_echo_adjust_subrequest(sr);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_echo_adjust_subrequest(ngx_http_request_t *sr)
+{
+    ngx_http_core_main_conf_t   *cmcf;
+    ngx_http_request_t          *r;
+
+
+    /* we do not inherit the parent request's variables */
+    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);
+
+    r = sr->parent;
+
+    sr->header_in = r->header_in;
+
+    /* XXX work-around a bug in ngx_http_subrequest */
+    if (r->headers_in.headers.last == &r->headers_in.headers.part) {
+        sr->headers_in.headers.last = &sr->headers_in.headers.part;
+    }
+
+    sr->variables = ngx_pcalloc(sr->pool, cmcf->variables.nelts
+                                        * sizeof(ngx_http_variable_value_t));
+
+    if (sr->variables == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_location.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_location.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,13 @@
+#ifndef ECHO_LOCATION_H
+#define ECHO_LOCATION_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_exec_echo_location_async(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+ngx_int_t ngx_http_echo_exec_echo_location(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+#endif /* ECHO_LOCATION_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_module.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_module.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,587 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_handler.h"
+#include "ngx_http_echo_filter.h"
+#include "ngx_http_echo_request_info.h"
+
+#include <nginx.h>
+#include <ngx_config.h>
+#include <ngx_log.h>
+
+/* config init handler */
+static void * ngx_http_echo_create_conf(ngx_conf_t *cf);
+
+/* config directive handlers */
+static char * ngx_http_echo_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_request_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_sleep(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+
+static char * ngx_http_echo_echo_flush(ngx_conf_t *cf, ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_blocking_sleep(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_reset_timer(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_before_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_after_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_location_async(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_location(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_subrequest_async(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_subrequest(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_duplicate(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_read_request_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_foreach_split(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_end(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_echo_abort_parent(ngx_conf_t *cf, ngx_command_t *cmd,
+        void *conf);
+
+static char * ngx_http_echo_echo_exec(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf);
+
+static char * ngx_http_echo_helper(ngx_http_echo_opcode_t opcode,
+        ngx_http_echo_cmd_category_t cat,
+        ngx_conf_t *cf, ngx_command_t *cmd, void* conf);
+
+
+static ngx_http_module_t ngx_http_echo_module_ctx = {
+    /* TODO we could add our own variables here... */
+    ngx_http_echo_handler_init,                 /* preconfiguration */
+    ngx_http_echo_filter_init,                  /* postconfiguration */
+
+    NULL,                          /* create main configuration */
+    NULL,                          /* init main configuration */
+
+    NULL,                          /* create server configuration */
+    NULL,                          /* merge server configuration */
+
+    ngx_http_echo_create_conf, /* create location configuration */
+    NULL                           /* merge location configuration */
+};
+
+
+static ngx_command_t  ngx_http_echo_commands[] = {
+
+    { ngx_string("echo"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_ANY,
+      ngx_http_echo_echo,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_request_body"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_request_body,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_sleep"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_http_echo_echo_sleep,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_flush"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_flush,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_blocking_sleep"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE1,
+      ngx_http_echo_echo_blocking_sleep,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_reset_timer"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_reset_timer,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_before_body"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_ANY,
+      ngx_http_echo_echo_before_body,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, before_body_cmds),
+      NULL },
+
+    { ngx_string("echo_after_body"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_ANY,
+      ngx_http_echo_echo_after_body,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, after_body_cmds),
+      NULL },
+
+    { ngx_string("echo_location_async"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE12,
+      ngx_http_echo_echo_location_async,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("echo_location"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE12,
+      ngx_http_echo_echo_location,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("echo_subrequest_async"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_2MORE,
+      ngx_http_echo_echo_subrequest_async,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("echo_subrequest"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_2MORE,
+      ngx_http_echo_echo_subrequest,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("echo_duplicate"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_2MORE,
+      ngx_http_echo_echo_duplicate,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      0,
+      NULL },
+
+    { ngx_string("echo_read_request_body"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_read_request_body,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_foreach_split"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_2MORE,
+      ngx_http_echo_echo_foreach_split,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_end"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_end,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_abort_parent"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_NOARGS,
+      ngx_http_echo_echo_abort_parent,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+    { ngx_string("echo_exec"),
+      NGX_HTTP_LOC_CONF|NGX_HTTP_LIF_CONF|NGX_CONF_TAKE12,
+      ngx_http_echo_echo_exec,
+      NGX_HTTP_LOC_CONF_OFFSET,
+      offsetof(ngx_http_echo_loc_conf_t, handler_cmds),
+      NULL },
+
+      ngx_null_command
+};
+
+
+ngx_module_t ngx_http_echo_module = {
+    NGX_MODULE_V1,
+    &ngx_http_echo_module_ctx, /* module context */
+    ngx_http_echo_commands,   /* module directives */
+    NGX_HTTP_MODULE,               /* module type */
+    NULL,                          /* init master */
+    NULL,                          /* init module */
+    NULL,                          /* init process */
+    NULL,                          /* init thread */
+    NULL,                          /* exit thread */
+    NULL,                          /* exit process */
+    NULL,                          /* exit master */
+    NGX_MODULE_V1_PADDING
+};
+
+
+static void *
+ngx_http_echo_create_conf(ngx_conf_t *cf)
+{
+    ngx_http_echo_loc_conf_t *conf;
+    conf = ngx_pcalloc(cf->pool, sizeof(ngx_http_echo_loc_conf_t));
+    if (conf == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    return conf;
+}
+
+
+static char *
+ngx_http_echo_helper(ngx_http_echo_opcode_t opcode,
+        ngx_http_echo_cmd_category_t cat,
+        ngx_conf_t *cf, ngx_command_t *cmd, void* conf)
+{
+    ngx_http_core_loc_conf_t        *clcf;
+    /* ngx_http_echo_loc_conf_t        *ulcf = conf; */
+    ngx_array_t                    **args_ptr;
+    ngx_http_script_compile_t        sc;
+    ngx_str_t                       *raw_args;
+    ngx_http_echo_arg_template_t    *arg;
+    ngx_array_t                    **cmds_ptr;
+    ngx_http_echo_cmd_t             *echo_cmd;
+    ngx_uint_t                       i, n;
+
+    /* cmds_ptr points to ngx_http_echo_loc_conf_t's
+     * handler_cmds, before_body_cmds, or after_body_cmds
+     * array, depending on the actual offset */
+    cmds_ptr = (ngx_array_t**)(((u_char*)conf) + cmd->offset);
+
+    if (*cmds_ptr == NULL) {
+        *cmds_ptr = ngx_array_create(cf->pool, 1,
+                sizeof(ngx_http_echo_cmd_t));
+
+        if (*cmds_ptr == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        if (cat == echo_handler_cmd) {
+            dd("registering the content handler");
+            /* register the content handler */
+            clcf = ngx_http_conf_get_module_loc_conf(cf,
+                    ngx_http_core_module);
+
+            dd("registering the content handler (2)");
+            clcf->handler = ngx_http_echo_handler;
+
+        } else {
+            dd("filter used = 1");
+            ngx_http_echo_filter_used = 1;
+        }
+    }
+
+    echo_cmd = ngx_array_push(*cmds_ptr);
+
+    if (echo_cmd == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    echo_cmd->opcode = opcode;
+
+    args_ptr = &echo_cmd->args;
+    *args_ptr = ngx_array_create(cf->pool, 1,
+            sizeof(ngx_http_echo_arg_template_t));
+
+    if (*args_ptr == NULL) {
+        return NGX_CONF_ERROR;
+    }
+
+    raw_args = cf->args->elts;
+
+    /* we skip the first arg and start from the second */
+
+    for (i = 1 ; i < cf->args->nelts; i++) {
+        arg = ngx_array_push(*args_ptr);
+
+        if (arg == NULL) {
+            return NGX_CONF_ERROR;
+        }
+
+        arg->raw_value = raw_args[i];
+
+        dd("found raw arg %s", raw_args[i].data);
+
+        arg->lengths = NULL;
+        arg->values  = NULL;
+
+        n = ngx_http_script_variables_count(&arg->raw_value);
+
+        if (n > 0) {
+            ngx_memzero(&sc, sizeof(ngx_http_script_compile_t));
+
+            sc.cf = cf;
+            sc.source = &arg->raw_value;
+            sc.lengths = &arg->lengths;
+            sc.values = &arg->values;
+            sc.variables = n;
+            sc.complete_lengths = 1;
+            sc.complete_values = 1;
+
+            if (ngx_http_script_compile(&sc) != NGX_OK) {
+                return NGX_CONF_ERROR;
+            }
+        }
+    } /* end for */
+
+    return NGX_CONF_OK;
+}
+
+
+static char *
+ngx_http_echo_echo(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    dd("in echo_echo...");
+    return ngx_http_echo_helper(echo_opcode_echo,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_request_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    dd("in echo_echo_request_body...");
+    return ngx_http_echo_helper(echo_opcode_echo_request_body,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_sleep(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    dd("in echo_sleep...");
+    return ngx_http_echo_helper(echo_opcode_echo_sleep,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_flush(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    dd("in echo_flush...");
+    return ngx_http_echo_helper(echo_opcode_echo_flush,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_blocking_sleep(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    dd("in echo_blocking_sleep...");
+    return ngx_http_echo_helper(echo_opcode_echo_blocking_sleep,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_reset_timer(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(echo_opcode_echo_reset_timer,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_before_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    dd("processing echo_before_body directive...");
+    return ngx_http_echo_helper(echo_opcode_echo_before_body,
+            echo_filter_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_after_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(echo_opcode_echo_after_body,
+            echo_filter_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ ngx_http_echo_echo_location_async(ngx_conf_t *cf, ngx_command_t *cmd,
+         void *conf)
+{
+
+#if ! defined(nginx_version)
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "Directive echo_location_async does not work with nginx "
+            "versions ealier than 0.7.46.");
+
+    return NGX_CONF_ERROR;
+
+#else
+
+    return ngx_http_echo_helper(echo_opcode_echo_location_async,
+            echo_handler_cmd,
+            cf, cmd, conf);
+
+#endif
+
+}
+
+
+static char *
+ ngx_http_echo_echo_location(ngx_conf_t *cf, ngx_command_t *cmd,
+         void *conf)
+{
+
+#if ! defined(nginx_version)
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "Directive echo_location does not work with nginx "
+            "versions ealier than 0.7.46.");
+
+    return NGX_CONF_ERROR;
+
+#else
+
+    return ngx_http_echo_helper(echo_opcode_echo_location,
+            echo_handler_cmd,
+            cf, cmd, conf);
+
+#endif
+
+}
+
+
+static char *
+ ngx_http_echo_echo_subrequest_async(ngx_conf_t *cf, ngx_command_t *cmd,
+         void *conf)
+{
+
+#if ! defined(nginx_version)
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "Directive echo_subrequest_async does not work with nginx "
+            "versions ealier than 0.7.46.");
+
+    return NGX_CONF_ERROR;
+
+#else
+
+    return ngx_http_echo_helper(echo_opcode_echo_subrequest_async,
+            echo_handler_cmd,
+            cf, cmd, conf);
+
+#endif
+
+}
+
+
+static char *
+ ngx_http_echo_echo_subrequest(ngx_conf_t *cf, ngx_command_t *cmd,
+         void *conf)
+{
+
+#if ! defined(nginx_version)
+
+    ngx_conf_log_error(NGX_LOG_EMERG, cf, 0,
+            "Directive echo_subrequest does not work with nginx "
+            "versions ealier than 0.7.46.");
+
+    return NGX_CONF_ERROR;
+
+#else
+
+    return ngx_http_echo_helper(echo_opcode_echo_subrequest,
+            echo_handler_cmd,
+            cf, cmd, conf);
+
+#endif
+
+}
+
+
+static char *
+ngx_http_echo_echo_duplicate(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(echo_opcode_echo_duplicate,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_read_request_body(ngx_conf_t *cf,
+        ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(
+            echo_opcode_echo_read_request_body,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_foreach_split(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(
+            echo_opcode_echo_foreach_split,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_end(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(
+            echo_opcode_echo_end,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_abort_parent(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(
+            echo_opcode_echo_abort_parent,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
+
+static char *
+ngx_http_echo_echo_exec(ngx_conf_t *cf, ngx_command_t *cmd, void *conf)
+{
+    return ngx_http_echo_helper(
+            echo_opcode_echo_exec,
+            echo_handler_cmd,
+            cf, cmd, conf);
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_module.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_module.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,118 @@
+/* Copyright (C) by agentzh */
+
+#ifndef NGX_HTTP_ECHO_MODULE_H
+#define NGX_HTTP_ECHO_MODULE_H
+
+#include <ngx_core.h>
+#include <ngx_http.h>
+#include <nginx.h>
+
+extern ngx_module_t ngx_http_echo_module;
+
+/* config directive's opcode */
+typedef enum {
+    echo_opcode_echo,
+    echo_opcode_echo_request_body,
+    echo_opcode_echo_sleep,
+    echo_opcode_echo_flush,
+    echo_opcode_echo_blocking_sleep,
+    echo_opcode_echo_reset_timer,
+    echo_opcode_echo_before_body,
+    echo_opcode_echo_after_body,
+    echo_opcode_echo_location_async,
+    echo_opcode_echo_location,
+    echo_opcode_echo_subrequest_async,
+    echo_opcode_echo_subrequest,
+    echo_opcode_echo_duplicate,
+    echo_opcode_echo_read_request_body,
+    echo_opcode_echo_foreach_split,
+    echo_opcode_echo_end,
+    echo_opcode_echo_abort_parent,
+    echo_opcode_echo_exec
+} ngx_http_echo_opcode_t;
+
+/* all the various config directives (or commands) are
+ * divided into two categories: "handler commands",
+ * and "filter commands". For instance, the "echo"
+ * directive is a handler command while
+ * "echo_before_body" is a filter one. */
+typedef enum {
+    echo_handler_cmd,
+    echo_filter_cmd
+
+} ngx_http_echo_cmd_category_t;
+
+/* compiled form of a config directive argument's value */
+typedef struct {
+    /* holds the raw string of the argument value */
+    ngx_str_t       raw_value;
+
+    /* fields "lengths" and "values" are set by
+     * the function ngx_http_script_compile,
+     * iff the argument value indeed contains
+     * nginx variables like "$foo" */
+    ngx_array_t     *lengths;
+    ngx_array_t     *values;
+
+} ngx_http_echo_arg_template_t;
+
+/* represent a config directive (or command) like "echo". */
+typedef struct {
+    ngx_http_echo_opcode_t      opcode;
+
+    /* each argument is of type echo_arg_template_t: */
+    ngx_array_t                 *args;
+} ngx_http_echo_cmd_t;
+
+/* location config struct */
+typedef struct {
+    /* elements of the following arrays are of type
+     * ngx_http_echo_cmd_t */
+    ngx_array_t     *handler_cmds;
+    ngx_array_t     *before_body_cmds;
+    ngx_array_t     *after_body_cmds;
+
+} ngx_http_echo_loc_conf_t;
+
+typedef struct {
+    ngx_array_t     *choices; /* items after splitting */
+    ngx_uint_t      next_choice;  /* current item index */
+    ngx_uint_t      cmd_index; /* cmd index for the echo_foreach direcitve */
+} ngx_http_echo_foreach_ctx_t;
+
+/* context struct in the request handling cycle, holding
+ * the current states of the command evaluator */
+typedef struct {
+    /* index of the next handler command in
+     * ngx_http_echo_loc_conf_t's "handler_cmds" array. */
+    ngx_uint_t       next_handler_cmd;
+
+    /* index of the next before-body filter command in
+     * ngx_http_echo_loc_conf_t's "before_body_cmds" array. */
+    ngx_uint_t       next_before_body_cmd;
+
+    /* index of the next after-body filter command in
+     * ngx_http_echo_loc_conf_t's "after_body_cmds" array. */
+    ngx_uint_t       next_after_body_cmd;
+
+    ngx_http_echo_foreach_ctx_t   *foreach;
+
+    ngx_flag_t       headers_sent;
+    ngx_flag_t       before_body_sent;
+    ngx_flag_t       skip_filter;
+
+    ngx_time_t       timer_begin;
+
+    ngx_event_t      sleep;
+
+    ngx_uint_t       counter;
+
+    ngx_flag_t       wait_read_request_body;
+
+    ngx_flag_t       waiting;
+    ngx_flag_t       done;
+} ngx_http_echo_ctx_t;
+
+
+#endif /* NGX_HTTP_ECHO_MODULE_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_request_info.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_request_info.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,269 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_request_info.h"
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_handler.h"
+
+#include <nginx.h>
+
+
+static void ngx_http_echo_post_read_request_body(ngx_http_request_t *r);
+
+ngx_int_t
+ngx_http_echo_exec_echo_read_request_body(
+        ngx_http_request_t* r, ngx_http_echo_ctx_t *ctx)
+{
+    return ngx_http_read_client_request_body(r, ngx_http_echo_post_read_request_body);
+}
+
+
+static void
+ngx_http_echo_post_read_request_body(ngx_http_request_t *r)
+{
+    ngx_http_echo_ctx_t         *ctx;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    dd("wait read request body %d", (int) ctx->wait_read_request_body);
+
+    if (ctx->wait_read_request_body) {
+        ctx->waiting = 0;
+        ctx->done = 1;
+
+        r->write_event_handler = ngx_http_echo_wev_handler;
+
+        ngx_http_echo_wev_handler(r);
+    }
+}
+
+
+/* this function's implementation is borrowed from nginx 0.8.20
+ * and modified a bit to work with subrequests.
+ * Copyrighted (C) by Igor Sysoev */
+ngx_int_t
+ngx_http_echo_request_method_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    if (r->method_name.data) {
+        v->len = r->method_name.len;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+        v->data = r->method_name.data;
+    } else {
+        v->not_found = 1;
+    }
+
+    return NGX_OK;
+}
+
+
+/* this function's implementation is borrowed from nginx 0.8.20
+ * and modified a bit to work with subrequests.
+ * Copyrighted (C) by Igor Sysoev */
+ngx_int_t
+ngx_http_echo_client_request_method_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    if (r->main->method_name.data) {
+        v->len = r->main->method_name.len;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+        v->data = r->main->method_name.data;
+    } else {
+        v->not_found = 1;
+    }
+
+    return NGX_OK;
+}
+
+
+/* this function's implementation is borrowed from nginx 0.8.20
+ * and modified a bit to work with subrequests.
+ * Copyrighted (C) by Igor Sysoev */
+ngx_int_t
+ngx_http_echo_request_body_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    u_char       *p;
+    size_t        len;
+    ngx_buf_t    *buf, *next;
+    ngx_chain_t  *cl;
+
+#if 0
+
+    dd("rrr request_body null ? %d", r->request_body == NULL);
+    if (r->request_body) {
+        dd("rrr request_body bufs null ? %d", r->request_body->bufs == NULL);
+        dd("rrr request_body temp file ? %d", r->request_body->temp_file != NULL);
+    }
+    dd("rrr request_body content length ? %ld", (long) r->headers_in.content_length_n);
+
+#endif
+
+    if (r->request_body == NULL
+        || r->request_body->bufs == NULL
+        || r->request_body->temp_file)
+    {
+        v->not_found = 1;
+
+        return NGX_OK;
+    }
+
+    cl = r->request_body->bufs;
+    buf = cl->buf;
+
+    if (cl->next == NULL) {
+        v->len = buf->last - buf->pos;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+        v->data = buf->pos;
+
+        return NGX_OK;
+    }
+
+    next = cl->next->buf;
+    len = (buf->last - buf->pos) + (next->last - next->pos);
+
+    p = ngx_pnalloc(r->pool, len);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    v->data = p;
+
+    p = ngx_cpymem(p, buf->pos, buf->last - buf->pos);
+    ngx_memcpy(p, next->pos, next->last - next->pos);
+
+    v->len = len;
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_client_request_headers_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    size_t                      size;
+    u_char                      *p, *last;
+    ngx_buf_t                   *header_in;
+    ngx_flag_t                  just_seen_crlf;
+
+    if (r != r->main) {
+        header_in = r->main->header_in;
+    } else {
+        header_in = r->header_in;
+    }
+
+    if (header_in == NULL) {
+        v->not_found = 1;
+        return NGX_OK;
+    }
+
+    size = header_in->pos - header_in->start;
+
+    v->data = ngx_palloc(r->pool, size);
+    last = ngx_cpymem(v->data, header_in->start, size);
+
+    /* fix \0 introduced by the nginx header parser and
+     * locate the end of the header */
+    just_seen_crlf = 0;
+    for (p = (u_char*)v->data; p != last; p++) {
+        if (*p == '\0') {
+            if (p + 1 != last && *(p + 1) == LF) {
+                just_seen_crlf = 1;
+                *p = CR;
+            } else {
+                *p = ':';
+                just_seen_crlf = 0;
+            }
+        } else if (*p == CR) {
+            if (just_seen_crlf) {
+                *p = '\0';
+                last = p;
+                break;
+            }
+        } else if (*p != LF) {
+            just_seen_crlf = 0;
+        }
+    }
+
+    v->len = last - v->data;
+    v->valid = 1;
+    v->no_cacheable = 0;
+    v->not_found = 0;
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_cacheable_request_uri_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    if (r->uri.len) {
+        v->len = r->uri.len;
+        v->valid = 1;
+        v->no_cacheable = 0;
+        v->not_found = 0;
+        v->data = r->uri.data;
+    } else {
+        v->not_found = 1;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_request_uri_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    if (r->uri.len) {
+        v->len = r->uri.len;
+        v->valid = 1;
+        v->no_cacheable = 1;
+        v->not_found = 0;
+        v->data = r->uri.data;
+    } else {
+        v->not_found = 1;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_response_status_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    u_char                      *p;
+
+    if (r->headers_out.status) {
+        dd("headers out status: %d", (int) r->headers_out.status);
+
+        p = ngx_palloc(r->pool, NGX_INT_T_LEN);
+        if (p == NULL) {
+            return NGX_ERROR;
+        }
+
+        v->len = ngx_sprintf(p, "%ui", r->headers_out.status) - p;
+        v->data = p;
+
+        v->valid = 1;
+        v->no_cacheable = 1;
+        v->not_found = 0;
+    } else {
+        v->not_found = 1;
+    }
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_request_info.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_request_info.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,31 @@
+#ifndef ECHO_REQUEST_INFO_H
+#define ECHO_REQUEST_INFO_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_exec_echo_read_request_body(
+        ngx_http_request_t* r, ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_request_method_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_client_request_method_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_request_body_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_client_request_headers_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_cacheable_request_uri_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_request_uri_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_response_status_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+#endif /* ECHO_REQUEST_INFO_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_sleep.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_sleep.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,200 @@
+/* Copyright (C) agentzh */
+
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_sleep.h"
+#include "ngx_http_echo_handler.h"
+
+#include <nginx.h>
+#include <ngx_log.h>
+
+/* event handler for echo_sleep */
+
+static void ngx_http_echo_post_sleep(ngx_http_request_t *r);
+
+static void ngx_http_echo_sleep_cleanup(void *data);
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_sleep(
+        ngx_http_request_t *r, ngx_http_echo_ctx_t *ctx,
+        ngx_array_t *computed_args)
+{
+    ngx_str_t                   *computed_arg;
+    ngx_str_t                   *computed_arg_elts;
+    float                        delay; /* in sec */
+    ngx_http_cleanup_t          *cln;
+
+    computed_arg_elts = computed_args->elts;
+    computed_arg = &computed_arg_elts[0];
+
+    delay = atof( (char*) computed_arg->data );
+
+    if (delay < 0.001) { /* should be bigger than 1 msec */
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                   "invalid sleep duration \"%V\"", &computed_arg_elts[0]);
+
+        return NGX_HTTP_BAD_REQUEST;
+    }
+
+    dd("DELAY = %.02lf sec", delay);
+
+    ngx_add_timer(&ctx->sleep, (ngx_msec_t) (1000 * delay));
+
+    /* we don't check broken downstream connections
+     * ourselves so even if the client shuts down
+     * the connection prematurely, nginx will still
+     * go on waiting for our timers to get properly
+     * expired. However, we'd still register a
+     * cleanup handler for completeness. */
+
+    cln = ngx_http_cleanup_add(r, 0);
+    if (cln == NULL) {
+        return NGX_ERROR;
+    }
+
+    cln->handler = ngx_http_echo_sleep_cleanup;
+    cln->data = r;
+
+    return NGX_AGAIN;
+}
+
+
+static void
+ngx_http_echo_post_sleep(ngx_http_request_t *r)
+{
+    ngx_http_echo_ctx_t         *ctx;
+    /* ngx_int_t                    rc; */
+
+    dd("entered echo post sleep...(r->done: %d)", r->done);
+
+    dd("sleep: before get module ctx");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+
+    if (ctx == NULL) {
+        return;
+    }
+
+    ctx->waiting = 0;
+    ctx->done = 1;
+
+    dd("sleep: after get module ctx");
+
+    dd("timed out? %d", ctx->sleep.timedout);
+    dd("timer set? %d", ctx->sleep.timer_set);
+
+    if ( ! ctx->sleep.timedout ) {
+        dd("HERE reached!");
+        return;
+    }
+
+    ctx->sleep.timedout = 0;
+
+    if (ctx->sleep.timer_set) {
+        dd("deleting timer for echo_sleep");
+
+        ngx_del_timer(&ctx->sleep);
+    }
+
+    /* r->write_event_handler = ngx_http_request_empty_handler; */
+
+    ngx_http_echo_wev_handler(r);
+}
+
+
+void
+ngx_http_echo_sleep_event_handler(ngx_event_t *ev)
+{
+    ngx_connection_t        *c;
+    ngx_http_request_t      *r;
+    ngx_http_log_ctx_t      *ctx;
+
+    r = ev->data;
+    c = r->connection;
+
+    if (c->destroyed) {
+        return;
+    }
+
+    ctx = c->log->data;
+    ctx->current_request = r;
+
+    /* XXX when r->done == 1 we should do cleaning immediately
+     * and delete our timer and then quit. */
+
+    ngx_log_debug2(NGX_LOG_DEBUG_HTTP, c->log, 0,
+            "echo sleep handler: \"%V?%V\"", &r->uri, &r->args);
+
+    /*
+    if (r->done) {
+        return;
+    }
+    */
+
+    ngx_http_echo_post_sleep(r);
+
+#if defined(nginx_version)
+
+    dd("before run posted requests");
+
+    ngx_http_run_posted_requests(c);
+
+    dd("after run posted requests");
+
+#endif
+
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_blocking_sleep(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_str_t                   *computed_arg;
+    ngx_str_t                   *computed_arg_elts;
+    float                       delay; /* in sec */
+
+    computed_arg_elts = computed_args->elts;
+    computed_arg = &computed_arg_elts[0];
+
+    delay = atof( (char*) computed_arg->data );
+
+    if (delay < 0.001) { /* should be bigger than 1 msec */
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                   "invalid sleep duration \"%V\"", &computed_arg_elts[0]);
+        return NGX_HTTP_BAD_REQUEST;
+    }
+
+    dd("blocking DELAY = %.02lf sec", delay);
+
+    ngx_msleep((ngx_msec_t) (1000 * delay));
+
+    return NGX_OK;
+}
+
+
+static void
+ngx_http_echo_sleep_cleanup(void *data)
+{
+    ngx_http_request_t      *r = data;
+    ngx_http_echo_ctx_t         *ctx;
+
+    dd("echo sleep cleanup");
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+    if (ctx == NULL) {
+        return;
+    }
+
+    if (ctx->sleep.timer_set) {
+        dd("cleanup: deleting timer for echo_sleep");
+
+        ngx_del_timer(&ctx->sleep);
+        return;
+    }
+
+    dd("cleanup: timer not set");
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_sleep.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_sleep.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,16 @@
+#ifndef ECHO_SLEEP_H
+#define ECHO_SLEEP_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_exec_echo_sleep(
+        ngx_http_request_t *r, ngx_http_echo_ctx_t *ctx,
+        ngx_array_t *computed_args);
+
+ngx_int_t ngx_http_echo_exec_echo_blocking_sleep(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+void ngx_http_echo_sleep_event_handler(ngx_event_t *ev);
+
+#endif /* ECHO_SLEEP_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_subrequest.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_subrequest.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,606 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_subrequest.h"
+#include "ngx_http_echo_handler.h"
+
+#define ngx_http_echo_method_name(m) { sizeof(m) - 1, (u_char *) m " " }
+
+ngx_str_t  ngx_http_echo_content_length_header_key = ngx_string("Content-Length");
+
+ngx_str_t  ngx_http_echo_get_method = ngx_http_echo_method_name("GET");
+ngx_str_t  ngx_http_echo_put_method = ngx_http_echo_method_name("PUT");
+ngx_str_t  ngx_http_echo_post_method = ngx_http_echo_method_name("POST");
+ngx_str_t  ngx_http_echo_head_method = ngx_http_echo_method_name("HEAD");
+ngx_str_t  ngx_http_echo_copy_method = ngx_http_echo_method_name("COPY");
+ngx_str_t  ngx_http_echo_move_method = ngx_http_echo_method_name("MOVE");
+ngx_str_t  ngx_http_echo_lock_method = ngx_http_echo_method_name("LOCK");
+ngx_str_t  ngx_http_echo_mkcol_method = ngx_http_echo_method_name("MKCOL");
+ngx_str_t  ngx_http_echo_trace_method = ngx_http_echo_method_name("TRACE");
+ngx_str_t  ngx_http_echo_delete_method = ngx_http_echo_method_name("DELETE");
+ngx_str_t  ngx_http_echo_unlock_method = ngx_http_echo_method_name("UNLOCK");
+ngx_str_t  ngx_http_echo_options_method = ngx_http_echo_method_name("OPTIONS");
+ngx_str_t  ngx_http_echo_propfind_method = ngx_http_echo_method_name("PROPFIND");
+ngx_str_t  ngx_http_echo_proppatch_method = ngx_http_echo_method_name("PROPPATCH");
+
+
+typedef struct ngx_http_echo_subrequest_s {
+    ngx_uint_t                  method;
+    ngx_str_t                   *method_name;
+    ngx_str_t                   *location;
+    ngx_str_t                   *query_string;
+    ssize_t                     content_length_n;
+    ngx_http_request_body_t     *request_body;
+} ngx_http_echo_subrequest_t;
+
+
+static ngx_int_t ngx_http_echo_parse_method_name(ngx_str_t **method_name_ptr);
+
+static ngx_int_t ngx_http_echo_adjust_subrequest(ngx_http_request_t *sr,
+        ngx_http_echo_subrequest_t *parsed_sr);
+
+static ngx_int_t ngx_http_echo_parse_subrequest_spec(ngx_http_request_t *r,
+        ngx_array_t *computed_args, ngx_http_echo_subrequest_t **parsed_sr_ptr);
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_subrequest_async(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_int_t                       rc;
+    ngx_http_echo_subrequest_t      *parsed_sr;
+    ngx_http_request_t              *sr; /* subrequest object */
+    ngx_str_t                       args;
+    ngx_uint_t                      flags = 0;
+
+
+    dd_enter();
+
+    rc = ngx_http_echo_parse_subrequest_spec(r, computed_args, &parsed_sr);
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    dd("location: %s", parsed_sr->location->data);
+    dd("location args: %s", (char*) (parsed_sr->query_string ?
+                parsed_sr->query_string->data : (u_char*)"NULL"));
+
+    args.data = NULL;
+    args.len = 0;
+
+    if (ngx_http_parse_unsafe_uri(r, parsed_sr->location, &args, &flags)
+            != NGX_OK)
+    {
+        ctx->headers_sent = 1;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (args.len > 0 && parsed_sr->query_string == NULL) {
+        parsed_sr->query_string = &args;
+    }
+
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+    if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    rc = ngx_http_subrequest(r, parsed_sr->location, parsed_sr->query_string,
+            &sr, NULL, 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_echo_adjust_subrequest(sr, parsed_sr);
+
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_subrequest(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_int_t                           rc;
+    ngx_http_request_t                  *sr; /* subrequest object */
+    ngx_http_post_subrequest_t          *psr;
+    ngx_http_echo_subrequest_t          *parsed_sr;
+    ngx_str_t                           args;
+    ngx_uint_t                          flags = 0;
+
+
+    dd_enter();
+
+    rc = ngx_http_echo_parse_subrequest_spec(r, computed_args, &parsed_sr);
+    if (rc != NGX_OK) {
+        return rc;
+    }
+
+    args.data = NULL;
+    args.len = 0;
+
+    if (ngx_http_parse_unsafe_uri(r, parsed_sr->location, &args, &flags)
+            != NGX_OK) {
+        ctx->headers_sent = 1;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (args.len > 0 && parsed_sr->query_string == NULL) {
+        parsed_sr->query_string = &args;
+    }
+
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+
+    if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    psr = ngx_palloc(r->pool, sizeof(ngx_http_post_subrequest_t));
+
+    if (psr == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    psr->handler = ngx_http_echo_post_subrequest;
+    psr->data = ctx;
+
+    rc = ngx_http_subrequest(r, parsed_sr->location, parsed_sr->query_string,
+            &sr, psr, 0);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    rc = ngx_http_echo_adjust_subrequest(sr, parsed_sr);
+
+    if (rc != NGX_OK) {
+        return NGX_ERROR;
+    }
+
+    return NGX_AGAIN;
+}
+
+
+static ngx_int_t
+ngx_http_echo_parse_subrequest_spec(ngx_http_request_t *r,
+        ngx_array_t *computed_args, ngx_http_echo_subrequest_t **parsed_sr_ptr)
+{
+    ngx_str_t                   *computed_arg_elts, *arg;
+    ngx_str_t                  **to_write = NULL;
+    ngx_str_t                   *method_name;
+    ngx_str_t                   *body_str = NULL;
+    ngx_uint_t                   i;
+    ngx_flag_t                   expecting_opt;
+    ngx_http_request_body_t     *rb = NULL;
+    ngx_buf_t                   *b;
+    ngx_http_echo_subrequest_t  *parsed_sr;
+
+    *parsed_sr_ptr = ngx_pcalloc(r->pool, sizeof(ngx_http_echo_subrequest_t));
+    if (*parsed_sr_ptr == NULL) {
+        return NGX_ERROR;
+    }
+
+    parsed_sr = *parsed_sr_ptr;
+
+    computed_arg_elts = computed_args->elts;
+
+    method_name = &computed_arg_elts[0];
+
+    parsed_sr->location     = &computed_arg_elts[1];
+
+    if (parsed_sr->location->len == 0) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    expecting_opt = 1;
+    for (i = 2; i < computed_args->nelts; i++) {
+        arg = &computed_arg_elts[i];
+        if (!expecting_opt) {
+            if (to_write == NULL) {
+                ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                        "echo_subrequest_async: to_write should NOT be NULL");
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+
+            *to_write = arg;
+            to_write = NULL;
+
+            expecting_opt = 1;
+
+            continue;
+        }
+
+        if (arg->len == 2) {
+            if (ngx_strncmp("-q", arg->data, arg->len) == 0) {
+                to_write = &parsed_sr->query_string;
+                expecting_opt = 0;
+                continue;
+            }
+
+            if (ngx_strncmp("-b", arg->data, arg->len) == 0) {
+                to_write = &body_str;
+                expecting_opt = 0;
+                continue;
+            }
+        }
+
+        ngx_log_error(NGX_LOG_ERR, r->connection->log, 0,
+                "Unknown option for echo_subrequest_async: %V", arg);
+
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (body_str != NULL && body_str->len != 0) {
+        rb = ngx_pcalloc(r->pool, sizeof(ngx_http_request_body_t));
+
+        if (rb == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        parsed_sr->content_length_n = body_str->len;
+
+        b = ngx_calloc_buf(r->pool);
+        if (b == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        b->temporary = 1;
+        /* b->memory = 1; */
+        b->start = b->pos = body_str->data;
+        b->end = b->last = body_str->data + body_str->len;
+
+        rb->bufs = ngx_alloc_chain_link(r->pool);
+        if (rb->bufs == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        rb->bufs->buf = b;
+        rb->bufs->next = NULL;
+
+        rb->buf = b;
+    }
+
+    parsed_sr->request_body = rb;
+
+    parsed_sr->method = ngx_http_echo_parse_method_name(&method_name);
+    parsed_sr->method_name  = method_name;
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_echo_adjust_subrequest(ngx_http_request_t *sr,
+        ngx_http_echo_subrequest_t *parsed_sr)
+{
+    ngx_table_elt_t            *h;
+    ngx_http_core_main_conf_t  *cmcf;
+    ngx_http_request_t         *r;
+
+    sr->method = parsed_sr->method;
+    sr->method_name = *(parsed_sr->method_name);
+
+    r = sr->parent;
+
+    sr->header_in = r->header_in;
+
+    /* XXX work-around a bug in ngx_http_subrequest */
+    if (r->headers_in.headers.last == &r->headers_in.headers.part) {
+        sr->headers_in.headers.last = &sr->headers_in.headers.part;
+    }
+
+    /* we do not inherit the parent request's variables */
+    cmcf = ngx_http_get_module_main_conf(sr, ngx_http_core_module);
+    sr->variables = ngx_pcalloc(sr->pool, cmcf->variables.nelts
+                                        * sizeof(ngx_http_variable_value_t));
+
+    if (sr->variables == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (parsed_sr->content_length_n > 0) {
+        sr->headers_in.content_length_n = parsed_sr->content_length_n;
+        sr->request_body = parsed_sr->request_body;
+
+        sr->headers_in.content_length = ngx_pcalloc(sr->pool,
+                sizeof(ngx_table_elt_t));
+        sr->headers_in.content_length->value.data =
+            ngx_palloc(sr->pool, NGX_OFF_T_LEN);
+        if (sr->headers_in.content_length->value.data == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+        sr->headers_in.content_length->value.len = ngx_sprintf(
+                sr->headers_in.content_length->value.data, "%O",
+                sr->headers_in.content_length_n) -
+                sr->headers_in.content_length->value.data;
+
+        if (ngx_list_init(&sr->headers_in.headers, sr->pool, 20,
+                    sizeof(ngx_table_elt_t)) != NGX_OK) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        h = ngx_list_push(&sr->headers_in.headers);
+        if (h == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        h->hash = sr->header_hash;
+
+        h->key = ngx_http_echo_content_length_header_key;
+        h->value = sr->headers_in.content_length->value;
+
+        h->lowcase_key = ngx_pnalloc(sr->pool, h->key.len);
+        if (h->lowcase_key == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        ngx_strlow(h->lowcase_key, h->key.data, h->key.len);
+
+        dd("sr content length: %s", sr->headers_in.content_length->value.data);
+    }
+
+    dd("subrequest body: %p", sr->request_body);
+
+    return NGX_OK;
+}
+
+
+static ngx_int_t
+ngx_http_echo_parse_method_name(ngx_str_t **method_name_ptr)
+{
+    const ngx_str_t* method_name = *method_name_ptr;
+
+    switch (method_name->len) {
+    case 3:
+        if (ngx_http_echo_strcmp_const(method_name->data, "GET") == 0) {
+            *method_name_ptr = &ngx_http_echo_get_method;
+            return NGX_HTTP_GET;
+            break;
+        }
+
+        if (ngx_http_echo_strcmp_const(method_name->data, "PUT") == 0) {
+            *method_name_ptr = &ngx_http_echo_put_method;
+            return NGX_HTTP_PUT;
+            break;
+        }
+
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 4:
+        if (ngx_http_echo_strcmp_const(method_name->data, "POST") == 0) {
+            *method_name_ptr = &ngx_http_echo_post_method;
+            return NGX_HTTP_POST;
+            break;
+        }
+        if (ngx_http_echo_strcmp_const(method_name->data, "HEAD") == 0) {
+            *method_name_ptr = &ngx_http_echo_head_method;
+            return NGX_HTTP_HEAD;
+            break;
+        }
+        if (ngx_http_echo_strcmp_const(method_name->data, "COPY") == 0) {
+            *method_name_ptr = &ngx_http_echo_copy_method;
+            return NGX_HTTP_COPY;
+            break;
+        }
+        if (ngx_http_echo_strcmp_const(method_name->data, "MOVE") == 0) {
+            *method_name_ptr = &ngx_http_echo_move_method;
+            return NGX_HTTP_MOVE;
+            break;
+        }
+        if (ngx_http_echo_strcmp_const(method_name->data, "LOCK") == 0) {
+            *method_name_ptr = &ngx_http_echo_lock_method;
+            return NGX_HTTP_LOCK;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 5:
+        if (ngx_http_echo_strcmp_const(method_name->data, "MKCOL") == 0) {
+            *method_name_ptr = &ngx_http_echo_mkcol_method;
+            return NGX_HTTP_MKCOL;
+            break;
+        }
+        if (ngx_http_echo_strcmp_const(method_name->data, "TRACE") == 0) {
+            *method_name_ptr = &ngx_http_echo_trace_method;
+            return NGX_HTTP_TRACE;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 6:
+        if (ngx_http_echo_strcmp_const(method_name->data, "DELETE") == 0) {
+            *method_name_ptr = &ngx_http_echo_delete_method;
+            return NGX_HTTP_DELETE;
+            break;
+        }
+
+        if (ngx_http_echo_strcmp_const(method_name->data, "UNLOCK") == 0) {
+            *method_name_ptr = &ngx_http_echo_unlock_method;
+            return NGX_HTTP_UNLOCK;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 7:
+        if (ngx_http_echo_strcmp_const(method_name->data, "OPTIONS") == 0) {
+            *method_name_ptr = &ngx_http_echo_options_method;
+            return NGX_HTTP_OPTIONS;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 8:
+        if (ngx_http_echo_strcmp_const(method_name->data, "PROPFIND") == 0) {
+            *method_name_ptr = &ngx_http_echo_propfind_method;
+            return NGX_HTTP_PROPFIND;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    case 9:
+        if (ngx_http_echo_strcmp_const(method_name->data, "PROPPATCH") == 0) {
+            *method_name_ptr = &ngx_http_echo_proppatch_method;
+            return NGX_HTTP_PROPPATCH;
+            break;
+        }
+        return NGX_HTTP_UNKNOWN;
+        break;
+
+    default:
+        return NGX_HTTP_UNKNOWN;
+        break;
+    }
+
+    return NGX_HTTP_UNKNOWN;
+}
+
+
+/* XXX extermely evil and not working yet */
+ngx_int_t
+ngx_http_echo_exec_abort_parent(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx)
+{
+#if 0
+    ngx_http_postponed_request_t    *pr, *ppr;
+    ngx_http_request_t              *saved_data = NULL;
+    ngx_chain_t                     *out = NULL;
+    /* ngx_int_t                       rc; */
+
+    dd("aborting parent...");
+
+    if (r == r->main || r->parent == NULL) {
+        return NGX_OK;
+    }
+
+    if (r->parent->postponed) {
+        dd("Found parent->postponed...");
+
+        saved_data = r->connection->data;
+        ppr = NULL;
+        for (pr = r->parent->postponed; pr->next; pr = pr->next) {
+            if (pr->request == NULL) {
+                continue;
+            }
+
+            if (pr->request == r) {
+                /* r->parent->postponed->next = pr; */
+                dd("found the current subrequest");
+                out = pr->out;
+                continue;
+            }
+
+            /* r->connection->data = pr->request; */
+            dd("finalizing the subrequest...");
+            ngx_http_upstream_create(pr->request);
+            pr->request->upstream = NULL;
+
+            if (ppr == NULL) {
+                r->parent->postponed = pr->next;
+                ppr = pr->next;
+            } else {
+                ppr->next = pr->next;
+                ppr = pr->next;
+            }
+        }
+    }
+
+    r->parent->postponed->next = NULL;
+
+    /*
+    r->connection->data = r->parent;
+    r->connection->buffered = 0;
+
+    if (out != NULL) {
+        dd("trying to send more stuffs for the parent");
+        ngx_http_output_filter(r->parent, out);
+    }
+    */
+
+    /* ngx_http_send_special(r->parent, NGX_HTTP_LAST); */
+
+    if (saved_data) {
+        r->connection->data = saved_data;
+    }
+
+    dd("terminating the parent request");
+
+    return ngx_http_echo_send_chain_link(r, ctx, NULL /* indicate LAST */);
+
+    /* ngx_http_upstream_create(r); */
+
+    /* ngx_http_finalize_request(r->parent, NGX_ERROR); */
+#endif
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_exec(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args)
+{
+    ngx_str_t                       *uri;
+    ngx_str_t                       *user_args;
+    ngx_str_t                        args;
+    ngx_uint_t                       flags;
+    ngx_str_t                       *computed_arg;
+
+    computed_arg = computed_args->elts;
+
+    uri = &computed_arg[0];
+
+    if (uri->len == 0) {
+        return NGX_HTTP_BAD_REQUEST;
+    }
+
+    if (computed_args->nelts > 1) {
+        user_args = &computed_arg[1];
+    } else {
+        user_args = NULL;
+    }
+
+    args.data = NULL;
+    args.len = 0;
+
+    if (ngx_http_parse_unsafe_uri(r, uri, &args, &flags)
+            != NGX_OK) {
+        ctx->headers_sent = 1;
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    if (args.len > 0 && user_args == NULL) {
+        user_args = &args;
+    }
+
+    /*
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+    if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+    */
+
+    if (uri->data[0] == '@') {
+        if (user_args && user_args->len > 0) {
+            ngx_log_error(NGX_LOG_ALERT, r->connection->log, 0,
+                    "query strings %V ignored when exec'ing named location %V",
+                    user_args, uri);
+
+        }
+
+        return ngx_http_named_location(r, uri);
+    }
+
+    return ngx_http_internal_redirect(r, uri, user_args);
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_subrequest.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_subrequest.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,19 @@
+#ifndef ECHO_SUBREQUEST_H
+#define ECHO_SUBREQUEST_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_exec_echo_subrequest(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+ngx_int_t ngx_http_echo_exec_echo_subrequest_async(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+ngx_int_t ngx_http_echo_exec_abort_parent(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_exec_exec(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx, ngx_array_t *computed_args);
+
+#endif /* ECHO_SUBREQUEST_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_timer.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_timer.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,76 @@
+#define DDEBUG 0
+
+#include "ddebug.h"
+
+#include "ngx_http_echo_timer.h"
+
+#include <stdlib.h>
+#include <ngx_log.h>
+
+ngx_int_t
+ngx_http_echo_timer_elapsed_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data)
+{
+    ngx_http_echo_ctx_t     *ctx;
+    ngx_msec_int_t          ms;
+    u_char                  *p;
+    ngx_time_t              *tp;
+    size_t                  size;
+
+    ctx = ngx_http_get_module_ctx(r, ngx_http_echo_module);
+    if (ctx->timer_begin.sec == 0) {
+        ctx->timer_begin.sec  = r->start_sec;
+        ctx->timer_begin.msec = (ngx_msec_t) r->start_msec;
+    }
+
+    /* force the ngx timer to update */
+
+#if defined nginx_version && (nginx_version >= 8035 \
+        || (nginx_version < 8000 && nginx_version >= 7066))
+    ngx_time_update();
+#else
+    ngx_time_update(0, 0);
+#endif
+
+    tp = ngx_timeofday();
+
+    dd("old sec msec: %ld %d\n", ctx->timer_begin.sec, ctx->timer_begin.msec);
+    dd("new sec msec: %ld %d\n", tp->sec, tp->msec);
+
+    ms = (ngx_msec_int_t)
+             ((tp->sec - ctx->timer_begin.sec) * 1000 +
+              (tp->msec - ctx->timer_begin.msec));
+    ms = (ms >= 0) ? ms : 0;
+
+    size = sizeof("-9223372036854775808.000") - 1;
+    p = ngx_palloc(r->pool, size);
+    v->len = ngx_snprintf(p, size, "%T.%03M",
+             ms / 1000, ms % 1000) - p;
+    v->data = p;
+
+    v->valid = 1;
+    v->no_cacheable = 1;
+    v->not_found = 0;
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_exec_echo_reset_timer(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx)
+{
+    dd("Exec timer...");
+
+    /* force the ngx timer to update */
+
+#if defined nginx_version && (nginx_version >= 8035 \
+        || (nginx_version < 8000 && nginx_version >= 7066))
+    ngx_time_update();
+#else
+    ngx_time_update(0, 0);
+#endif
+
+    ctx->timer_begin = *ngx_timeofday();
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_timer.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_timer.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,13 @@
+#ifndef ECHO_TIMER_H
+#define ECHO_TIMER_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_timer_elapsed_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+ngx_int_t ngx_http_echo_exec_echo_reset_timer(ngx_http_request_t *r,
+        ngx_http_echo_ctx_t *ctx);
+
+#endif /* ECHO_TIMER_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_util.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_util.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,248 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_util.h"
+#include "ngx_http_echo_sleep.h"
+
+
+ngx_int_t
+ngx_http_echo_init_ctx(ngx_http_request_t *r, ngx_http_echo_ctx_t **ctx_ptr)
+{
+    ngx_http_echo_ctx_t         *ctx;
+
+    *ctx_ptr = ngx_pcalloc(r->pool, sizeof(ngx_http_echo_ctx_t));
+    if (*ctx_ptr == NULL) {
+        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+    }
+
+    ctx = *ctx_ptr;
+
+    ctx->sleep.handler   = ngx_http_echo_sleep_event_handler;
+    ctx->sleep.data      = r;
+    ctx->sleep.log       = r->connection->log;
+
+    return NGX_OK;
+}
+
+ngx_int_t
+ngx_http_echo_eval_cmd_args(ngx_http_request_t *r,
+        ngx_http_echo_cmd_t *cmd, ngx_array_t *computed_args,
+        ngx_array_t *opts)
+{
+    ngx_uint_t                       i;
+    ngx_array_t                     *args = cmd->args;
+    ngx_str_t                       *arg, *raw, *opt;
+    ngx_http_echo_arg_template_t    *value;
+    ngx_flag_t                       expecting_opts = 1;
+
+
+    value = args->elts;
+
+    for (i = 0; i < args->nelts; i++) {
+        raw = &value[i].raw_value;
+
+        if (value[i].lengths == NULL && raw->len > 0) {
+            if (expecting_opts) {
+                if (raw->len == 1 || raw->data[0] != '-') {
+                    expecting_opts = 0;
+
+                } else if (raw->data[1] == '-') {
+                    expecting_opts = 0;
+                    continue;
+
+                } else {
+                    opt = ngx_array_push(opts);
+                    if (opt == NULL) {
+                        return NGX_HTTP_INTERNAL_SERVER_ERROR;
+                    }
+
+                    opt->len = raw->len - 1;
+                    opt->data = raw->data + 1;
+
+                    continue;
+                }
+            }
+        }
+
+        arg = ngx_array_push(computed_args);
+        if (arg == NULL) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        if (value[i].lengths == NULL) { /* does not contain vars */
+            dd("Using raw value \"%.*s\"", (int) raw->len, raw->data);
+            *arg = *raw;
+
+        } else {
+            if (ngx_http_script_run(r, arg, value[i].lengths->elts,
+                        0, value[i].values->elts) == NULL)
+            {
+                return NGX_HTTP_INTERNAL_SERVER_ERROR;
+            }
+        }
+    }
+
+    return NGX_OK;
+}
+
+
+ngx_int_t
+ngx_http_echo_send_chain_link(ngx_http_request_t* r,
+        ngx_http_echo_ctx_t *ctx, ngx_chain_t *cl)
+{
+    ngx_int_t       rc;
+    size_t          size;
+    ngx_chain_t     *p;
+
+    rc = ngx_http_echo_send_header_if_needed(r, ctx);
+
+    if (r->header_only || rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+        return rc;
+    }
+
+    if (r->http_version < NGX_HTTP_VERSION_11 && !ctx->headers_sent) {
+        ctx->headers_sent = 1;
+
+        size = 0;
+
+        for (p = cl; p; p = p->next) {
+            if (p->buf->memory) {
+                size += p->buf->last - p->buf->pos;
+            }
+        }
+
+        r->headers_out.content_length_n = (off_t) size;
+
+        if (r->headers_out.content_length) {
+            r->headers_out.content_length->hash = 0;
+        }
+
+        r->headers_out.content_length = NULL;
+
+        rc = ngx_http_send_header(r);
+
+        if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+    }
+
+    if (cl == NULL) {
+
+#if defined(nginx_version) && nginx_version <= 8004
+
+        /* earlier versions of nginx does not allow subrequests
+            to send last_buf themselves */
+        if (r != r->main) {
+            return NGX_OK;
+        }
+
+#endif
+
+        rc = ngx_http_send_special(r, NGX_HTTP_LAST);
+        if (rc >= NGX_HTTP_SPECIAL_RESPONSE) {
+            return rc;
+        }
+
+        return NGX_OK;
+    }
+
+    return ngx_http_output_filter(r, cl);
+}
+
+ngx_int_t
+ngx_http_echo_send_header_if_needed(ngx_http_request_t* r,
+        ngx_http_echo_ctx_t *ctx) {
+    /* ngx_int_t   rc; */
+
+    if ( ! ctx->headers_sent ) {
+        r->headers_out.status = NGX_HTTP_OK;
+
+        if (ngx_http_set_content_type(r) != NGX_OK) {
+            return NGX_HTTP_INTERNAL_SERVER_ERROR;
+        }
+
+        ngx_http_clear_content_length(r);
+        ngx_http_clear_accept_ranges(r);
+
+        if (r->http_version >= NGX_HTTP_VERSION_11) {
+            ctx->headers_sent = 1;
+            return ngx_http_send_header(r);
+        }
+    }
+
+    return NGX_OK;
+}
+
+ssize_t
+ngx_http_echo_atosz(u_char *line, size_t n) {
+    ssize_t  value;
+
+    if (n == 0) {
+        return NGX_ERROR;
+    }
+
+    for (value = 0; n--; line++) {
+        if (*line == '_') { /* we ignore undercores */
+            continue;
+        }
+
+        if (*line < '0' || *line > '9') {
+            return NGX_ERROR;
+        }
+
+        value = value * 10 + (*line - '0');
+    }
+
+    if (value < 0) {
+        return NGX_ERROR;
+    } else {
+        return value;
+    }
+}
+
+/* Modified from the ngx_strlcasestrn function in ngx_string.h
+ * Copyright (C) by Igor Sysoev */
+u_char *
+ngx_http_echo_strlstrn(u_char *s1, u_char *last, u_char *s2, size_t n)
+{
+    ngx_uint_t  c1, c2;
+
+    c2 = (ngx_uint_t) *s2++;
+    last -= n;
+
+    do {
+        do {
+            if (s1 >= last) {
+                return NULL;
+            }
+
+            c1 = (ngx_uint_t) *s1++;
+
+        } while (c1 != c2);
+
+    } while (ngx_strncmp(s1, s2, n) != 0);
+
+    return --s1;
+}
+
+
+ngx_int_t
+ngx_http_echo_post_request_at_head(ngx_http_request_t *r,
+        ngx_http_posted_request_t *pr)
+{
+    dd_enter();
+
+    if (pr == NULL) {
+        pr = ngx_palloc(r->pool, sizeof(ngx_http_posted_request_t));
+        if (pr == NULL) {
+            return NGX_ERROR;
+        }
+    }
+
+    pr->request = r;
+    pr->next = r->main->posted_requests;
+    r->main->posted_requests = pr;
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_util.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_util.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,30 @@
+#ifndef NGX_HTTP_ECHO_UTIL_H
+#define NGX_HTTP_ECHO_UTIL_H
+
+#include "ngx_http_echo_module.h"
+
+#define ngx_http_echo_strcmp_const(a, b) \
+    ngx_strncmp(a, b, sizeof(b) - 1)
+
+ngx_int_t ngx_http_echo_init_ctx(ngx_http_request_t *r, ngx_http_echo_ctx_t **ctx_ptr);
+
+ngx_int_t ngx_http_echo_eval_cmd_args(ngx_http_request_t *r,
+        ngx_http_echo_cmd_t *cmd, ngx_array_t *computed_args,
+        ngx_array_t *opts);
+
+ngx_int_t ngx_http_echo_send_header_if_needed(ngx_http_request_t* r,
+        ngx_http_echo_ctx_t *ctx);
+
+ngx_int_t ngx_http_echo_send_chain_link(ngx_http_request_t* r,
+        ngx_http_echo_ctx_t *ctx, ngx_chain_t *cl);
+
+ssize_t ngx_http_echo_atosz(u_char *line, size_t n);
+
+u_char * ngx_http_echo_strlstrn(u_char *s1, u_char *last, u_char *s2, size_t n);
+
+ngx_int_t ngx_http_echo_post_request_at_head(ngx_http_request_t *r,
+        ngx_http_posted_request_t *pr);
+
+
+#endif /* NGX_HTTP_ECHO_UTIL_H */
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_var.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_var.c	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,98 @@
+#define DDEBUG 0
+#include "ddebug.h"
+
+#include "ngx_http_echo_var.h"
+#include "ngx_http_echo_timer.h"
+#include "ngx_http_echo_request_info.h"
+#include "ngx_http_echo_foreach.h"
+
+static ngx_int_t ngx_http_echo_incr_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data);
+
+static ngx_http_variable_t ngx_http_echo_variables[] = {
+    { ngx_string("echo_timer_elapsed"), NULL,
+      ngx_http_echo_timer_elapsed_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_request_method"), NULL,
+      ngx_http_echo_request_method_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_cacheable_request_uri"), NULL,
+      ngx_http_echo_cacheable_request_uri_variable, 0,
+      0, 0 },
+
+    { ngx_string("echo_request_uri"), NULL,
+      ngx_http_echo_request_uri_variable, 0,
+      0, 0 },
+
+    { ngx_string("echo_client_request_method"), NULL,
+      ngx_http_echo_client_request_method_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_request_body"), NULL,
+      ngx_http_echo_request_body_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_client_request_headers"), NULL,
+      ngx_http_echo_client_request_headers_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_it"), NULL,
+      ngx_http_echo_it_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_incr"), NULL,
+      ngx_http_echo_incr_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_string("echo_response_status"), NULL,
+      ngx_http_echo_response_status_variable, 0,
+      NGX_HTTP_VAR_NOCACHEABLE, 0 },
+
+    { ngx_null_string, NULL, NULL, 0, 0, 0 }
+};
+
+ngx_int_t
+ngx_http_echo_add_variables(ngx_conf_t *cf) {
+    ngx_http_variable_t *var, *v;
+    for (v = ngx_http_echo_variables; v->name.len; v++) {
+        var = ngx_http_add_variable(cf, &v->name, v->flags);
+        if (var == NULL) {
+            return NGX_ERROR;
+        }
+        var->get_handler = v->get_handler;
+        var->data = v->data;
+    }
+    return NGX_OK;
+}
+
+static ngx_int_t
+ngx_http_echo_incr_variable(ngx_http_request_t *r,
+        ngx_http_variable_value_t *v, uintptr_t data) {
+    ngx_http_echo_ctx_t         *ctx;
+    u_char                      *p;
+
+    ctx = ngx_http_get_module_ctx(r->main, ngx_http_echo_module);
+
+    if (ctx == NULL) {
+        return NGX_ERROR;
+    }
+
+    ctx->counter++;
+
+    p = ngx_palloc(r->pool, NGX_INT_T_LEN);
+    if (p == NULL) {
+        return NGX_ERROR;
+    }
+
+    v->len = ngx_sprintf(p, "%ui", ctx->counter) - p;
+    v->data = p;
+
+    v->valid = 1;
+    v->not_found = 0;
+    v->no_cacheable = 1;
+
+    return NGX_OK;
+}
+
Index: 0.8/modules/nginx-echo/src/ngx_http_echo_var.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/src/ngx_http_echo_var.h	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,9 @@
+#ifndef ECHO_VAR_H
+#define ECHO_VAR_H
+
+#include "ngx_http_echo_module.h"
+
+ngx_int_t ngx_http_echo_add_variables(ngx_conf_t *cf);
+
+#endif /* ECHO_VAR_H */
+
Index: 0.8/modules/nginx-echo/test/inc/Module/AutoInstall.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Module/AutoInstall.pm	2010-10-31 07:35:47.718338000 +0000
@@ -0,0 +1,820 @@
+#line 1
+package Module::AutoInstall;
+
+use strict;
+use Cwd                 ();
+use ExtUtils::MakeMaker ();
+
+use vars qw{$VERSION};
+BEGIN {
+	$VERSION = '1.03';
+}
+
+# special map on pre-defined feature sets
+my %FeatureMap = (
+    ''      => 'Core Features',    # XXX: deprecated
+    '-core' => 'Core Features',
+);
+
+# various lexical flags
+my ( @Missing, @Existing,  %DisabledTests, $UnderCPAN,     $HasCPANPLUS );
+my (
+    $Config, $CheckOnly, $SkipInstall, $AcceptDefault, $TestOnly, $AllDeps
+);
+my ( $PostambleActions, $PostambleUsed );
+
+# See if it's a testing or non-interactive session
+_accept_default( $ENV{AUTOMATED_TESTING} or ! -t STDIN );
+_init();
+
+sub _accept_default {
+    $AcceptDefault = shift;
+}
+
+sub missing_modules {
+    return @Missing;
+}
+
+sub do_install {
+    __PACKAGE__->install(
+        [
+            $Config
+            ? ( UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+            : ()
+        ],
+        @Missing,
+    );
+}
+
+# initialize various flags, and/or perform install
+sub _init {
+    foreach my $arg (
+        @ARGV,
+        split(
+            /[\s\t]+/,
+            $ENV{PERL_AUTOINSTALL} || $ENV{PERL_EXTUTILS_AUTOINSTALL} || ''
+        )
+      )
+    {
+        if ( $arg =~ /^--config=(.*)$/ ) {
+            $Config = [ split( ',', $1 ) ];
+        }
+        elsif ( $arg =~ /^--installdeps=(.*)$/ ) {
+            __PACKAGE__->install( $Config, @Missing = split( /,/, $1 ) );
+            exit 0;
+        }
+        elsif ( $arg =~ /^--default(?:deps)?$/ ) {
+            $AcceptDefault = 1;
+        }
+        elsif ( $arg =~ /^--check(?:deps)?$/ ) {
+            $CheckOnly = 1;
+        }
+        elsif ( $arg =~ /^--skip(?:deps)?$/ ) {
+            $SkipInstall = 1;
+        }
+        elsif ( $arg =~ /^--test(?:only)?$/ ) {
+            $TestOnly = 1;
+        }
+        elsif ( $arg =~ /^--all(?:deps)?$/ ) {
+            $AllDeps = 1;
+        }
+    }
+}
+
+# overrides MakeMaker's prompt() to automatically accept the default choice
+sub _prompt {
+    goto &ExtUtils::MakeMaker::prompt unless $AcceptDefault;
+
+    my ( $prompt, $default ) = @_;
+    my $y = ( $default =~ /^[Yy]/ );
+
+    print $prompt, ' [', ( $y ? 'Y' : 'y' ), '/', ( $y ? 'n' : 'N' ), '] ';
+    print "$default\n";
+    return $default;
+}
+
+# the workhorse
+sub import {
+    my $class = shift;
+    my @args  = @_ or return;
+    my $core_all;
+
+    print "*** $class version " . $class->VERSION . "\n";
+    print "*** Checking for Perl dependencies...\n";
+
+    my $cwd = Cwd::cwd();
+
+    $Config = [];
+
+    my $maxlen = length(
+        (
+            sort   { length($b) <=> length($a) }
+              grep { /^[^\-]/ }
+              map  {
+                ref($_)
+                  ? ( ( ref($_) eq 'HASH' ) ? keys(%$_) : @{$_} )
+                  : ''
+              }
+              map { +{@args}->{$_} }
+              grep { /^[^\-]/ or /^-core$/i } keys %{ +{@args} }
+        )[0]
+    );
+
+    # We want to know if we're under CPAN early to avoid prompting, but
+    # if we aren't going to try and install anything anyway then skip the
+    # check entirely since we don't want to have to load (and configure)
+    # an old CPAN just for a cosmetic message
+
+    $UnderCPAN = _check_lock(1) unless $SkipInstall;
+
+    while ( my ( $feature, $modules ) = splice( @args, 0, 2 ) ) {
+        my ( @required, @tests, @skiptests );
+        my $default  = 1;
+        my $conflict = 0;
+
+        if ( $feature =~ m/^-(\w+)$/ ) {
+            my $option = lc($1);
+
+            # check for a newer version of myself
+            _update_to( $modules, @_ ) and return if $option eq 'version';
+
+            # sets CPAN configuration options
+            $Config = $modules if $option eq 'config';
+
+            # promote every features to core status
+            $core_all = ( $modules =~ /^all$/i ) and next
+              if $option eq 'core';
+
+            next unless $option eq 'core';
+        }
+
+        print "[" . ( $FeatureMap{ lc($feature) } || $feature ) . "]\n";
+
+        $modules = [ %{$modules} ] if UNIVERSAL::isa( $modules, 'HASH' );
+
+        unshift @$modules, -default => &{ shift(@$modules) }
+          if ( ref( $modules->[0] ) eq 'CODE' );    # XXX: bugward combatability
+
+        while ( my ( $mod, $arg ) = splice( @$modules, 0, 2 ) ) {
+            if ( $mod =~ m/^-(\w+)$/ ) {
+                my $option = lc($1);
+
+                $default   = $arg    if ( $option eq 'default' );
+                $conflict  = $arg    if ( $option eq 'conflict' );
+                @tests     = @{$arg} if ( $option eq 'tests' );
+                @skiptests = @{$arg} if ( $option eq 'skiptests' );
+
+                next;
+            }
+
+            printf( "- %-${maxlen}s ...", $mod );
+
+            if ( $arg and $arg =~ /^\D/ ) {
+                unshift @$modules, $arg;
+                $arg = 0;
+            }
+
+            # XXX: check for conflicts and uninstalls(!) them.
+            my $cur = _load($mod);
+            if (_version_cmp ($cur, $arg) >= 0)
+            {
+                print "loaded. ($cur" . ( $arg ? " >= $arg" : '' ) . ")\n";
+                push @Existing, $mod => $arg;
+                $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+            }
+            else {
+                if (not defined $cur)   # indeed missing
+                {
+                    print "missing." . ( $arg ? " (would need $arg)" : '' ) . "\n";
+                }
+                else
+                {
+                    # no need to check $arg as _version_cmp ($cur, undef) would satisfy >= above
+                    print "too old. ($cur < $arg)\n";
+                }
+
+                push @required, $mod => $arg;
+            }
+        }
+
+        next unless @required;
+
+        my $mandatory = ( $feature eq '-core' or $core_all );
+
+        if (
+            !$SkipInstall
+            and (
+                $CheckOnly
+                or ($mandatory and $UnderCPAN)
+                or $AllDeps
+                or _prompt(
+                    qq{==> Auto-install the }
+                      . ( @required / 2 )
+                      . ( $mandatory ? ' mandatory' : ' optional' )
+                      . qq{ module(s) from CPAN?},
+                    $default ? 'y' : 'n',
+                ) =~ /^[Yy]/
+            )
+          )
+        {
+            push( @Missing, @required );
+            $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+        }
+
+        elsif ( !$SkipInstall
+            and $default
+            and $mandatory
+            and
+            _prompt( qq{==> The module(s) are mandatory! Really skip?}, 'n', )
+            =~ /^[Nn]/ )
+        {
+            push( @Missing, @required );
+            $DisabledTests{$_} = 1 for map { glob($_) } @skiptests;
+        }
+
+        else {
+            $DisabledTests{$_} = 1 for map { glob($_) } @tests;
+        }
+    }
+
+    if ( @Missing and not( $CheckOnly or $UnderCPAN ) ) {
+        require Config;
+        print
+"*** Dependencies will be installed the next time you type '$Config::Config{make}'.\n";
+
+        # make an educated guess of whether we'll need root permission.
+        print "    (You may need to do that as the 'root' user.)\n"
+          if eval '$>';
+    }
+    print "*** $class configuration finished.\n";
+
+    chdir $cwd;
+
+    # import to main::
+    no strict 'refs';
+    *{'main::WriteMakefile'} = \&Write if caller(0) eq 'main';
+
+    return (@Existing, @Missing);
+}
+
+sub _running_under {
+    my $thing = shift;
+    print <<"END_MESSAGE";
+*** Since we're running under ${thing}, I'll just let it take care
+    of the dependency's installation later.
+END_MESSAGE
+    return 1;
+}
+
+# Check to see if we are currently running under CPAN.pm and/or CPANPLUS;
+# if we are, then we simply let it taking care of our dependencies
+sub _check_lock {
+    return unless @Missing or @_;
+
+    my $cpan_env = $ENV{PERL5_CPAN_IS_RUNNING};
+
+    if ($ENV{PERL5_CPANPLUS_IS_RUNNING}) {
+        return _running_under($cpan_env ? 'CPAN' : 'CPANPLUS');
+    }
+
+    require CPAN;
+
+    if ($CPAN::VERSION > '1.89') {
+        if ($cpan_env) {
+            return _running_under('CPAN');
+        }
+        return; # CPAN.pm new enough, don't need to check further
+    }
+
+    # last ditch attempt, this -will- configure CPAN, very sorry
+
+    _load_cpan(1); # force initialize even though it's already loaded
+
+    # Find the CPAN lock-file
+    my $lock = MM->catfile( $CPAN::Config->{cpan_home}, ".lock" );
+    return unless -f $lock;
+
+    # Check the lock
+    local *LOCK;
+    return unless open(LOCK, $lock);
+
+    if (
+            ( $^O eq 'MSWin32' ? _under_cpan() : <LOCK> == getppid() )
+        and ( $CPAN::Config->{prerequisites_policy} || '' ) ne 'ignore'
+    ) {
+        print <<'END_MESSAGE';
+
+*** Since we're running under CPAN, I'll just let it take care
+    of the dependency's installation later.
+END_MESSAGE
+        return 1;
+    }
+
+    close LOCK;
+    return;
+}
+
+sub install {
+    my $class = shift;
+
+    my $i;    # used below to strip leading '-' from config keys
+    my @config = ( map { s/^-// if ++$i; $_ } @{ +shift } );
+
+    my ( @modules, @installed );
+    while ( my ( $pkg, $ver ) = splice( @_, 0, 2 ) ) {
+
+        # grep out those already installed
+        if ( _version_cmp( _load($pkg), $ver ) >= 0 ) {
+            push @installed, $pkg;
+        }
+        else {
+            push @modules, $pkg, $ver;
+        }
+    }
+
+    return @installed unless @modules;  # nothing to do
+    return @installed if _check_lock(); # defer to the CPAN shell
+
+    print "*** Installing dependencies...\n";
+
+    return unless _connected_to('cpan.org');
+
+    my %args = @config;
+    my %failed;
+    local *FAILED;
+    if ( $args{do_once} and open( FAILED, '.#autoinstall.failed' ) ) {
+        while (<FAILED>) { chomp; $failed{$_}++ }
+        close FAILED;
+
+        my @newmod;
+        while ( my ( $k, $v ) = splice( @modules, 0, 2 ) ) {
+            push @newmod, ( $k => $v ) unless $failed{$k};
+        }
+        @modules = @newmod;
+    }
+
+    if ( _has_cpanplus() and not $ENV{PERL_AUTOINSTALL_PREFER_CPAN} ) {
+        _install_cpanplus( \@modules, \@config );
+    } else {
+        _install_cpan( \@modules, \@config );
+    }
+
+    print "*** $class installation finished.\n";
+
+    # see if we have successfully installed them
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        if ( _version_cmp( _load($pkg), $ver ) >= 0 ) {
+            push @installed, $pkg;
+        }
+        elsif ( $args{do_once} and open( FAILED, '>> .#autoinstall.failed' ) ) {
+            print FAILED "$pkg\n";
+        }
+    }
+
+    close FAILED if $args{do_once};
+
+    return @installed;
+}
+
+sub _install_cpanplus {
+    my @modules   = @{ +shift };
+    my @config    = _cpanplus_config( @{ +shift } );
+    my $installed = 0;
+
+    require CPANPLUS::Backend;
+    my $cp   = CPANPLUS::Backend->new;
+    my $conf = $cp->configure_object;
+
+    return unless $conf->can('conf') # 0.05x+ with "sudo" support
+               or _can_write($conf->_get_build('base'));  # 0.04x
+
+    # if we're root, set UNINST=1 to avoid trouble unless user asked for it.
+    my $makeflags = $conf->get_conf('makeflags') || '';
+    if ( UNIVERSAL::isa( $makeflags, 'HASH' ) ) {
+        # 0.03+ uses a hashref here
+        $makeflags->{UNINST} = 1 unless exists $makeflags->{UNINST};
+
+    } else {
+        # 0.02 and below uses a scalar
+        $makeflags = join( ' ', split( ' ', $makeflags ), 'UNINST=1' )
+          if ( $makeflags !~ /\bUNINST\b/ and eval qq{ $> eq '0' } );
+
+    }
+    $conf->set_conf( makeflags => $makeflags );
+    $conf->set_conf( prereqs   => 1 );
+
+
+
+    while ( my ( $key, $val ) = splice( @config, 0, 2 ) ) {
+        $conf->set_conf( $key, $val );
+    }
+
+    my $modtree = $cp->module_tree;
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        print "*** Installing $pkg...\n";
+
+        MY::preinstall( $pkg, $ver ) or next if defined &MY::preinstall;
+
+        my $success;
+        my $obj = $modtree->{$pkg};
+
+        if ( $obj and _version_cmp( $obj->{version}, $ver ) >= 0 ) {
+            my $pathname = $pkg;
+            $pathname =~ s/::/\\W/;
+
+            foreach my $inc ( grep { m/$pathname.pm/i } keys(%INC) ) {
+                delete $INC{$inc};
+            }
+
+            my $rv = $cp->install( modules => [ $obj->{module} ] );
+
+            if ( $rv and ( $rv->{ $obj->{module} } or $rv->{ok} ) ) {
+                print "*** $pkg successfully installed.\n";
+                $success = 1;
+            } else {
+                print "*** $pkg installation cancelled.\n";
+                $success = 0;
+            }
+
+            $installed += $success;
+        } else {
+            print << ".";
+*** Could not find a version $ver or above for $pkg; skipping.
+.
+        }
+
+        MY::postinstall( $pkg, $ver, $success ) if defined &MY::postinstall;
+    }
+
+    return $installed;
+}
+
+sub _cpanplus_config {
+	my @config = ();
+	while ( @_ ) {
+		my ($key, $value) = (shift(), shift());
+		if ( $key eq 'prerequisites_policy' ) {
+			if ( $value eq 'follow' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_INSTALL();
+			} elsif ( $value eq 'ask' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_ASK();
+			} elsif ( $value eq 'ignore' ) {
+				$value = CPANPLUS::Internals::Constants::PREREQ_IGNORE();
+			} else {
+				die "*** Cannot convert option $key = '$value' to CPANPLUS version.\n";
+			}
+		} else {
+			die "*** Cannot convert option $key to CPANPLUS version.\n";
+		}
+	}
+	return @config;
+}
+
+sub _install_cpan {
+    my @modules   = @{ +shift };
+    my @config    = @{ +shift };
+    my $installed = 0;
+    my %args;
+
+    _load_cpan();
+    require Config;
+
+    if (CPAN->VERSION < 1.80) {
+        # no "sudo" support, probe for writableness
+        return unless _can_write( MM->catfile( $CPAN::Config->{cpan_home}, 'sources' ) )
+                  and _can_write( $Config::Config{sitelib} );
+    }
+
+    # if we're root, set UNINST=1 to avoid trouble unless user asked for it.
+    my $makeflags = $CPAN::Config->{make_install_arg} || '';
+    $CPAN::Config->{make_install_arg} =
+      join( ' ', split( ' ', $makeflags ), 'UNINST=1' )
+      if ( $makeflags !~ /\bUNINST\b/ and eval qq{ $> eq '0' } );
+
+    # don't show start-up info
+    $CPAN::Config->{inhibit_startup_message} = 1;
+
+    # set additional options
+    while ( my ( $opt, $arg ) = splice( @config, 0, 2 ) ) {
+        ( $args{$opt} = $arg, next )
+          if $opt =~ /^force$/;    # pseudo-option
+        $CPAN::Config->{$opt} = $arg;
+    }
+
+    local $CPAN::Config->{prerequisites_policy} = 'follow';
+
+    while ( my ( $pkg, $ver ) = splice( @modules, 0, 2 ) ) {
+        MY::preinstall( $pkg, $ver ) or next if defined &MY::preinstall;
+
+        print "*** Installing $pkg...\n";
+
+        my $obj     = CPAN::Shell->expand( Module => $pkg );
+        my $success = 0;
+
+        if ( $obj and _version_cmp( $obj->cpan_version, $ver ) >= 0 ) {
+            my $pathname = $pkg;
+            $pathname =~ s/::/\\W/;
+
+            foreach my $inc ( grep { m/$pathname.pm/i } keys(%INC) ) {
+                delete $INC{$inc};
+            }
+
+            my $rv = $args{force} ? CPAN::Shell->force( install => $pkg )
+                                  : CPAN::Shell->install($pkg);
+            $rv ||= eval {
+                $CPAN::META->instance( 'CPAN::Distribution', $obj->cpan_file, )
+                  ->{install}
+                  if $CPAN::META;
+            };
+
+            if ( $rv eq 'YES' ) {
+                print "*** $pkg successfully installed.\n";
+                $success = 1;
+            }
+            else {
+                print "*** $pkg installation failed.\n";
+                $success = 0;
+            }
+
+            $installed += $success;
+        }
+        else {
+            print << ".";
+*** Could not find a version $ver or above for $pkg; skipping.
+.
+        }
+
+        MY::postinstall( $pkg, $ver, $success ) if defined &MY::postinstall;
+    }
+
+    return $installed;
+}
+
+sub _has_cpanplus {
+    return (
+        $HasCPANPLUS = (
+            $INC{'CPANPLUS/Config.pm'}
+              or _load('CPANPLUS::Shell::Default')
+        )
+    );
+}
+
+# make guesses on whether we're under the CPAN installation directory
+sub _under_cpan {
+    require Cwd;
+    require File::Spec;
+
+    my $cwd  = File::Spec->canonpath( Cwd::cwd() );
+    my $cpan = File::Spec->canonpath( $CPAN::Config->{cpan_home} );
+
+    return ( index( $cwd, $cpan ) > -1 );
+}
+
+sub _update_to {
+    my $class = __PACKAGE__;
+    my $ver   = shift;
+
+    return
+      if _version_cmp( _load($class), $ver ) >= 0;  # no need to upgrade
+
+    if (
+        _prompt( "==> A newer version of $class ($ver) is required. Install?",
+            'y' ) =~ /^[Nn]/
+      )
+    {
+        die "*** Please install $class $ver manually.\n";
+    }
+
+    print << ".";
+*** Trying to fetch it from CPAN...
+.
+
+    # install ourselves
+    _load($class) and return $class->import(@_)
+      if $class->install( [], $class, $ver );
+
+    print << '.'; exit 1;
+
+*** Cannot bootstrap myself. :-( Installation terminated.
+.
+}
+
+# check if we're connected to some host, using inet_aton
+sub _connected_to {
+    my $site = shift;
+
+    return (
+        ( _load('Socket') and Socket::inet_aton($site) ) or _prompt(
+            qq(
+*** Your host cannot resolve the domain name '$site', which
+    probably means the Internet connections are unavailable.
+==> Should we try to install the required module(s) anyway?), 'n'
+          ) =~ /^[Yy]/
+    );
+}
+
+# check if a directory is writable; may create it on demand
+sub _can_write {
+    my $path = shift;
+    mkdir( $path, 0755 ) unless -e $path;
+
+    return 1 if -w $path;
+
+    print << ".";
+*** You are not allowed to write to the directory '$path';
+    the installation may fail due to insufficient permissions.
+.
+
+    if (
+        eval '$>' and lc(`sudo -V`) =~ /version/ and _prompt(
+            qq(
+==> Should we try to re-execute the autoinstall process with 'sudo'?),
+            ((-t STDIN) ? 'y' : 'n')
+        ) =~ /^[Yy]/
+      )
+    {
+
+        # try to bootstrap ourselves from sudo
+        print << ".";
+*** Trying to re-execute the autoinstall process with 'sudo'...
+.
+        my $missing = join( ',', @Missing );
+        my $config = join( ',',
+            UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+          if $Config;
+
+        return
+          unless system( 'sudo', $^X, $0, "--config=$config",
+            "--installdeps=$missing" );
+
+        print << ".";
+*** The 'sudo' command exited with error!  Resuming...
+.
+    }
+
+    return _prompt(
+        qq(
+==> Should we try to install the required module(s) anyway?), 'n'
+    ) =~ /^[Yy]/;
+}
+
+# load a module and return the version it reports
+sub _load {
+    my $mod  = pop;    # class/instance doesn't matter
+    my $file = $mod;
+
+    $file =~ s|::|/|g;
+    $file .= '.pm';
+
+    local $@;
+    return eval { require $file; $mod->VERSION } || ( $@ ? undef: 0 );
+}
+
+# Load CPAN.pm and it's configuration
+sub _load_cpan {
+    return if $CPAN::VERSION and $CPAN::Config and not @_;
+    require CPAN;
+
+    # CPAN-1.82+ adds CPAN::Config::AUTOLOAD to redirect to
+    #    CPAN::HandleConfig->load. CPAN reports that the redirection
+    #    is deprecated in a warning printed at the user.
+
+    # CPAN-1.81 expects CPAN::HandleConfig->load, does not have
+    #   $CPAN::HandleConfig::VERSION but cannot handle
+    #   CPAN::Config->load
+
+    # Which "versions expect CPAN::Config->load?
+
+    if ( $CPAN::HandleConfig::VERSION
+        || CPAN::HandleConfig->can('load')
+    ) {
+        # Newer versions of CPAN have a HandleConfig module
+        CPAN::HandleConfig->load;
+    } else {
+    	# Older versions had the load method in Config directly
+        CPAN::Config->load;
+    }
+}
+
+# compare two versions, either use Sort::Versions or plain comparison
+# return values same as <=>
+sub _version_cmp {
+    my ( $cur, $min ) = @_;
+    return -1 unless defined $cur;  # if 0 keep comparing
+    return 1 unless $min;
+
+    $cur =~ s/\s+$//;
+
+    # check for version numbers that are not in decimal format
+    if ( ref($cur) or ref($min) or $cur =~ /v|\..*\./ or $min =~ /v|\..*\./ ) {
+        if ( ( $version::VERSION or defined( _load('version') )) and
+             version->can('new')
+            ) {
+
+            # use version.pm if it is installed.
+            return version->new($cur) <=> version->new($min);
+        }
+        elsif ( $Sort::Versions::VERSION or defined( _load('Sort::Versions') ) )
+        {
+
+            # use Sort::Versions as the sorting algorithm for a.b.c versions
+            return Sort::Versions::versioncmp( $cur, $min );
+        }
+
+        warn "Cannot reliably compare non-decimal formatted versions.\n"
+          . "Please install version.pm or Sort::Versions.\n";
+    }
+
+    # plain comparison
+    local $^W = 0;    # shuts off 'not numeric' bugs
+    return $cur <=> $min;
+}
+
+# nothing; this usage is deprecated.
+sub main::PREREQ_PM { return {}; }
+
+sub _make_args {
+    my %args = @_;
+
+    $args{PREREQ_PM} = { %{ $args{PREREQ_PM} || {} }, @Existing, @Missing }
+      if $UnderCPAN or $TestOnly;
+
+    if ( $args{EXE_FILES} and -e 'MANIFEST' ) {
+        require ExtUtils::Manifest;
+        my $manifest = ExtUtils::Manifest::maniread('MANIFEST');
+
+        $args{EXE_FILES} =
+          [ grep { exists $manifest->{$_} } @{ $args{EXE_FILES} } ];
+    }
+
+    $args{test}{TESTS} ||= 't/*.t';
+    $args{test}{TESTS} = join( ' ',
+        grep { !exists( $DisabledTests{$_} ) }
+          map { glob($_) } split( /\s+/, $args{test}{TESTS} ) );
+
+    my $missing = join( ',', @Missing );
+    my $config =
+      join( ',', UNIVERSAL::isa( $Config, 'HASH' ) ? %{$Config} : @{$Config} )
+      if $Config;
+
+    $PostambleActions = (
+        ($missing and not $UnderCPAN)
+        ? "\$(PERL) $0 --config=$config --installdeps=$missing"
+        : "\$(NOECHO) \$(NOOP)"
+    );
+
+    return %args;
+}
+
+# a wrapper to ExtUtils::MakeMaker::WriteMakefile
+sub Write {
+    require Carp;
+    Carp::croak "WriteMakefile: Need even number of args" if @_ % 2;
+
+    if ($CheckOnly) {
+        print << ".";
+*** Makefile not written in check-only mode.
+.
+        return;
+    }
+
+    my %args = _make_args(@_);
+
+    no strict 'refs';
+
+    $PostambleUsed = 0;
+    local *MY::postamble = \&postamble unless defined &MY::postamble;
+    ExtUtils::MakeMaker::WriteMakefile(%args);
+
+    print << "." unless $PostambleUsed;
+*** WARNING: Makefile written with customized MY::postamble() without
+    including contents from Module::AutoInstall::postamble() --
+    auto installation features disabled.  Please contact the author.
+.
+
+    return 1;
+}
+
+sub postamble {
+    $PostambleUsed = 1;
+
+    return <<"END_MAKE";
+
+config :: installdeps
+\t\$(NOECHO) \$(NOOP)
+
+checkdeps ::
+\t\$(PERL) $0 --checkdeps
+
+installdeps ::
+\t$PostambleActions
+
+END_MAKE
+
+}
+
+1;
+
+__END__
+
+#line 1071
Index: 0.8/modules/nginx-echo/test/inc/Module/Install.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Module/Install.pm	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,466 @@
+#line 1
+package Module::Install;
+
+# For any maintainers:
+# The load order for Module::Install is a bit magic.
+# It goes something like this...
+#
+# IF ( host has Module::Install installed, creating author mode ) {
+#     1. Makefile.PL calls "use inc::Module::Install"
+#     2. $INC{inc/Module/Install.pm} set to installed version of inc::Module::Install
+#     3. The installed version of inc::Module::Install loads
+#     4. inc::Module::Install calls "require Module::Install"
+#     5. The ./inc/ version of Module::Install loads
+# } ELSE {
+#     1. Makefile.PL calls "use inc::Module::Install"
+#     2. $INC{inc/Module/Install.pm} set to ./inc/ version of Module::Install
+#     3. The ./inc/ version of Module::Install loads
+# }
+
+use 5.005;
+use strict 'vars';
+use Cwd        ();
+use File::Find ();
+use File::Path ();
+
+use vars qw{$VERSION $MAIN};
+BEGIN {
+	# All Module::Install core packages now require synchronised versions.
+	# This will be used to ensure we don't accidentally load old or
+	# different versions of modules.
+	# This is not enforced yet, but will be some time in the next few
+	# releases once we can make sure it won't clash with custom
+	# Module::Install extensions.
+	$VERSION = '0.99';
+
+	# Storage for the pseudo-singleton
+	$MAIN    = undef;
+
+	*inc::Module::Install::VERSION = *VERSION;
+	@inc::Module::Install::ISA     = __PACKAGE__;
+
+}
+
+sub import {
+	my $class = shift;
+	my $self  = $class->new(@_);
+	my $who   = $self->_caller;
+
+	#-------------------------------------------------------------
+	# all of the following checks should be included in import(),
+	# to allow "eval 'require Module::Install; 1' to test
+	# installation of Module::Install. (RT #51267)
+	#-------------------------------------------------------------
+
+	# Whether or not inc::Module::Install is actually loaded, the
+	# $INC{inc/Module/Install.pm} is what will still get set as long as
+	# the caller loaded module this in the documented manner.
+	# If not set, the caller may NOT have loaded the bundled version, and thus
+	# they may not have a MI version that works with the Makefile.PL. This would
+	# result in false errors or unexpected behaviour. And we don't want that.
+	my $file = join( '/', 'inc', split /::/, __PACKAGE__ ) . '.pm';
+	unless ( $INC{$file} ) { die <<"END_DIE" }
+
+Please invoke ${\__PACKAGE__} with:
+
+	use inc::${\__PACKAGE__};
+
+not:
+
+	use ${\__PACKAGE__};
+
+END_DIE
+
+	# This reportedly fixes a rare Win32 UTC file time issue, but
+	# as this is a non-cross-platform XS module not in the core,
+	# we shouldn't really depend on it. See RT #24194 for detail.
+	# (Also, this module only supports Perl 5.6 and above).
+	eval "use Win32::UTCFileTime" if $^O eq 'MSWin32' && $] >= 5.006;
+
+	# If the script that is loading Module::Install is from the future,
+	# then make will detect this and cause it to re-run over and over
+	# again. This is bad. Rather than taking action to touch it (which
+	# is unreliable on some platforms and requires write permissions)
+	# for now we should catch this and refuse to run.
+	if ( -f $0 ) {
+		my $s = (stat($0))[9];
+
+		# If the modification time is only slightly in the future,
+		# sleep briefly to remove the problem.
+		my $a = $s - time;
+		if ( $a > 0 and $a < 5 ) { sleep 5 }
+
+		# Too far in the future, throw an error.
+		my $t = time;
+		if ( $s > $t ) { die <<"END_DIE" }
+
+Your installer $0 has a modification time in the future ($s > $t).
+
+This is known to create infinite loops in make.
+
+Please correct this, then run $0 again.
+
+END_DIE
+	}
+
+
+	# Build.PL was formerly supported, but no longer is due to excessive
+	# difficulty in implementing every single feature twice.
+	if ( $0 =~ /Build.PL$/i ) { die <<"END_DIE" }
+
+Module::Install no longer supports Build.PL.
+
+It was impossible to maintain duel backends, and has been deprecated.
+
+Please remove all Build.PL files and only use the Makefile.PL installer.
+
+END_DIE
+
+	#-------------------------------------------------------------
+
+	# To save some more typing in Module::Install installers, every...
+	# use inc::Module::Install
+	# ...also acts as an implicit use strict.
+	$^H |= strict::bits(qw(refs subs vars));
+
+	#-------------------------------------------------------------
+
+	unless ( -f $self->{file} ) {
+		foreach my $key (keys %INC) {
+			delete $INC{$key} if $key =~ /Module\/Install/;
+		}
+
+		local $^W;
+		require "$self->{path}/$self->{dispatch}.pm";
+		File::Path::mkpath("$self->{prefix}/$self->{author}");
+		$self->{admin} = "$self->{name}::$self->{dispatch}"->new( _top => $self );
+		$self->{admin}->init;
+		@_ = ($class, _self => $self);
+		goto &{"$self->{name}::import"};
+	}
+
+	local $^W;
+	*{"${who}::AUTOLOAD"} = $self->autoload;
+	$self->preload;
+
+	# Unregister loader and worker packages so subdirs can use them again
+	delete $INC{'inc/Module/Install.pm'};
+	delete $INC{'Module/Install.pm'};
+
+	# Save to the singleton
+	$MAIN = $self;
+
+	return 1;
+}
+
+sub autoload {
+	my $self = shift;
+	my $who  = $self->_caller;
+	my $cwd  = Cwd::cwd();
+	my $sym  = "${who}::AUTOLOAD";
+	$sym->{$cwd} = sub {
+		my $pwd = Cwd::cwd();
+		if ( my $code = $sym->{$pwd} ) {
+			# Delegate back to parent dirs
+			goto &$code unless $cwd eq $pwd;
+		}
+		unless ($$sym =~ s/([^:]+)$//) {
+			# XXX: it looks like we can't retrieve the missing function
+			# via $$sym (usually $main::AUTOLOAD) in this case.
+			# I'm still wondering if we should slurp Makefile.PL to
+			# get some context or not ...
+			my ($package, $file, $line) = caller;
+			die <<"EOT";
+Unknown function is found at $file line $line.
+Execution of $file aborted due to runtime errors.
+
+If you're a contributor to a project, you may need to install
+some Module::Install extensions from CPAN (or other repository).
+If you're a user of a module, please contact the author.
+EOT
+		}
+		my $method = $1;
+		if ( uc($method) eq $method ) {
+			# Do nothing
+			return;
+		} elsif ( $method =~ /^_/ and $self->can($method) ) {
+			# Dispatch to the root M:I class
+			return $self->$method(@_);
+		}
+
+		# Dispatch to the appropriate plugin
+		unshift @_, ( $self, $1 );
+		goto &{$self->can('call')};
+	};
+}
+
+sub preload {
+	my $self = shift;
+	unless ( $self->{extensions} ) {
+		$self->load_extensions(
+			"$self->{prefix}/$self->{path}", $self
+		);
+	}
+
+	my @exts = @{$self->{extensions}};
+	unless ( @exts ) {
+		@exts = $self->{admin}->load_all_extensions;
+	}
+
+	my %seen;
+	foreach my $obj ( @exts ) {
+		while (my ($method, $glob) = each %{ref($obj) . '::'}) {
+			next unless $obj->can($method);
+			next if $method =~ /^_/;
+			next if $method eq uc($method);
+			$seen{$method}++;
+		}
+	}
+
+	my $who = $self->_caller;
+	foreach my $name ( sort keys %seen ) {
+		local $^W;
+		*{"${who}::$name"} = sub {
+			${"${who}::AUTOLOAD"} = "${who}::$name";
+			goto &{"${who}::AUTOLOAD"};
+		};
+	}
+}
+
+sub new {
+	my ($class, %args) = @_;
+
+    delete $INC{'FindBin.pm'};
+    require FindBin;
+
+	# ignore the prefix on extension modules built from top level.
+	my $base_path = Cwd::abs_path($FindBin::Bin);
+	unless ( Cwd::abs_path(Cwd::cwd()) eq $base_path ) {
+		delete $args{prefix};
+	}
+	return $args{_self} if $args{_self};
+
+	$args{dispatch} ||= 'Admin';
+	$args{prefix}   ||= 'inc';
+	$args{author}   ||= ($^O eq 'VMS' ? '_author' : '.author');
+	$args{bundle}   ||= 'inc/BUNDLES';
+	$args{base}     ||= $base_path;
+	$class =~ s/^\Q$args{prefix}\E:://;
+	$args{name}     ||= $class;
+	$args{version}  ||= $class->VERSION;
+	unless ( $args{path} ) {
+		$args{path}  = $args{name};
+		$args{path}  =~ s!::!/!g;
+	}
+	$args{file}     ||= "$args{base}/$args{prefix}/$args{path}.pm";
+	$args{wrote}      = 0;
+
+	bless( \%args, $class );
+}
+
+sub call {
+	my ($self, $method) = @_;
+	my $obj = $self->load($method) or return;
+        splice(@_, 0, 2, $obj);
+	goto &{$obj->can($method)};
+}
+
+sub load {
+	my ($self, $method) = @_;
+
+	$self->load_extensions(
+		"$self->{prefix}/$self->{path}", $self
+	) unless $self->{extensions};
+
+	foreach my $obj (@{$self->{extensions}}) {
+		return $obj if $obj->can($method);
+	}
+
+	my $admin = $self->{admin} or die <<"END_DIE";
+The '$method' method does not exist in the '$self->{prefix}' path!
+Please remove the '$self->{prefix}' directory and run $0 again to load it.
+END_DIE
+
+	my $obj = $admin->load($method, 1);
+	push @{$self->{extensions}}, $obj;
+
+	$obj;
+}
+
+sub load_extensions {
+	my ($self, $path, $top) = @_;
+
+	my $should_reload = 0;
+	unless ( grep { ! ref $_ and lc $_ eq lc $self->{prefix} } @INC ) {
+		unshift @INC, $self->{prefix};
+		$should_reload = 1;
+	}
+
+	foreach my $rv ( $self->find_extensions($path) ) {
+		my ($file, $pkg) = @{$rv};
+		next if $self->{pathnames}{$pkg};
+
+		local $@;
+		my $new = eval { local $^W; require $file; $pkg->can('new') };
+		unless ( $new ) {
+			warn $@ if $@;
+			next;
+		}
+		$self->{pathnames}{$pkg} =
+			$should_reload ? delete $INC{$file} : $INC{$file};
+		push @{$self->{extensions}}, &{$new}($pkg, _top => $top );
+	}
+
+	$self->{extensions} ||= [];
+}
+
+sub find_extensions {
+	my ($self, $path) = @_;
+
+	my @found;
+	File::Find::find( sub {
+		my $file = $File::Find::name;
+		return unless $file =~ m!^\Q$path\E/(.+)\.pm\Z!is;
+		my $subpath = $1;
+		return if lc($subpath) eq lc($self->{dispatch});
+
+		$file = "$self->{path}/$subpath.pm";
+		my $pkg = "$self->{name}::$subpath";
+		$pkg =~ s!/!::!g;
+
+		# If we have a mixed-case package name, assume case has been preserved
+		# correctly.  Otherwise, root through the file to locate the case-preserved
+		# version of the package name.
+		if ( $subpath eq lc($subpath) || $subpath eq uc($subpath) ) {
+			my $content = Module::Install::_read($subpath . '.pm');
+			my $in_pod  = 0;
+			foreach ( split //, $content ) {
+				$in_pod = 1 if /^=\w/;
+				$in_pod = 0 if /^=cut/;
+				next if ($in_pod || /^=cut/);  # skip pod text
+				next if /^\s*#/;               # and comments
+				if ( m/^\s*package\s+($pkg)\s*;/i ) {
+					$pkg = $1;
+					last;
+				}
+			}
+		}
+
+		push @found, [ $file, $pkg ];
+	}, $path ) if -d $path;
+
+	@found;
+}
+
+
+
+
+
+#####################################################################
+# Common Utility Functions
+
+sub _caller {
+	my $depth = 0;
+	my $call  = caller($depth);
+	while ( $call eq __PACKAGE__ ) {
+		$depth++;
+		$call = caller($depth);
+	}
+	return $call;
+}
+
+# Done in evals to avoid confusing Perl::MinimumVersion
+eval( $] >= 5.006 ? <<'END_NEW' : <<'END_OLD' ); die $@ if $@;
+sub _read {
+	local *FH;
+	open( FH, '<', $_[0] ) or die "open($_[0]): $!";
+	my $string = do { local $/; <FH> };
+	close FH or die "close($_[0]): $!";
+	return $string;
+}
+END_NEW
+sub _read {
+	local *FH;
+	open( FH, "< $_[0]"  ) or die "open($_[0]): $!";
+	my $string = do { local $/; <FH> };
+	close FH or die "close($_[0]): $!";
+	return $string;
+}
+END_OLD
+
+sub _readperl {
+	my $string = Module::Install::_read($_[0]);
+	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
+	$string =~ s/(\n)\n*__(?:DATA|END)__\b.*\z/$1/s;
+	$string =~ s/\n\n=\w+.+?\n\n=cut\b.+?\n+/\n\n/sg;
+	return $string;
+}
+
+sub _readpod {
+	my $string = Module::Install::_read($_[0]);
+	$string =~ s/(?:\015{1,2}\012|\015|\012)/\n/sg;
+	return $string if $_[0] =~ /\.pod\z/;
+	$string =~ s/(^|\n=cut\b.+?\n+)[^=\s].+?\n(\n=\w+|\z)/$1$2/sg;
+	$string =~ s/\n*=pod\b[^\n]*\n+/\n\n/sg;
+	$string =~ s/\n*=cut\b[^\n]*\n+/\n\n/sg;
+	$string =~ s/^\n+//s;
+	return $string;
+}
+
+# Done in evals to avoid confusing Perl::MinimumVersion
+eval( $] >= 5.006 ? <<'END_NEW' : <<'END_OLD' ); die $@ if $@;
+sub _write {
+	local *FH;
+	open( FH, '>', $_[0] ) or die "open($_[0]): $!";
+	foreach ( 1 .. $#_ ) {
+		print FH $_[$_] or die "print($_[0]): $!";
+	}
+	close FH or die "close($_[0]): $!";
+}
+END_NEW
+sub _write {
+	local *FH;
+	open( FH, "> $_[0]"  ) or die "open($_[0]): $!";
+	foreach ( 1 .. $#_ ) {
+		print FH $_[$_] or die "print($_[0]): $!";
+	}
+	close FH or die "close($_[0]): $!";
+}
+END_OLD
+
+# _version is for processing module versions (eg, 1.03_05) not
+# Perl versions (eg, 5.8.1).
+sub _version ($) {
+	my $s = shift || 0;
+	my $d =()= $s =~ /(\.)/g;
+	if ( $d >= 2 ) {
+		# Normalise multipart versions
+		$s =~ s/(\.)(\d{1,3})/sprintf("$1%03d",$2)/eg;
+	}
+	$s =~ s/^(\d+)\.?//;
+	my $l = $1 || 0;
+	my @v = map {
+		$_ . '0' x (3 - length $_)
+	} $s =~ /(\d{1,3})\D?/g;
+	$l = $l . '.' . join '', @v if @v;
+	return $l + 0;
+}
+
+sub _cmp ($$) {
+	_version($_[0]) <=> _version($_[1]);
+}
+
+# Cloned from Params::Util::_CLASS
+sub _CLASS ($) {
+	(
+		defined $_[0]
+		and
+		! ref $_[0]
+		and
+		$_[0] =~ m/^[^\W\d]\w*(?:::\w+)*\z/s
+	) ? $_[0] : undef;
+}
+
+1;
+
+# Copyright 2008 - 2010 Adam Kennedy.
Index: 0.8/modules/nginx-echo/test/inc/Spiffy.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Spiffy.pm	2010-10-31 07:35:47.698338000 +0000
@@ -0,0 +1,539 @@
+#line 1
+package Spiffy;
+use strict;
+use 5.006001;
+use warnings;
+use Carp;
+require Exporter;
+our $VERSION = '0.30';
+our @EXPORT = ();
+our @EXPORT_BASE = qw(field const stub super);
+our @EXPORT_OK = (@EXPORT_BASE, qw(id WWW XXX YYY ZZZ));
+our %EXPORT_TAGS = (XXX => [qw(WWW XXX YYY ZZZ)]);
+
+my $stack_frame = 0;
+my $dump = 'yaml';
+my $bases_map = {};
+
+sub WWW; sub XXX; sub YYY; sub ZZZ;
+
+# This line is here to convince "autouse" into believing we are autousable.
+sub can {
+    ($_[1] eq 'import' and caller()->isa('autouse'))
+        ? \&Exporter::import        # pacify autouse's equality test
+        : $_[0]->SUPER::can($_[1])  # normal case
+}
+
+# TODO
+#
+# Exported functions like field and super should be hidden so as not to
+# be confused with methods that can be inherited.
+#
+
+sub new {
+    my $class = shift;
+    $class = ref($class) || $class;
+    my $self = bless {}, $class;
+    while (@_) {
+        my $method = shift;
+        $self->$method(shift);
+    }
+    return $self;
+}
+
+my $filtered_files = {};
+my $filter_dump = 0;
+my $filter_save = 0;
+our $filter_result = '';
+sub import {
+    no strict 'refs';
+    no warnings;
+    my $self_package = shift;
+
+    # XXX Using parse_arguments here might cause confusion, because the
+    # subclass's boolean_arguments and paired_arguments can conflict, causing
+    # difficult debugging. Consider using something truly local.
+    my ($args, @export_list) = do {
+        local *boolean_arguments = sub {
+            qw(
+                -base -Base -mixin -selfless
+                -XXX -dumper -yaml
+                -filter_dump -filter_save
+            )
+        };
+        local *paired_arguments = sub { qw(-package) };
+        $self_package->parse_arguments(@_);
+    };
+    return spiffy_mixin_import(scalar(caller(0)), $self_package, @export_list)
+      if $args->{-mixin};
+
+    $filter_dump = 1 if $args->{-filter_dump};
+    $filter_save = 1 if $args->{-filter_save};
+    $dump = 'yaml' if $args->{-yaml};
+    $dump = 'dumper' if $args->{-dumper};
+
+    local @EXPORT_BASE = @EXPORT_BASE;
+
+    if ($args->{-XXX}) {
+        push @EXPORT_BASE, @{$EXPORT_TAGS{XXX}}
+          unless grep /^XXX$/, @EXPORT_BASE;
+    }
+
+    spiffy_filter()
+      if ($args->{-selfless} or $args->{-Base}) and
+         not $filtered_files->{(caller($stack_frame))[1]}++;
+
+    my $caller_package = $args->{-package} || caller($stack_frame);
+    push @{"$caller_package\::ISA"}, $self_package
+      if $args->{-Base} or $args->{-base};
+
+    for my $class (@{all_my_bases($self_package)}) {
+        next unless $class->isa('Spiffy');
+        my @export = grep {
+            not defined &{"$caller_package\::$_"};
+        } ( @{"$class\::EXPORT"},
+            ($args->{-Base} or $args->{-base})
+              ? @{"$class\::EXPORT_BASE"} : (),
+          );
+        my @export_ok = grep {
+            not defined &{"$caller_package\::$_"};
+        } @{"$class\::EXPORT_OK"};
+
+        # Avoid calling the expensive Exporter::export
+        # if there is nothing to do (optimization)
+        my %exportable = map { ($_, 1) } @export, @export_ok;
+        next unless keys %exportable;
+
+        my @export_save = @{"$class\::EXPORT"};
+        my @export_ok_save = @{"$class\::EXPORT_OK"};
+        @{"$class\::EXPORT"} = @export;
+        @{"$class\::EXPORT_OK"} = @export_ok;
+        my @list = grep {
+            (my $v = $_) =~ s/^[\!\:]//;
+            $exportable{$v} or ${"$class\::EXPORT_TAGS"}{$v};
+        } @export_list;
+        Exporter::export($class, $caller_package, @list);
+        @{"$class\::EXPORT"} = @export_save;
+        @{"$class\::EXPORT_OK"} = @export_ok_save;
+    }
+}
+
+sub spiffy_filter {
+    require Filter::Util::Call;
+    my $done = 0;
+    Filter::Util::Call::filter_add(
+        sub {
+            return 0 if $done;
+            my ($data, $end) = ('', '');
+            while (my $status = Filter::Util::Call::filter_read()) {
+                return $status if $status < 0;
+                if (/^__(?:END|DATA)__\r?$/) {
+                    $end = $_;
+                    last;
+                }
+                $data .= $_;
+                $_ = '';
+            }
+            $_ = $data;
+            my @my_subs;
+            s[^(sub\s+\w+\s+\{)(.*\n)]
+             [${1}my \$self = shift;$2]gm;
+            s[^(sub\s+\w+)\s*\(\s*\)(\s+\{.*\n)]
+             [${1}${2}]gm;
+            s[^my\s+sub\s+(\w+)(\s+\{)(.*)((?s:.*?\n))\}\n]
+             [push @my_subs, $1; "\$$1 = sub$2my \$self = shift;$3$4\};\n"]gem;
+            my $preclare = '';
+            if (@my_subs) {
+                $preclare = join ',', map "\$$_", @my_subs;
+                $preclare = "my($preclare);";
+            }
+            $_ = "use strict;use warnings;$preclare${_};1;\n$end";
+            if ($filter_dump) { print; exit }
+            if ($filter_save) { $filter_result = $_; $_ = $filter_result; }
+            $done = 1;
+        }
+    );
+}
+
+sub base {
+    push @_, -base;
+    goto &import;
+}
+
+sub all_my_bases {
+    my $class = shift;
+
+    return $bases_map->{$class}
+      if defined $bases_map->{$class};
+
+    my @bases = ($class);
+    no strict 'refs';
+    for my $base_class (@{"${class}::ISA"}) {
+        push @bases, @{all_my_bases($base_class)};
+    }
+    my $used = {};
+    $bases_map->{$class} = [grep {not $used->{$_}++} @bases];
+}
+
+my %code = (
+    sub_start =>
+      "sub {\n",
+    set_default =>
+      "  \$_[0]->{%s} = %s\n    unless exists \$_[0]->{%s};\n",
+    init =>
+      "  return \$_[0]->{%s} = do { my \$self = \$_[0]; %s }\n" .
+      "    unless \$#_ > 0 or defined \$_[0]->{%s};\n",
+    weak_init =>
+      "  return do {\n" .
+      "    \$_[0]->{%s} = do { my \$self = \$_[0]; %s };\n" .
+      "    Scalar::Util::weaken(\$_[0]->{%s}) if ref \$_[0]->{%s};\n" .
+      "    \$_[0]->{%s};\n" .
+      "  } unless \$#_ > 0 or defined \$_[0]->{%s};\n",
+    return_if_get =>
+      "  return \$_[0]->{%s} unless \$#_ > 0;\n",
+    set =>
+      "  \$_[0]->{%s} = \$_[1];\n",
+    weaken =>
+      "  Scalar::Util::weaken(\$_[0]->{%s}) if ref \$_[0]->{%s};\n",
+    sub_end =>
+      "  return \$_[0]->{%s};\n}\n",
+);
+
+sub field {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *boolean_arguments = sub { (qw(-weak)) };
+        local *paired_arguments = sub { (qw(-package -init)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    die "Cannot have a default for a weakened field ($field)"
+        if defined $default && $args->{-weak};
+    return if defined &{"${package}::$field"};
+    require Scalar::Util if $args->{-weak};
+    my $default_string =
+        ( ref($default) eq 'ARRAY' and not @$default )
+        ? '[]'
+        : (ref($default) eq 'HASH' and not keys %$default )
+          ? '{}'
+          : default_as_code($default);
+
+    my $code = $code{sub_start};
+    if ($args->{-init}) {
+        my $fragment = $args->{-weak} ? $code{weak_init} : $code{init};
+        $code .= sprintf $fragment, $field, $args->{-init}, ($field) x 4;
+    }
+    $code .= sprintf $code{set_default}, $field, $default_string, $field
+      if defined $default;
+    $code .= sprintf $code{return_if_get}, $field;
+    $code .= sprintf $code{set}, $field;
+    $code .= sprintf $code{weaken}, $field, $field
+      if $args->{-weak};
+    $code .= sprintf $code{sub_end}, $field;
+
+    my $sub = eval $code;
+    die $@ if $@;
+    no strict 'refs';
+    *{"${package}::$field"} = $sub;
+    return $code if defined wantarray;
+}
+
+sub default_as_code {
+    require Data::Dumper;
+    local $Data::Dumper::Sortkeys = 1;
+    my $code = Data::Dumper::Dumper(shift);
+    $code =~ s/^\$VAR1 = //;
+    $code =~ s/;$//;
+    return $code;
+}
+
+sub const {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *paired_arguments = sub { (qw(-package)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    no strict 'refs';
+    return if defined &{"${package}::$field"};
+    *{"${package}::$field"} = sub { $default }
+}
+
+sub stub {
+    my $package = caller;
+    my ($args, @values) = do {
+        no warnings;
+        local *paired_arguments = sub { (qw(-package)) };
+        Spiffy->parse_arguments(@_);
+    };
+    my ($field, $default) = @values;
+    $package = $args->{-package} if defined $args->{-package};
+    no strict 'refs';
+    return if defined &{"${package}::$field"};
+    *{"${package}::$field"} =
+    sub {
+        require Carp;
+        Carp::confess
+          "Method $field in package $package must be subclassed";
+    }
+}
+
+sub parse_arguments {
+    my $class = shift;
+    my ($args, @values) = ({}, ());
+    my %booleans = map { ($_, 1) } $class->boolean_arguments;
+    my %pairs = map { ($_, 1) } $class->paired_arguments;
+    while (@_) {
+        my $elem = shift;
+        if (defined $elem and defined $booleans{$elem}) {
+            $args->{$elem} = (@_ and $_[0] =~ /^[01]$/)
+            ? shift
+            : 1;
+        }
+        elsif (defined $elem and defined $pairs{$elem} and @_) {
+            $args->{$elem} = shift;
+        }
+        else {
+            push @values, $elem;
+        }
+    }
+    return wantarray ? ($args, @values) : $args;
+}
+
+sub boolean_arguments { () }
+sub paired_arguments { () }
+
+# get a unique id for any node
+sub id {
+    if (not ref $_[0]) {
+        return 'undef' if not defined $_[0];
+        \$_[0] =~ /\((\w+)\)$/o or die;
+        return "$1-S";
+    }
+    require overload;
+    overload::StrVal($_[0]) =~ /\((\w+)\)$/o or die;
+    return $1;
+}
+
+#===============================================================================
+# It's super, man.
+#===============================================================================
+package DB;
+{
+    no warnings 'redefine';
+    sub super_args {
+        my @dummy = caller(@_ ? $_[0] : 2);
+        return @DB::args;
+    }
+}
+
+package Spiffy;
+sub super {
+    my $method;
+    my $frame = 1;
+    while ($method = (caller($frame++))[3]) {
+        $method =~ s/.*::// and last;
+    }
+    my @args = DB::super_args($frame);
+    @_ = @_ ? ($args[0], @_) : @args;
+    my $class = ref $_[0] ? ref $_[0] : $_[0];
+    my $caller_class = caller;
+    my $seen = 0;
+    my @super_classes = reverse grep {
+        ($seen or $seen = ($_ eq $caller_class)) ? 0 : 1;
+    } reverse @{all_my_bases($class)};
+    for my $super_class (@super_classes) {
+        no strict 'refs';
+        next if $super_class eq $class;
+        if (defined &{"${super_class}::$method"}) {
+            ${"$super_class\::AUTOLOAD"} = ${"$class\::AUTOLOAD"}
+              if $method eq 'AUTOLOAD';
+            return &{"${super_class}::$method"};
+        }
+    }
+    return;
+}
+
+#===============================================================================
+# This code deserves a spanking, because it is being very naughty.
+# It is exchanging base.pm's import() for its own, so that people
+# can use base.pm with Spiffy modules, without being the wiser.
+#===============================================================================
+my $real_base_import;
+my $real_mixin_import;
+
+BEGIN {
+    require base unless defined $INC{'base.pm'};
+    $INC{'mixin.pm'} ||= 'Spiffy/mixin.pm';
+    $real_base_import = \&base::import;
+    $real_mixin_import = \&mixin::import;
+    no warnings;
+    *base::import = \&spiffy_base_import;
+    *mixin::import = \&spiffy_mixin_import;
+}
+
+# my $i = 0;
+# while (my $caller = caller($i++)) {
+#     next unless $caller eq 'base' or $caller eq 'mixin';
+#     croak <<END;
+# Spiffy.pm must be loaded before calling 'use base' or 'use mixin' with a
+# Spiffy module. See the documentation of Spiffy.pm for details.
+# END
+# }
+
+sub spiffy_base_import {
+    my @base_classes = @_;
+    shift @base_classes;
+    no strict 'refs';
+    goto &$real_base_import
+      unless grep {
+          eval "require $_" unless %{"$_\::"};
+          $_->isa('Spiffy');
+      } @base_classes;
+    my $inheritor = caller(0);
+    for my $base_class (@base_classes) {
+        next if $inheritor->isa($base_class);
+        croak "Can't mix Spiffy and non-Spiffy classes in 'use base'.\n",
+              "See the documentation of Spiffy.pm for details\n  "
+          unless $base_class->isa('Spiffy');
+        $stack_frame = 1; # tell import to use different caller
+        import($base_class, '-base');
+        $stack_frame = 0;
+    }
+}
+
+sub mixin {
+    my $self = shift;
+    my $target_class = ref($self);
+    spiffy_mixin_import($target_class, @_)
+}
+
+sub spiffy_mixin_import {
+    my $target_class = shift;
+    $target_class = caller(0)
+      if $target_class eq 'mixin';
+    my $mixin_class = shift
+      or die "Nothing to mixin";
+    eval "require $mixin_class";
+    my @roles = @_;
+    my $pseudo_class = join '-', $target_class, $mixin_class, @roles;
+    my %methods = spiffy_mixin_methods($mixin_class, @roles);
+    no strict 'refs';
+    no warnings;
+    @{"$pseudo_class\::ISA"} = @{"$target_class\::ISA"};
+    @{"$target_class\::ISA"} = ($pseudo_class);
+    for (keys %methods) {
+        *{"$pseudo_class\::$_"} = $methods{$_};
+    }
+}
+
+sub spiffy_mixin_methods {
+    my $mixin_class = shift;
+    no strict 'refs';
+    my %methods = spiffy_all_methods($mixin_class);
+    map {
+        $methods{$_}
+          ? ($_, \ &{"$methods{$_}\::$_"})
+          : ($_, \ &{"$mixin_class\::$_"})
+    } @_
+      ? (get_roles($mixin_class, @_))
+      : (keys %methods);
+}
+
+sub get_roles {
+    my $mixin_class = shift;
+    my @roles = @_;
+    while (grep /^!*:/, @roles) {
+        @roles = map {
+            s/!!//g;
+            /^!:(.*)/ ? do {
+                my $m = "_role_$1";
+                map("!$_", $mixin_class->$m);
+            } :
+            /^:(.*)/ ? do {
+                my $m = "_role_$1";
+                ($mixin_class->$m);
+            } :
+            ($_)
+        } @roles;
+    }
+    if (@roles and $roles[0] =~ /^!/) {
+        my %methods = spiffy_all_methods($mixin_class);
+        unshift @roles, keys(%methods);
+    }
+    my %roles;
+    for (@roles) {
+        s/!!//g;
+        delete $roles{$1}, next
+          if /^!(.*)/;
+        $roles{$_} = 1;
+    }
+    keys %roles;
+}
+
+sub spiffy_all_methods {
+    no strict 'refs';
+    my $class = shift;
+    return if $class eq 'Spiffy';
+    my %methods = map {
+        ($_, $class)
+    } grep {
+        defined &{"$class\::$_"} and not /^_/
+    } keys %{"$class\::"};
+    my %super_methods;
+    %super_methods = spiffy_all_methods(${"$class\::ISA"}[0])
+      if @{"$class\::ISA"};
+    %{{%super_methods, %methods}};
+}
+
+
+# END of naughty code.
+#===============================================================================
+# Debugging support
+#===============================================================================
+sub spiffy_dump {
+    no warnings;
+    if ($dump eq 'dumper') {
+        require Data::Dumper;
+        $Data::Dumper::Sortkeys = 1;
+        $Data::Dumper::Indent = 1;
+        return Data::Dumper::Dumper(@_);
+    }
+    require YAML;
+    $YAML::UseVersion = 0;
+    return YAML::Dump(@_) . "...\n";
+}
+
+sub at_line_number {
+    my ($file_path, $line_number) = (caller(1))[1,2];
+    "  at $file_path line $line_number\n";
+}
+
+sub WWW {
+    warn spiffy_dump(@_) . at_line_number;
+    return wantarray ? @_ : $_[0];
+}
+
+sub XXX {
+    die spiffy_dump(@_) . at_line_number;
+}
+
+sub YYY {
+    print spiffy_dump(@_) . at_line_number;
+    return wantarray ? @_ : $_[0];
+}
+
+sub ZZZ {
+    require Carp;
+    Carp::confess spiffy_dump(@_);
+}
+
+1;
+
+__END__
+
+#line 1066
Index: 0.8/modules/nginx-echo/test/inc/Test/Base.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Test/Base.pm	2010-10-31 07:35:47.678338000 +0000
@@ -0,0 +1,684 @@
+#line 1
+# TODO:
+#
+package Test::Base;
+use 5.006001;
+use Spiffy 0.30 -Base;
+use Spiffy ':XXX';
+our $VERSION = '0.59';
+
+my @test_more_exports;
+BEGIN {
+    @test_more_exports = qw(
+        ok isnt like unlike is_deeply cmp_ok
+        skip todo_skip pass fail
+        eq_array eq_hash eq_set
+        plan can_ok isa_ok diag
+        use_ok
+        $TODO
+    );
+}
+
+use Test::More import => \@test_more_exports;
+use Carp;
+
+our @EXPORT = (@test_more_exports, qw(
+    is no_diff
+
+    blocks next_block first_block
+    delimiters spec_file spec_string
+    filters filters_delay filter_arguments
+    run run_compare run_is run_is_deeply run_like run_unlike
+    skip_all_unless_require is_deep run_is_deep
+    WWW XXX YYY ZZZ
+    tie_output no_diag_on_only
+
+    find_my_self default_object
+
+    croak carp cluck confess
+));
+
+field '_spec_file';
+field '_spec_string';
+field _filters => [qw(norm trim)];
+field _filters_map => {};
+field spec =>
+      -init => '$self->_spec_init';
+field block_list =>
+      -init => '$self->_block_list_init';
+field _next_list => [];
+field block_delim =>
+      -init => '$self->block_delim_default';
+field data_delim =>
+      -init => '$self->data_delim_default';
+field _filters_delay => 0;
+field _no_diag_on_only => 0;
+
+field block_delim_default => '===';
+field data_delim_default => '---';
+
+my $default_class;
+my $default_object;
+my $reserved_section_names = {};
+
+sub default_object {
+    $default_object ||= $default_class->new;
+    return $default_object;
+}
+
+my $import_called = 0;
+sub import() {
+    $import_called = 1;
+    my $class = (grep /^-base$/i, @_)
+    ? scalar(caller)
+    : $_[0];
+    if (not defined $default_class) {
+        $default_class = $class;
+    }
+#     else {
+#         croak "Can't use $class after using $default_class"
+#           unless $default_class->isa($class);
+#     }
+
+    unless (grep /^-base$/i, @_) {
+        my @args;
+        for (my $ii = 1; $ii <= $#_; ++$ii) {
+            if ($_[$ii] eq '-package') {
+                ++$ii;
+            } else {
+                push @args, $_[$ii];
+            }
+        }
+        Test::More->import(import => \@test_more_exports, @args)
+            if @args;
+     }
+
+    _strict_warnings();
+    goto &Spiffy::import;
+}
+
+# Wrap Test::Builder::plan
+my $plan_code = \&Test::Builder::plan;
+my $Have_Plan = 0;
+{
+    no warnings 'redefine';
+    *Test::Builder::plan = sub {
+        $Have_Plan = 1;
+        goto &$plan_code;
+    };
+}
+
+my $DIED = 0;
+$SIG{__DIE__} = sub { $DIED = 1; die @_ };
+
+sub block_class  { $self->find_class('Block') }
+sub filter_class { $self->find_class('Filter') }
+
+sub find_class {
+    my $suffix = shift;
+    my $class = ref($self) . "::$suffix";
+    return $class if $class->can('new');
+    $class = __PACKAGE__ . "::$suffix";
+    return $class if $class->can('new');
+    eval "require $class";
+    return $class if $class->can('new');
+    die "Can't find a class for $suffix";
+}
+
+sub check_late {
+    if ($self->{block_list}) {
+        my $caller = (caller(1))[3];
+        $caller =~ s/.*:://;
+        croak "Too late to call $caller()"
+    }
+}
+
+sub find_my_self() {
+    my $self = ref($_[0]) eq $default_class
+    ? splice(@_, 0, 1)
+    : default_object();
+    return $self, @_;
+}
+
+sub blocks() {
+    (my ($self), @_) = find_my_self(@_);
+
+    croak "Invalid arguments passed to 'blocks'"
+      if @_ > 1;
+    croak sprintf("'%s' is invalid argument to blocks()", shift(@_))
+      if @_ && $_[0] !~ /^[a-zA-Z]\w*$/;
+
+    my $blocks = $self->block_list;
+
+    my $section_name = shift || '';
+    my @blocks = $section_name
+    ? (grep { exists $_->{$section_name} } @$blocks)
+    : (@$blocks);
+
+    return scalar(@blocks) unless wantarray;
+
+    return (@blocks) if $self->_filters_delay;
+
+    for my $block (@blocks) {
+        $block->run_filters
+          unless $block->is_filtered;
+    }
+
+    return (@blocks);
+}
+
+sub next_block() {
+    (my ($self), @_) = find_my_self(@_);
+    my $list = $self->_next_list;
+    if (@$list == 0) {
+        $list = [@{$self->block_list}, undef];
+        $self->_next_list($list);
+    }
+    my $block = shift @$list;
+    if (defined $block and not $block->is_filtered) {
+        $block->run_filters;
+    }
+    return $block;
+}
+
+sub first_block() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_next_list([]);
+    $self->next_block;
+}
+
+sub filters_delay() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_filters_delay(defined $_[0] ? shift : 1);
+}
+
+sub no_diag_on_only() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_no_diag_on_only(defined $_[0] ? shift : 1);
+}
+
+sub delimiters() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    my ($block_delimiter, $data_delimiter) = @_;
+    $block_delimiter ||= $self->block_delim_default;
+    $data_delimiter ||= $self->data_delim_default;
+    $self->block_delim($block_delimiter);
+    $self->data_delim($data_delimiter);
+    return $self;
+}
+
+sub spec_file() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    $self->_spec_file(shift);
+    return $self;
+}
+
+sub spec_string() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->check_late;
+    $self->_spec_string(shift);
+    return $self;
+}
+
+sub filters() {
+    (my ($self), @_) = find_my_self(@_);
+    if (ref($_[0]) eq 'HASH') {
+        $self->_filters_map(shift);
+    }
+    else {
+        my $filters = $self->_filters;
+        push @$filters, @_;
+    }
+    return $self;
+}
+
+sub filter_arguments() {
+    $Test::Base::Filter::arguments;
+}
+
+sub have_text_diff {
+    eval { require Text::Diff; 1 } &&
+        $Text::Diff::VERSION >= 0.35 &&
+        $Algorithm::Diff::VERSION >= 1.15;
+}
+
+sub is($$;$) {
+    (my ($self), @_) = find_my_self(@_);
+    my ($actual, $expected, $name) = @_;
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    if ($ENV{TEST_SHOW_NO_DIFFS} or
+         not defined $actual or
+         not defined $expected or
+         $actual eq $expected or
+         not($self->have_text_diff) or
+         $expected !~ /\n./s
+    ) {
+        Test::More::is($actual, $expected, $name);
+    }
+    else {
+        $name = '' unless defined $name;
+        ok $actual eq $expected,
+           $name . "\n" . Text::Diff::diff(\$expected, \$actual);
+    }
+}
+
+sub run(&;$) {
+    (my ($self), @_) = find_my_self(@_);
+    my $callback = shift;
+    for my $block (@{$self->block_list}) {
+        $block->run_filters unless $block->is_filtered;
+        &{$callback}($block);
+    }
+}
+
+my $name_error = "Can't determine section names";
+sub _section_names {
+    return @_ if @_ == 2;
+    my $block = $self->first_block
+      or croak $name_error;
+    my @names = grep {
+        $_ !~ /^(ONLY|LAST|SKIP)$/;
+    } @{$block->{_section_order}[0] || []};
+    croak "$name_error. Need two sections in first block"
+      unless @names == 2;
+    return @names;
+}
+
+sub _assert_plan {
+    plan('no_plan') unless $Have_Plan;
+}
+
+sub END {
+    run_compare() unless $Have_Plan or $DIED or not $import_called;
+}
+
+sub run_compare() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        if (ref $block->$x) {
+            is_deeply($block->$x, $block->$y,
+                $block->name ? $block->name : ());
+        }
+        elsif (ref $block->$y eq 'Regexp') {
+            my $regexp = ref $y ? $y : $block->$y;
+            like($block->$x, $regexp, $block->name ? $block->name : ());
+        }
+        else {
+            is($block->$x, $block->$y, $block->name ? $block->name : ());
+        }
+    }
+}
+
+sub run_is() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    local $Test::Builder::Level = $Test::Builder::Level + 1;
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is($block->$x, $block->$y,
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub run_is_deeply() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is_deeply($block->$x, $block->$y,
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub run_like() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and defined($y);
+        $block->run_filters unless $block->is_filtered;
+        my $regexp = ref $y ? $y : $block->$y;
+        like($block->$x, $regexp,
+             $block->name ? $block->name : ()
+            );
+    }
+}
+
+sub run_unlike() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and defined($y);
+        $block->run_filters unless $block->is_filtered;
+        my $regexp = ref $y ? $y : $block->$y;
+        unlike($block->$x, $regexp,
+               $block->name ? $block->name : ()
+              );
+    }
+}
+
+sub skip_all_unless_require() {
+    (my ($self), @_) = find_my_self(@_);
+    my $module = shift;
+    eval "require $module; 1"
+        or Test::More::plan(
+            skip_all => "$module failed to load"
+        );
+}
+
+sub is_deep() {
+    (my ($self), @_) = find_my_self(@_);
+    require Test::Deep;
+    Test::Deep::cmp_deeply(@_);
+}
+
+sub run_is_deep() {
+    (my ($self), @_) = find_my_self(@_);
+    $self->_assert_plan;
+    my ($x, $y) = $self->_section_names(@_);
+    for my $block (@{$self->block_list}) {
+        next unless exists($block->{$x}) and exists($block->{$y});
+        $block->run_filters unless $block->is_filtered;
+        is_deep($block->$x, $block->$y,
+           $block->name ? $block->name : ()
+          );
+    }
+}
+
+sub _pre_eval {
+    my $spec = shift;
+    return $spec unless $spec =~
+      s/\A\s*<<<(.*?)>>>\s*$//sm;
+    my $eval_code = $1;
+    eval "package main; $eval_code";
+    croak $@ if $@;
+    return $spec;
+}
+
+sub _block_list_init {
+    my $spec = $self->spec;
+    $spec = $self->_pre_eval($spec);
+    my $cd = $self->block_delim;
+    my @hunks = ($spec =~ /^(\Q${cd}\E.*?(?=^\Q${cd}\E|\z))/msg);
+    my $blocks = $self->_choose_blocks(@hunks);
+    $self->block_list($blocks); # Need to set early for possible filter use
+    my $seq = 1;
+    for my $block (@$blocks) {
+        $block->blocks_object($self);
+        $block->seq_num($seq++);
+    }
+    return $blocks;
+}
+
+sub _choose_blocks {
+    my $blocks = [];
+    for my $hunk (@_) {
+        my $block = $self->_make_block($hunk);
+        if (exists $block->{ONLY}) {
+            diag "I found ONLY: maybe you're debugging?"
+                unless $self->_no_diag_on_only;
+            return [$block];
+        }
+        next if exists $block->{SKIP};
+        push @$blocks, $block;
+        if (exists $block->{LAST}) {
+            return $blocks;
+        }
+    }
+    return $blocks;
+}
+
+sub _check_reserved {
+    my $id = shift;
+    croak "'$id' is a reserved name. Use something else.\n"
+      if $reserved_section_names->{$id} or
+         $id =~ /^_/;
+}
+
+sub _make_block {
+    my $hunk = shift;
+    my $cd = $self->block_delim;
+    my $dd = $self->data_delim;
+    my $block = $self->block_class->new;
+    $hunk =~ s/\A\Q${cd}\E[ \t]*(.*)\s+// or die;
+    my $name = $1;
+    my @parts = split /^\Q${dd}\E +\(?(\w+)\)? *(.*)?\n/m, $hunk;
+    my $description = shift @parts;
+    $description ||= '';
+    unless ($description =~ /\S/) {
+        $description = $name;
+    }
+    $description =~ s/\s*\z//;
+    $block->set_value(description => $description);
+
+    my $section_map = {};
+    my $section_order = [];
+    while (@parts) {
+        my ($type, $filters, $value) = splice(@parts, 0, 3);
+        $self->_check_reserved($type);
+        $value = '' unless defined $value;
+        $filters = '' unless defined $filters;
+        if ($filters =~ /:(\s|\z)/) {
+            croak "Extra lines not allowed in '$type' section"
+              if $value =~ /\S/;
+            ($filters, $value) = split /\s*:(?:\s+|\z)/, $filters, 2;
+            $value = '' unless defined $value;
+            $value =~ s/^\s*(.*?)\s*$/$1/;
+        }
+        $section_map->{$type} = {
+            filters => $filters,
+        };
+        push @$section_order, $type;
+        $block->set_value($type, $value);
+    }
+    $block->set_value(name => $name);
+    $block->set_value(_section_map => $section_map);
+    $block->set_value(_section_order => $section_order);
+    return $block;
+}
+
+sub _spec_init {
+    return $self->_spec_string
+      if $self->_spec_string;
+    local $/;
+    my $spec;
+    if (my $spec_file = $self->_spec_file) {
+        open FILE, $spec_file or die $!;
+        $spec = <FILE>;
+        close FILE;
+    }
+    else {
+        $spec = do {
+            package main;
+            no warnings 'once';
+            <DATA>;
+        };
+    }
+    return $spec;
+}
+
+sub _strict_warnings() {
+    require Filter::Util::Call;
+    my $done = 0;
+    Filter::Util::Call::filter_add(
+        sub {
+            return 0 if $done;
+            my ($data, $end) = ('', '');
+            while (my $status = Filter::Util::Call::filter_read()) {
+                return $status if $status < 0;
+                if (/^__(?:END|DATA)__\r?$/) {
+                    $end = $_;
+                    last;
+                }
+                $data .= $_;
+                $_ = '';
+            }
+            $_ = "use strict;use warnings;$data$end";
+            $done = 1;
+        }
+    );
+}
+
+sub tie_output() {
+    my $handle = shift;
+    die "No buffer to tie" unless @_;
+    tie $handle, 'Test::Base::Handle', $_[0];
+}
+
+sub no_diff {
+    $ENV{TEST_SHOW_NO_DIFFS} = 1;
+}
+
+package Test::Base::Handle;
+
+sub TIEHANDLE() {
+    my $class = shift;
+    bless \ $_[0], $class;
+}
+
+sub PRINT {
+    $$self .= $_ for @_;
+}
+
+#===============================================================================
+# Test::Base::Block
+#
+# This is the default class for accessing a Test::Base block object.
+#===============================================================================
+package Test::Base::Block;
+our @ISA = qw(Spiffy);
+
+our @EXPORT = qw(block_accessor);
+
+sub AUTOLOAD {
+    return;
+}
+
+sub block_accessor() {
+    my $accessor = shift;
+    no strict 'refs';
+    return if defined &$accessor;
+    *$accessor = sub {
+        my $self = shift;
+        if (@_) {
+            Carp::croak "Not allowed to set values for '$accessor'";
+        }
+        my @list = @{$self->{$accessor} || []};
+        return wantarray
+        ? (@list)
+        : $list[0];
+    };
+}
+
+block_accessor 'name';
+block_accessor 'description';
+Spiffy::field 'seq_num';
+Spiffy::field 'is_filtered';
+Spiffy::field 'blocks_object';
+Spiffy::field 'original_values' => {};
+
+sub set_value {
+    no strict 'refs';
+    my $accessor = shift;
+    block_accessor $accessor
+      unless defined &$accessor;
+    $self->{$accessor} = [@_];
+}
+
+sub run_filters {
+    my $map = $self->_section_map;
+    my $order = $self->_section_order;
+    Carp::croak "Attempt to filter a block twice"
+      if $self->is_filtered;
+    for my $type (@$order) {
+        my $filters = $map->{$type}{filters};
+        my @value = $self->$type;
+        $self->original_values->{$type} = $value[0];
+        for my $filter ($self->_get_filters($type, $filters)) {
+            $Test::Base::Filter::arguments =
+              $filter =~ s/=(.*)$// ? $1 : undef;
+            my $function = "main::$filter";
+            no strict 'refs';
+            if (defined &$function) {
+                local $_ =
+                    (@value == 1 and not defined($value[0])) ? undef :
+                        join '', @value;
+                my $old = $_;
+                @value = &$function(@value);
+                if (not(@value) or
+                    @value == 1 and defined($value[0]) and $value[0] =~ /\A(\d+|)\z/
+                ) {
+                    if ($value[0] && $_ eq $old) {
+                        Test::Base::diag("Filters returning numbers are supposed to do munging \$_: your filter '$function' apparently doesn't.");
+                    }
+                    @value = ($_);
+                }
+            }
+            else {
+                my $filter_object = $self->blocks_object->filter_class->new;
+                die "Can't find a function or method for '$filter' filter\n"
+                  unless $filter_object->can($filter);
+                $filter_object->current_block($self);
+                @value = $filter_object->$filter(@value);
+            }
+            # Set the value after each filter since other filters may be
+            # introspecting.
+            $self->set_value($type, @value);
+        }
+    }
+    $self->is_filtered(1);
+}
+
+sub _get_filters {
+    my $type = shift;
+    my $string = shift || '';
+    $string =~ s/\s*(.*?)\s*/$1/;
+    my @filters = ();
+    my $map_filters = $self->blocks_object->_filters_map->{$type} || [];
+    $map_filters = [ $map_filters ] unless ref $map_filters;
+    my @append = ();
+    for (
+        @{$self->blocks_object->_filters},
+        @$map_filters,
+        split(/\s+/, $string),
+    ) {
+        my $filter = $_;
+        last unless length $filter;
+        if ($filter =~ s/^-//) {
+            @filters = grep { $_ ne $filter } @filters;
+        }
+        elsif ($filter =~ s/^\+//) {
+            push @append, $filter;
+        }
+        else {
+            push @filters, $filter;
+        }
+    }
+    return @filters, @append;
+}
+
+{
+    %$reserved_section_names = map {
+        ($_, 1);
+    } keys(%Test::Base::Block::), qw( new DESTROY );
+}
+
+__DATA__
+
+=encoding utf8
+
+#line 1376
Index: 0.8/modules/nginx-echo/test/inc/Test/Builder.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Test/Builder.pm	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,1413 @@
+#line 1
+package Test::Builder;
+
+use 5.006;
+use strict;
+use warnings;
+
+our $VERSION = '0.92';
+$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+BEGIN {
+    if( $] < 5.008 ) {
+        require Test::Builder::IO::Scalar;
+    }
+}
+
+
+# Make Test::Builder thread-safe for ithreads.
+BEGIN {
+    use Config;
+    # Load threads::shared when threads are turned on.
+    # 5.8.0's threads are so busted we no longer support them.
+    if( $] >= 5.008001 && $Config{useithreads} && $INC{'threads.pm'} ) {
+        require threads::shared;
+
+        # Hack around YET ANOTHER threads::shared bug.  It would
+        # occassionally forget the contents of the variable when sharing it.
+        # So we first copy the data, then share, then put our copy back.
+        *share = sub (\[$@%]) {
+            my $type = ref $_[0];
+            my $data;
+
+            if( $type eq 'HASH' ) {
+                %$data = %{ $_[0] };
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @$data = @{ $_[0] };
+            }
+            elsif( $type eq 'SCALAR' ) {
+                $$data = ${ $_[0] };
+            }
+            else {
+                die( "Unknown type: " . $type );
+            }
+
+            $_[0] = &threads::shared::share( $_[0] );
+
+            if( $type eq 'HASH' ) {
+                %{ $_[0] } = %$data;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                @{ $_[0] } = @$data;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                ${ $_[0] } = $$data;
+            }
+            else {
+                die( "Unknown type: " . $type );
+            }
+
+            return $_[0];
+        };
+    }
+    # 5.8.0's threads::shared is busted when threads are off
+    # and earlier Perls just don't have that module at all.
+    else {
+        *share = sub { return $_[0] };
+        *lock  = sub { 0 };
+    }
+}
+
+#line 117
+
+my $Test = Test::Builder->new;
+
+sub new {
+    my($class) = shift;
+    $Test ||= $class->create;
+    return $Test;
+}
+
+#line 139
+
+sub create {
+    my $class = shift;
+
+    my $self = bless {}, $class;
+    $self->reset;
+
+    return $self;
+}
+
+#line 158
+
+our $Level;
+
+sub reset {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
+    my($self) = @_;
+
+    # We leave this a global because it has to be localized and localizing
+    # hash keys is just asking for pain.  Also, it was documented.
+    $Level = 1;
+
+    $self->{Have_Plan}    = 0;
+    $self->{No_Plan}      = 0;
+    $self->{Have_Output_Plan} = 0;
+
+    $self->{Original_Pid} = $$;
+
+    share( $self->{Curr_Test} );
+    $self->{Curr_Test} = 0;
+    $self->{Test_Results} = &share( [] );
+
+    $self->{Exported_To}    = undef;
+    $self->{Expected_Tests} = 0;
+
+    $self->{Skip_All} = 0;
+
+    $self->{Use_Nums} = 1;
+
+    $self->{No_Header} = 0;
+    $self->{No_Ending} = 0;
+
+    $self->{Todo}       = undef;
+    $self->{Todo_Stack} = [];
+    $self->{Start_Todo} = 0;
+    $self->{Opened_Testhandles} = 0;
+
+    $self->_dup_stdhandles;
+
+    return;
+}
+
+#line 219
+
+my %plan_cmds = (
+    no_plan     => \&no_plan,
+    skip_all    => \&skip_all,
+    tests       => \&_plan_tests,
+);
+
+sub plan {
+    my( $self, $cmd, $arg ) = @_;
+
+    return unless $cmd;
+
+    local $Level = $Level + 1;
+
+    $self->croak("You tried to plan twice") if $self->{Have_Plan};
+
+    if( my $method = $plan_cmds{$cmd} ) {
+        local $Level = $Level + 1;
+        $self->$method($arg);
+    }
+    else {
+        my @args = grep { defined } ( $cmd, $arg );
+        $self->croak("plan() doesn't understand @args");
+    }
+
+    return 1;
+}
+
+
+sub _plan_tests {
+    my($self, $arg) = @_;
+
+    if($arg) {
+        local $Level = $Level + 1;
+        return $self->expected_tests($arg);
+    }
+    elsif( !defined $arg ) {
+        $self->croak("Got an undefined number of tests");
+    }
+    else {
+        $self->croak("You said to run 0 tests");
+    }
+
+    return;
+}
+
+
+#line 275
+
+sub expected_tests {
+    my $self = shift;
+    my($max) = @_;
+
+    if(@_) {
+        $self->croak("Number of tests must be a positive integer.  You gave it '$max'")
+          unless $max =~ /^\+?\d+$/;
+
+        $self->{Expected_Tests} = $max;
+        $self->{Have_Plan}      = 1;
+
+        $self->_output_plan($max) unless $self->no_header;
+    }
+    return $self->{Expected_Tests};
+}
+
+#line 299
+
+sub no_plan {
+    my($self, $arg) = @_;
+
+    $self->carp("no_plan takes no arguments") if $arg;
+
+    $self->{No_Plan}   = 1;
+    $self->{Have_Plan} = 1;
+
+    return 1;
+}
+
+
+#line 333
+
+sub _output_plan {
+    my($self, $max, $directive, $reason) = @_;
+
+    $self->carp("The plan was already output") if $self->{Have_Output_Plan};
+
+    my $plan = "1..$max";
+    $plan .= " # $directive" if defined $directive;
+    $plan .= " $reason"      if defined $reason;
+
+    $self->_print("$plan\n");
+
+    $self->{Have_Output_Plan} = 1;
+
+    return;
+}
+
+#line 384
+
+sub done_testing {
+    my($self, $num_tests) = @_;
+
+    # If done_testing() specified the number of tests, shut off no_plan.
+    if( defined $num_tests ) {
+        $self->{No_Plan} = 0;
+    }
+    else {
+        $num_tests = $self->current_test;
+    }
+
+    if( $self->{Done_Testing} ) {
+        my($file, $line) = @{$self->{Done_Testing}}[1,2];
+        $self->ok(0, "done_testing() was already called at $file line $line");
+        return;
+    }
+
+    $self->{Done_Testing} = [caller];
+
+    if( $self->expected_tests && $num_tests != $self->expected_tests ) {
+        $self->ok(0, "planned to run @{[ $self->expected_tests ]} ".
+                     "but done_testing() expects $num_tests");
+    }
+    else {
+        $self->{Expected_Tests} = $num_tests;
+    }
+
+    $self->_output_plan($num_tests) unless $self->{Have_Output_Plan};
+
+    $self->{Have_Plan} = 1;
+
+    return 1;
+}
+
+
+#line 429
+
+sub has_plan {
+    my $self = shift;
+
+    return( $self->{Expected_Tests} ) if $self->{Expected_Tests};
+    return('no_plan') if $self->{No_Plan};
+    return(undef);
+}
+
+#line 446
+
+sub skip_all {
+    my( $self, $reason ) = @_;
+
+    $self->{Skip_All} = 1;
+
+    $self->_output_plan(0, "SKIP", $reason) unless $self->no_header;
+    exit(0);
+}
+
+#line 468
+
+sub exported_to {
+    my( $self, $pack ) = @_;
+
+    if( defined $pack ) {
+        $self->{Exported_To} = $pack;
+    }
+    return $self->{Exported_To};
+}
+
+#line 498
+
+sub ok {
+    my( $self, $test, $name ) = @_;
+
+    # $test might contain an object which we don't want to accidentally
+    # store, so we turn it into a boolean.
+    $test = $test ? 1 : 0;
+
+    lock $self->{Curr_Test};
+    $self->{Curr_Test}++;
+
+    # In case $name is a string overloaded object, force it to stringify.
+    $self->_unoverload_str( \$name );
+
+    $self->diag(<<"ERR") if defined $name and $name =~ /^[\d\s]+$/;
+    You named your test '$name'.  You shouldn't use numbers for your test names.
+    Very confusing.
+ERR
+
+    # Capture the value of $TODO for the rest of this ok() call
+    # so it can more easily be found by other routines.
+    my $todo    = $self->todo();
+    my $in_todo = $self->in_todo;
+    local $self->{Todo} = $todo if $in_todo;
+
+    $self->_unoverload_str( \$todo );
+
+    my $out;
+    my $result = &share( {} );
+
+    unless($test) {
+        $out .= "not ";
+        @$result{ 'ok', 'actual_ok' } = ( ( $self->in_todo ? 1 : 0 ), 0 );
+    }
+    else {
+        @$result{ 'ok', 'actual_ok' } = ( 1, $test );
+    }
+
+    $out .= "ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+
+    if( defined $name ) {
+        $name =~ s|#|\\#|g;    # # in a name can confuse Test::Harness.
+        $out .= " - $name";
+        $result->{name} = $name;
+    }
+    else {
+        $result->{name} = '';
+    }
+
+    if( $self->in_todo ) {
+        $out .= " # TODO $todo";
+        $result->{reason} = $todo;
+        $result->{type}   = 'todo';
+    }
+    else {
+        $result->{reason} = '';
+        $result->{type}   = '';
+    }
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = $result;
+    $out .= "\n";
+
+    $self->_print($out);
+
+    unless($test) {
+        my $msg = $self->in_todo ? "Failed (TODO)" : "Failed";
+        $self->_print_to_fh( $self->_diag_fh, "\n" ) if $ENV{HARNESS_ACTIVE};
+
+        my( undef, $file, $line ) = $self->caller;
+        if( defined $name ) {
+            $self->diag(qq[  $msg test '$name'\n]);
+            $self->diag(qq[  at $file line $line.\n]);
+        }
+        else {
+            $self->diag(qq[  $msg test at $file line $line.\n]);
+        }
+    }
+
+    return $test ? 1 : 0;
+}
+
+sub _unoverload {
+    my $self = shift;
+    my $type = shift;
+
+    $self->_try(sub { require overload; }, die_on_fail => 1);
+
+    foreach my $thing (@_) {
+        if( $self->_is_object($$thing) ) {
+            if( my $string_meth = overload::Method( $$thing, $type ) ) {
+                $$thing = $$thing->$string_meth();
+            }
+        }
+    }
+
+    return;
+}
+
+sub _is_object {
+    my( $self, $thing ) = @_;
+
+    return $self->_try( sub { ref $thing && $thing->isa('UNIVERSAL') } ) ? 1 : 0;
+}
+
+sub _unoverload_str {
+    my $self = shift;
+
+    return $self->_unoverload( q[""], @_ );
+}
+
+sub _unoverload_num {
+    my $self = shift;
+
+    $self->_unoverload( '0+', @_ );
+
+    for my $val (@_) {
+        next unless $self->_is_dualvar($$val);
+        $$val = $$val + 0;
+    }
+
+    return;
+}
+
+# This is a hack to detect a dualvar such as $!
+sub _is_dualvar {
+    my( $self, $val ) = @_;
+
+    # Objects are not dualvars.
+    return 0 if ref $val;
+
+    no warnings 'numeric';
+    my $numval = $val + 0;
+    return $numval != 0 and $numval ne $val ? 1 : 0;
+}
+
+#line 649
+
+sub is_eq {
+    my( $self, $got, $expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    $self->_unoverload_str( \$got, \$expect );
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok( $test, $name );
+        $self->_is_diag( $got, 'eq', $expect ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, 'eq', $expect, $name );
+}
+
+sub is_num {
+    my( $self, $got, $expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    $self->_unoverload_num( \$got, \$expect );
+
+    if( !defined $got || !defined $expect ) {
+        # undef only matches undef and nothing else
+        my $test = !defined $got && !defined $expect;
+
+        $self->ok( $test, $name );
+        $self->_is_diag( $got, '==', $expect ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, '==', $expect, $name );
+}
+
+sub _diag_fmt {
+    my( $self, $type, $val ) = @_;
+
+    if( defined $$val ) {
+        if( $type eq 'eq' or $type eq 'ne' ) {
+            # quote and force string context
+            $$val = "'$$val'";
+        }
+        else {
+            # force numeric context
+            $self->_unoverload_num($val);
+        }
+    }
+    else {
+        $$val = 'undef';
+    }
+
+    return;
+}
+
+sub _is_diag {
+    my( $self, $got, $type, $expect ) = @_;
+
+    $self->_diag_fmt( $type, $_ ) for \$got, \$expect;
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+         got: $got
+    expected: $expect
+DIAGNOSTIC
+
+}
+
+sub _isnt_diag {
+    my( $self, $got, $type ) = @_;
+
+    $self->_diag_fmt( $type, \$got );
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+         got: $got
+    expected: anything else
+DIAGNOSTIC
+}
+
+#line 746
+
+sub isnt_eq {
+    my( $self, $got, $dont_expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok( $test, $name );
+        $self->_isnt_diag( $got, 'ne' ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, 'ne', $dont_expect, $name );
+}
+
+sub isnt_num {
+    my( $self, $got, $dont_expect, $name ) = @_;
+    local $Level = $Level + 1;
+
+    if( !defined $got || !defined $dont_expect ) {
+        # undef only matches undef and nothing else
+        my $test = defined $got || defined $dont_expect;
+
+        $self->ok( $test, $name );
+        $self->_isnt_diag( $got, '!=' ) unless $test;
+        return $test;
+    }
+
+    return $self->cmp_ok( $got, '!=', $dont_expect, $name );
+}
+
+#line 797
+
+sub like {
+    my( $self, $this, $regex, $name ) = @_;
+
+    local $Level = $Level + 1;
+    return $self->_regex_ok( $this, $regex, '=~', $name );
+}
+
+sub unlike {
+    my( $self, $this, $regex, $name ) = @_;
+
+    local $Level = $Level + 1;
+    return $self->_regex_ok( $this, $regex, '!~', $name );
+}
+
+#line 821
+
+my %numeric_cmps = map { ( $_, 1 ) } ( "<", "<=", ">", ">=", "==", "!=", "<=>" );
+
+sub cmp_ok {
+    my( $self, $got, $type, $expect, $name ) = @_;
+
+    my $test;
+    my $error;
+    {
+        ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+
+        my($pack, $file, $line) = $self->caller();
+
+        $test = eval qq[
+#line 1 "cmp_ok [from $file line $line]"
+\$got $type \$expect;
+];
+        $error = $@;
+    }
+    local $Level = $Level + 1;
+    my $ok = $self->ok( $test, $name );
+
+    # Treat overloaded objects as numbers if we're asked to do a
+    # numeric comparison.
+    my $unoverload
+      = $numeric_cmps{$type}
+      ? '_unoverload_num'
+      : '_unoverload_str';
+
+    $self->diag(<<"END") if $error;
+An error occurred while using $type:
+------------------------------------
+$error
+------------------------------------
+END
+
+    unless($ok) {
+        $self->$unoverload( \$got, \$expect );
+
+        if( $type =~ /^(eq|==)$/ ) {
+            $self->_is_diag( $got, $type, $expect );
+        }
+        elsif( $type =~ /^(ne|!=)$/ ) {
+            $self->_isnt_diag( $got, $type );
+        }
+        else {
+            $self->_cmp_diag( $got, $type, $expect );
+        }
+    }
+    return $ok;
+}
+
+sub _cmp_diag {
+    my( $self, $got, $type, $expect ) = @_;
+
+    $got    = defined $got    ? "'$got'"    : 'undef';
+    $expect = defined $expect ? "'$expect'" : 'undef';
+
+    local $Level = $Level + 1;
+    return $self->diag(<<"DIAGNOSTIC");
+    $got
+        $type
+    $expect
+DIAGNOSTIC
+}
+
+sub _caller_context {
+    my $self = shift;
+
+    my( $pack, $file, $line ) = $self->caller(1);
+
+    my $code = '';
+    $code .= "#line $line $file\n" if defined $file and defined $line;
+
+    return $code;
+}
+
+#line 920
+
+sub BAIL_OUT {
+    my( $self, $reason ) = @_;
+
+    $self->{Bailed_Out} = 1;
+    $self->_print("Bail out!  $reason");
+    exit 255;
+}
+
+#line 933
+
+*BAILOUT = \&BAIL_OUT;
+
+#line 944
+
+sub skip {
+    my( $self, $why ) = @_;
+    $why ||= '';
+    $self->_unoverload_str( \$why );
+
+    lock( $self->{Curr_Test} );
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
+        {
+            'ok'      => 1,
+            actual_ok => 1,
+            name      => '',
+            type      => 'skip',
+            reason    => $why,
+        }
+    );
+
+    my $out = "ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out .= " # skip";
+    $out .= " $why"               if length $why;
+    $out .= "\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+#line 985
+
+sub todo_skip {
+    my( $self, $why ) = @_;
+    $why ||= '';
+
+    lock( $self->{Curr_Test} );
+    $self->{Curr_Test}++;
+
+    $self->{Test_Results}[ $self->{Curr_Test} - 1 ] = &share(
+        {
+            'ok'      => 1,
+            actual_ok => 0,
+            name      => '',
+            type      => 'todo_skip',
+            reason    => $why,
+        }
+    );
+
+    my $out = "not ok";
+    $out .= " $self->{Curr_Test}" if $self->use_numbers;
+    $out .= " # TODO & SKIP $why\n";
+
+    $self->_print($out);
+
+    return 1;
+}
+
+#line 1062
+
+sub maybe_regex {
+    my( $self, $regex ) = @_;
+    my $usable_regex = undef;
+
+    return $usable_regex unless defined $regex;
+
+    my( $re, $opts );
+
+    # Check for qr/foo/
+    if( _is_qr($regex) ) {
+        $usable_regex = $regex;
+    }
+    # Check for '/foo/' or 'm,foo,'
+    elsif(( $re, $opts )        = $regex =~ m{^ /(.*)/ (\w*) $ }sx              or
+          ( undef, $re, $opts ) = $regex =~ m,^ m([^\w\s]) (.+) \1 (\w*) $,sx
+    )
+    {
+        $usable_regex = length $opts ? "(?$opts)$re" : $re;
+    }
+
+    return $usable_regex;
+}
+
+sub _is_qr {
+    my $regex = shift;
+
+    # is_regexp() checks for regexes in a robust manner, say if they're
+    # blessed.
+    return re::is_regexp($regex) if defined &re::is_regexp;
+    return ref $regex eq 'Regexp';
+}
+
+sub _regex_ok {
+    my( $self, $this, $regex, $cmp, $name ) = @_;
+
+    my $ok           = 0;
+    my $usable_regex = $self->maybe_regex($regex);
+    unless( defined $usable_regex ) {
+        local $Level = $Level + 1;
+        $ok = $self->ok( 0, $name );
+        $self->diag("    '$regex' doesn't look much like a regex to me.");
+        return $ok;
+    }
+
+    {
+        ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+        my $test;
+        my $code = $self->_caller_context;
+
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+
+        # Yes, it has to look like this or 5.4.5 won't see the #line
+        # directive.
+        # Don't ask me, man, I just work here.
+        $test = eval "
+$code" . q{$test = $this =~ /$usable_regex/ ? 1 : 0};
+
+        $test = !$test if $cmp eq '!~';
+
+        local $Level = $Level + 1;
+        $ok = $self->ok( $test, $name );
+    }
+
+    unless($ok) {
+        $this = defined $this ? "'$this'" : 'undef';
+        my $match = $cmp eq '=~' ? "doesn't match" : "matches";
+
+        local $Level = $Level + 1;
+        $self->diag( sprintf <<'DIAGNOSTIC', $this, $match, $regex );
+                  %s
+    %13s '%s'
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+# I'm not ready to publish this.  It doesn't deal with array return
+# values from the code or context.
+
+#line 1162
+
+sub _try {
+    my( $self, $code, %opts ) = @_;
+
+    my $error;
+    my $return;
+    {
+        local $!;               # eval can mess up $!
+        local $@;               # don't set $@ in the test
+        local $SIG{__DIE__};    # don't trip an outside DIE handler.
+        $return = eval { $code->() };
+        $error = $@;
+    }
+
+    die $error if $error and $opts{die_on_fail};
+
+    return wantarray ? ( $return, $error ) : $return;
+}
+
+#line 1191
+
+sub is_fh {
+    my $self     = shift;
+    my $maybe_fh = shift;
+    return 0 unless defined $maybe_fh;
+
+    return 1 if ref $maybe_fh  eq 'GLOB';    # its a glob ref
+    return 1 if ref \$maybe_fh eq 'GLOB';    # its a glob
+
+    return eval { $maybe_fh->isa("IO::Handle") } ||
+           # 5.5.4's tied() and can() doesn't like getting undef
+           eval { ( tied($maybe_fh) || '' )->can('TIEHANDLE') };
+}
+
+#line 1235
+
+sub level {
+    my( $self, $level ) = @_;
+
+    if( defined $level ) {
+        $Level = $level;
+    }
+    return $Level;
+}
+
+#line 1267
+
+sub use_numbers {
+    my( $self, $use_nums ) = @_;
+
+    if( defined $use_nums ) {
+        $self->{Use_Nums} = $use_nums;
+    }
+    return $self->{Use_Nums};
+}
+
+#line 1300
+
+foreach my $attribute (qw(No_Header No_Ending No_Diag)) {
+    my $method = lc $attribute;
+
+    my $code = sub {
+        my( $self, $no ) = @_;
+
+        if( defined $no ) {
+            $self->{$attribute} = $no;
+        }
+        return $self->{$attribute};
+    };
+
+    no strict 'refs';    ## no critic
+    *{ __PACKAGE__ . '::' . $method } = $code;
+}
+
+#line 1353
+
+sub diag {
+    my $self = shift;
+
+    $self->_print_comment( $self->_diag_fh, @_ );
+}
+
+#line 1368
+
+sub note {
+    my $self = shift;
+
+    $self->_print_comment( $self->output, @_ );
+}
+
+sub _diag_fh {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    return $self->in_todo ? $self->todo_output : $self->failure_output;
+}
+
+sub _print_comment {
+    my( $self, $fh, @msgs ) = @_;
+
+    return if $self->no_diag;
+    return unless @msgs;
+
+    # Prevent printing headers when compiling (i.e. -c)
+    return if $^C;
+
+    # Smash args together like print does.
+    # Convert undef to 'undef' so its readable.
+    my $msg = join '', map { defined($_) ? $_ : 'undef' } @msgs;
+
+    # Escape the beginning, _print will take care of the rest.
+    $msg =~ s/^/# /;
+
+    local $Level = $Level + 1;
+    $self->_print_to_fh( $fh, $msg );
+
+    return 0;
+}
+
+#line 1418
+
+sub explain {
+    my $self = shift;
+
+    return map {
+        ref $_
+          ? do {
+            $self->_try(sub { require Data::Dumper }, die_on_fail => 1);
+
+            my $dumper = Data::Dumper->new( [$_] );
+            $dumper->Indent(1)->Terse(1);
+            $dumper->Sortkeys(1) if $dumper->can("Sortkeys");
+            $dumper->Dump;
+          }
+          : $_
+    } @_;
+}
+
+#line 1447
+
+sub _print {
+    my $self = shift;
+    return $self->_print_to_fh( $self->output, @_ );
+}
+
+sub _print_to_fh {
+    my( $self, $fh, @msgs ) = @_;
+
+    # Prevent printing headers when only compiling.  Mostly for when
+    # tests are deparsed with B::Deparse
+    return if $^C;
+
+    my $msg = join '', @msgs;
+
+    local( $\, $", $, ) = ( undef, ' ', '' );
+
+    # Escape each line after the first with a # so we don't
+    # confuse Test::Harness.
+    $msg =~ s{\n(?!\z)}{\n# }sg;
+
+    # Stick a newline on the end if it needs it.
+    $msg .= "\n" unless $msg =~ /\n\z/;
+
+    return print $fh $msg;
+}
+
+#line 1506
+
+sub output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Out_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Out_FH};
+}
+
+sub failure_output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Fail_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Fail_FH};
+}
+
+sub todo_output {
+    my( $self, $fh ) = @_;
+
+    if( defined $fh ) {
+        $self->{Todo_FH} = $self->_new_fh($fh);
+    }
+    return $self->{Todo_FH};
+}
+
+sub _new_fh {
+    my $self = shift;
+    my($file_or_fh) = shift;
+
+    my $fh;
+    if( $self->is_fh($file_or_fh) ) {
+        $fh = $file_or_fh;
+    }
+    elsif( ref $file_or_fh eq 'SCALAR' ) {
+        # Scalar refs as filehandles was added in 5.8.
+        if( $] >= 5.008 ) {
+            open $fh, ">>", $file_or_fh
+              or $self->croak("Can't open scalar ref $file_or_fh: $!");
+        }
+        # Emulate scalar ref filehandles with a tie.
+        else {
+            $fh = Test::Builder::IO::Scalar->new($file_or_fh)
+              or $self->croak("Can't tie scalar ref $file_or_fh");
+        }
+    }
+    else {
+        open $fh, ">", $file_or_fh
+          or $self->croak("Can't open test output log $file_or_fh: $!");
+        _autoflush($fh);
+    }
+
+    return $fh;
+}
+
+sub _autoflush {
+    my($fh) = shift;
+    my $old_fh = select $fh;
+    $| = 1;
+    select $old_fh;
+
+    return;
+}
+
+my( $Testout, $Testerr );
+
+sub _dup_stdhandles {
+    my $self = shift;
+
+    $self->_open_testhandles;
+
+    # Set everything to unbuffered else plain prints to STDOUT will
+    # come out in the wrong order from our own prints.
+    _autoflush($Testout);
+    _autoflush( \*STDOUT );
+    _autoflush($Testerr);
+    _autoflush( \*STDERR );
+
+    $self->reset_outputs;
+
+    return;
+}
+
+sub _open_testhandles {
+    my $self = shift;
+
+    return if $self->{Opened_Testhandles};
+
+    # We dup STDOUT and STDERR so people can change them in their
+    # test suites while still getting normal test output.
+    open( $Testout, ">&STDOUT" ) or die "Can't dup STDOUT:  $!";
+    open( $Testerr, ">&STDERR" ) or die "Can't dup STDERR:  $!";
+
+    #    $self->_copy_io_layers( \*STDOUT, $Testout );
+    #    $self->_copy_io_layers( \*STDERR, $Testerr );
+
+    $self->{Opened_Testhandles} = 1;
+
+    return;
+}
+
+sub _copy_io_layers {
+    my( $self, $src, $dst ) = @_;
+
+    $self->_try(
+        sub {
+            require PerlIO;
+            my @src_layers = PerlIO::get_layers($src);
+
+            binmode $dst, join " ", map ":$_", @src_layers if @src_layers;
+        }
+    );
+
+    return;
+}
+
+#line 1631
+
+sub reset_outputs {
+    my $self = shift;
+
+    $self->output        ($Testout);
+    $self->failure_output($Testerr);
+    $self->todo_output   ($Testout);
+
+    return;
+}
+
+#line 1657
+
+sub _message_at_caller {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    my( $pack, $file, $line ) = $self->caller;
+    return join( "", @_ ) . " at $file line $line.\n";
+}
+
+sub carp {
+    my $self = shift;
+    return warn $self->_message_at_caller(@_);
+}
+
+sub croak {
+    my $self = shift;
+    return die $self->_message_at_caller(@_);
+}
+
+
+#line 1697
+
+sub current_test {
+    my( $self, $num ) = @_;
+
+    lock( $self->{Curr_Test} );
+    if( defined $num ) {
+        $self->{Curr_Test} = $num;
+
+        # If the test counter is being pushed forward fill in the details.
+        my $test_results = $self->{Test_Results};
+        if( $num > @$test_results ) {
+            my $start = @$test_results ? @$test_results : 0;
+            for( $start .. $num - 1 ) {
+                $test_results->[$_] = &share(
+                    {
+                        'ok'      => 1,
+                        actual_ok => undef,
+                        reason    => 'incrementing test number',
+                        type      => 'unknown',
+                        name      => undef
+                    }
+                );
+            }
+        }
+        # If backward, wipe history.  Its their funeral.
+        elsif( $num < @$test_results ) {
+            $#{$test_results} = $num - 1;
+        }
+    }
+    return $self->{Curr_Test};
+}
+
+#line 1739
+
+sub summary {
+    my($self) = shift;
+
+    return map { $_->{'ok'} } @{ $self->{Test_Results} };
+}
+
+#line 1794
+
+sub details {
+    my $self = shift;
+    return @{ $self->{Test_Results} };
+}
+
+#line 1823
+
+sub todo {
+    my( $self, $pack ) = @_;
+
+    return $self->{Todo} if defined $self->{Todo};
+
+    local $Level = $Level + 1;
+    my $todo = $self->find_TODO($pack);
+    return $todo if defined $todo;
+
+    return '';
+}
+
+#line 1845
+
+sub find_TODO {
+    my( $self, $pack ) = @_;
+
+    $pack = $pack || $self->caller(1) || $self->exported_to;
+    return unless $pack;
+
+    no strict 'refs';    ## no critic
+    return ${ $pack . '::TODO' };
+}
+
+#line 1863
+
+sub in_todo {
+    my $self = shift;
+
+    local $Level = $Level + 1;
+    return( defined $self->{Todo} || $self->find_TODO ) ? 1 : 0;
+}
+
+#line 1913
+
+sub todo_start {
+    my $self = shift;
+    my $message = @_ ? shift : '';
+
+    $self->{Start_Todo}++;
+    if( $self->in_todo ) {
+        push @{ $self->{Todo_Stack} } => $self->todo;
+    }
+    $self->{Todo} = $message;
+
+    return;
+}
+
+#line 1935
+
+sub todo_end {
+    my $self = shift;
+
+    if( !$self->{Start_Todo} ) {
+        $self->croak('todo_end() called without todo_start()');
+    }
+
+    $self->{Start_Todo}--;
+
+    if( $self->{Start_Todo} && @{ $self->{Todo_Stack} } ) {
+        $self->{Todo} = pop @{ $self->{Todo_Stack} };
+    }
+    else {
+        delete $self->{Todo};
+    }
+
+    return;
+}
+
+#line 1968
+
+sub caller {    ## no critic (Subroutines::ProhibitBuiltinHomonyms)
+    my( $self, $height ) = @_;
+    $height ||= 0;
+
+    my $level = $self->level + $height + 1;
+    my @caller;
+    do {
+        @caller = CORE::caller( $level );
+        $level--;
+    } until @caller;
+    return wantarray ? @caller : $caller[0];
+}
+
+#line 1985
+
+#line 1999
+
+#'#
+sub _sanity_check {
+    my $self = shift;
+
+    $self->_whoa( $self->{Curr_Test} < 0, 'Says here you ran a negative number of tests!' );
+    $self->_whoa( $self->{Curr_Test} != @{ $self->{Test_Results} },
+        'Somehow you got a different number of results than tests ran!' );
+
+    return;
+}
+
+#line 2020
+
+sub _whoa {
+    my( $self, $check, $desc ) = @_;
+    if($check) {
+        local $Level = $Level + 1;
+        $self->croak(<<"WHOA");
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+
+    return;
+}
+
+#line 2044
+
+sub _my_exit {
+    $? = $_[0];    ## no critic (Variables::RequireLocalizedPunctuationVars)
+
+    return 1;
+}
+
+#line 2056
+
+sub _ending {
+    my $self = shift;
+
+    my $real_exit_code = $?;
+
+    # Don't bother with an ending if this is a forked copy.  Only the parent
+    # should do the ending.
+    if( $self->{Original_Pid} != $$ ) {
+        return;
+    }
+
+    # Ran tests but never declared a plan or hit done_testing
+    if( !$self->{Have_Plan} and $self->{Curr_Test} ) {
+        $self->diag("Tests were run but no plan was declared and done_testing() was not seen.");
+    }
+
+    # Exit if plan() was never called.  This is so "require Test::Simple"
+    # doesn't puke.
+    if( !$self->{Have_Plan} ) {
+        return;
+    }
+
+    # Don't do an ending if we bailed out.
+    if( $self->{Bailed_Out} ) {
+        return;
+    }
+
+    # Figure out if we passed or failed and print helpful messages.
+    my $test_results = $self->{Test_Results};
+    if(@$test_results) {
+        # The plan?  We have no plan.
+        if( $self->{No_Plan} ) {
+            $self->_output_plan($self->{Curr_Test}) unless $self->no_header;
+            $self->{Expected_Tests} = $self->{Curr_Test};
+        }
+
+        # Auto-extended arrays and elements which aren't explicitly
+        # filled in with a shared reference will puke under 5.8.0
+        # ithreads.  So we have to fill them in by hand. :(
+        my $empty_result = &share( {} );
+        for my $idx ( 0 .. $self->{Expected_Tests} - 1 ) {
+            $test_results->[$idx] = $empty_result
+              unless defined $test_results->[$idx];
+        }
+
+        my $num_failed = grep !$_->{'ok'}, @{$test_results}[ 0 .. $self->{Curr_Test} - 1 ];
+
+        my $num_extra = $self->{Curr_Test} - $self->{Expected_Tests};
+
+        if( $num_extra != 0 ) {
+            my $s = $self->{Expected_Tests} == 1 ? '' : 's';
+            $self->diag(<<"FAIL");
+Looks like you planned $self->{Expected_Tests} test$s but ran $self->{Curr_Test}.
+FAIL
+        }
+
+        if($num_failed) {
+            my $num_tests = $self->{Curr_Test};
+            my $s = $num_failed == 1 ? '' : 's';
+
+            my $qualifier = $num_extra == 0 ? '' : ' run';
+
+            $self->diag(<<"FAIL");
+Looks like you failed $num_failed test$s of $num_tests$qualifier.
+FAIL
+        }
+
+        if($real_exit_code) {
+            $self->diag(<<"FAIL");
+Looks like your test exited with $real_exit_code just after $self->{Curr_Test}.
+FAIL
+
+            _my_exit($real_exit_code) && return;
+        }
+
+        my $exit_code;
+        if($num_failed) {
+            $exit_code = $num_failed <= 254 ? $num_failed : 254;
+        }
+        elsif( $num_extra != 0 ) {
+            $exit_code = 255;
+        }
+        else {
+            $exit_code = 0;
+        }
+
+        _my_exit($exit_code) && return;
+    }
+    elsif( $self->{Skip_All} ) {
+        _my_exit(0) && return;
+    }
+    elsif($real_exit_code) {
+        $self->diag(<<"FAIL");
+Looks like your test exited with $real_exit_code before it could output anything.
+FAIL
+        _my_exit($real_exit_code) && return;
+    }
+    else {
+        $self->diag("No tests run!\n");
+        _my_exit(255) && return;
+    }
+
+    $self->_whoa( 1, "We fell off the end of _ending()" );
+}
+
+END {
+    $Test->_ending if defined $Test and !$Test->no_ending;
+}
+
+#line 2236
+
+1;
+
Index: 0.8/modules/nginx-echo/test/inc/Test/Builder/Module.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Test/Builder/Module.pm	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,81 @@
+#line 1
+package Test::Builder::Module;
+
+use strict;
+
+use Test::Builder;
+
+require Exporter;
+our @ISA = qw(Exporter);
+
+our $VERSION = '0.92';
+$VERSION = eval $VERSION;      ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+# 5.004's Exporter doesn't have export_to_level.
+my $_export_to_level = sub {
+    my $pkg   = shift;
+    my $level = shift;
+    (undef) = shift;    # redundant arg
+    my $callpkg = caller($level);
+    $pkg->export( $callpkg, @_ );
+};
+
+#line 82
+
+sub import {
+    my($class) = shift;
+
+    # Don't run all this when loading ourself.
+    return 1 if $class eq 'Test::Builder::Module';
+
+    my $test = $class->builder;
+
+    my $caller = caller;
+
+    $test->exported_to($caller);
+
+    $class->import_extra( \@_ );
+    my(@imports) = $class->_strip_imports( \@_ );
+
+    $test->plan(@_);
+
+    $class->$_export_to_level( 1, $class, @imports );
+}
+
+sub _strip_imports {
+    my $class = shift;
+    my $list  = shift;
+
+    my @imports = ();
+    my @other   = ();
+    my $idx     = 0;
+    while( $idx <= $#{$list} ) {
+        my $item = $list->[$idx];
+
+        if( defined $item and $item eq 'import' ) {
+            push @imports, @{ $list->[ $idx + 1 ] };
+            $idx++;
+        }
+        else {
+            push @other, $item;
+        }
+
+        $idx++;
+    }
+
+    @$list = @other;
+
+    return @imports;
+}
+
+#line 145
+
+sub import_extra { }
+
+#line 175
+
+sub builder {
+    return Test::Builder->new;
+}
+
+1;
Index: 0.8/modules/nginx-echo/test/inc/Test/More.pm
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/inc/Test/More.pm	2010-10-31 07:35:47.678338000 +0000
@@ -0,0 +1,735 @@
+#line 1
+package Test::More;
+
+use 5.006;
+use strict;
+use warnings;
+
+#---- perlcritic exemptions. ----#
+
+# We use a lot of subroutine prototypes
+## no critic (Subroutines::ProhibitSubroutinePrototypes)
+
+# Can't use Carp because it might cause use_ok() to accidentally succeed
+# even though the module being used forgot to use Carp.  Yes, this
+# actually happened.
+sub _carp {
+    my( $file, $line ) = ( caller(1) )[ 1, 2 ];
+    return warn @_, " at $file line $line\n";
+}
+
+our $VERSION = '0.92';
+$VERSION = eval $VERSION;    ## no critic (BuiltinFunctions::ProhibitStringyEval)
+
+use Test::Builder::Module;
+our @ISA    = qw(Test::Builder::Module);
+our @EXPORT = qw(ok use_ok require_ok
+  is isnt like unlike is_deeply
+  cmp_ok
+  skip todo todo_skip
+  pass fail
+  eq_array eq_hash eq_set
+  $TODO
+  plan
+  done_testing
+  can_ok isa_ok new_ok
+  diag note explain
+  BAIL_OUT
+);
+
+#line 163
+
+sub plan {
+    my $tb = Test::More->builder;
+
+    return $tb->plan(@_);
+}
+
+# This implements "use Test::More 'no_diag'" but the behavior is
+# deprecated.
+sub import_extra {
+    my $class = shift;
+    my $list  = shift;
+
+    my @other = ();
+    my $idx   = 0;
+    while( $idx <= $#{$list} ) {
+        my $item = $list->[$idx];
+
+        if( defined $item and $item eq 'no_diag' ) {
+            $class->builder->no_diag(1);
+        }
+        else {
+            push @other, $item;
+        }
+
+        $idx++;
+    }
+
+    @$list = @other;
+
+    return;
+}
+
+#line 216
+
+sub done_testing {
+    my $tb = Test::More->builder;
+    $tb->done_testing(@_);
+}
+
+#line 289
+
+sub ok ($;$) {
+    my( $test, $name ) = @_;
+    my $tb = Test::More->builder;
+
+    return $tb->ok( $test, $name );
+}
+
+#line 367
+
+sub is ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->is_eq(@_);
+}
+
+sub isnt ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->isnt_eq(@_);
+}
+
+*isn't = \&isnt;
+
+#line 411
+
+sub like ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->like(@_);
+}
+
+#line 426
+
+sub unlike ($$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->unlike(@_);
+}
+
+#line 471
+
+sub cmp_ok($$$;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->cmp_ok(@_);
+}
+
+#line 506
+
+sub can_ok ($@) {
+    my( $proto, @methods ) = @_;
+    my $class = ref $proto || $proto;
+    my $tb = Test::More->builder;
+
+    unless($class) {
+        my $ok = $tb->ok( 0, "->can(...)" );
+        $tb->diag('    can_ok() called with empty class or reference');
+        return $ok;
+    }
+
+    unless(@methods) {
+        my $ok = $tb->ok( 0, "$class->can(...)" );
+        $tb->diag('    can_ok() called with no methods');
+        return $ok;
+    }
+
+    my @nok = ();
+    foreach my $method (@methods) {
+        $tb->_try( sub { $proto->can($method) } ) or push @nok, $method;
+    }
+
+    my $name = (@methods == 1) ? "$class->can('$methods[0]')" :
+                                 "$class->can(...)"           ;
+
+    my $ok = $tb->ok( !@nok, $name );
+
+    $tb->diag( map "    $class->can('$_') failed\n", @nok );
+
+    return $ok;
+}
+
+#line 572
+
+sub isa_ok ($$;$) {
+    my( $object, $class, $obj_name ) = @_;
+    my $tb = Test::More->builder;
+
+    my $diag;
+
+    if( !defined $object ) {
+        $obj_name = 'The thing' unless defined $obj_name;
+        $diag = "$obj_name isn't defined";
+    }
+    else {
+        my $whatami = ref $object ? 'object' : 'class';
+        # We can't use UNIVERSAL::isa because we want to honor isa() overrides
+        my( $rslt, $error ) = $tb->_try( sub { $object->isa($class) } );
+        if($error) {
+            if( $error =~ /^Can't call method "isa" on unblessed reference/ ) {
+                # Its an unblessed reference
+                $obj_name = 'The reference' unless defined $obj_name;
+                if( !UNIVERSAL::isa( $object, $class ) ) {
+                    my $ref = ref $object;
+                    $diag = "$obj_name isn't a '$class' it's a '$ref'";
+                }
+            }
+            elsif( $error =~ /Can't call method "isa" without a package/ ) {
+                # It's something that can't even be a class
+                $diag = "$obj_name isn't a class or reference";
+            }
+            else {
+                die <<WHOA;
+WHOA! I tried to call ->isa on your $whatami and got some weird error.
+Here's the error.
+$error
+WHOA
+            }
+        }
+        else {
+            $obj_name = "The $whatami" unless defined $obj_name;
+            if( !$rslt ) {
+                my $ref = ref $object;
+                $diag = "$obj_name isn't a '$class' it's a '$ref'";
+            }
+        }
+    }
+
+    my $name = "$obj_name isa $class";
+    my $ok;
+    if($diag) {
+        $ok = $tb->ok( 0, $name );
+        $tb->diag("    $diag\n");
+    }
+    else {
+        $ok = $tb->ok( 1, $name );
+    }
+
+    return $ok;
+}
+
+#line 650
+
+sub new_ok {
+    my $tb = Test::More->builder;
+    $tb->croak("new_ok() must be given at least a class") unless @_;
+
+    my( $class, $args, $object_name ) = @_;
+
+    $args ||= [];
+    $object_name = "The object" unless defined $object_name;
+
+    my $obj;
+    my( $success, $error ) = $tb->_try( sub { $obj = $class->new(@$args); 1 } );
+    if($success) {
+        local $Test::Builder::Level = $Test::Builder::Level + 1;
+        isa_ok $obj, $class, $object_name;
+    }
+    else {
+        $tb->ok( 0, "new() died" );
+        $tb->diag("    Error was:  $error");
+    }
+
+    return $obj;
+}
+
+#line 690
+
+sub pass (;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->ok( 1, @_ );
+}
+
+sub fail (;$) {
+    my $tb = Test::More->builder;
+
+    return $tb->ok( 0, @_ );
+}
+
+#line 753
+
+sub use_ok ($;@) {
+    my( $module, @imports ) = @_;
+    @imports = () unless @imports;
+    my $tb = Test::More->builder;
+
+    my( $pack, $filename, $line ) = caller;
+
+    my $code;
+    if( @imports == 1 and $imports[0] =~ /^\d+(?:\.\d+)?$/ ) {
+        # probably a version check.  Perl needs to see the bare number
+        # for it to work with non-Exporter based modules.
+        $code = <<USE;
+package $pack;
+use $module $imports[0];
+1;
+USE
+    }
+    else {
+        $code = <<USE;
+package $pack;
+use $module \@{\$args[0]};
+1;
+USE
+    }
+
+    my( $eval_result, $eval_error ) = _eval( $code, \@imports );
+    my $ok = $tb->ok( $eval_result, "use $module;" );
+
+    unless($ok) {
+        chomp $eval_error;
+        $@ =~ s{^BEGIN failed--compilation aborted at .*$}
+                {BEGIN failed--compilation aborted at $filename line $line.}m;
+        $tb->diag(<<DIAGNOSTIC);
+    Tried to use '$module'.
+    Error:  $eval_error
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+sub _eval {
+    my( $code, @args ) = @_;
+
+    # Work around oddities surrounding resetting of $@ by immediately
+    # storing it.
+    my( $sigdie, $eval_result, $eval_error );
+    {
+        local( $@, $!, $SIG{__DIE__} );    # isolate eval
+        $eval_result = eval $code;              ## no critic (BuiltinFunctions::ProhibitStringyEval)
+        $eval_error  = $@;
+        $sigdie      = $SIG{__DIE__} || undef;
+    }
+    # make sure that $code got a chance to set $SIG{__DIE__}
+    $SIG{__DIE__} = $sigdie if defined $sigdie;
+
+    return( $eval_result, $eval_error );
+}
+
+#line 822
+
+sub require_ok ($) {
+    my($module) = shift;
+    my $tb = Test::More->builder;
+
+    my $pack = caller;
+
+    # Try to deterine if we've been given a module name or file.
+    # Module names must be barewords, files not.
+    $module = qq['$module'] unless _is_module_name($module);
+
+    my $code = <<REQUIRE;
+package $pack;
+require $module;
+1;
+REQUIRE
+
+    my( $eval_result, $eval_error ) = _eval($code);
+    my $ok = $tb->ok( $eval_result, "require $module;" );
+
+    unless($ok) {
+        chomp $eval_error;
+        $tb->diag(<<DIAGNOSTIC);
+    Tried to require '$module'.
+    Error:  $eval_error
+DIAGNOSTIC
+
+    }
+
+    return $ok;
+}
+
+sub _is_module_name {
+    my $module = shift;
+
+    # Module names start with a letter.
+    # End with an alphanumeric.
+    # The rest is an alphanumeric or ::
+    $module =~ s/\b::\b//g;
+
+    return $module =~ /^[a-zA-Z]\w*$/ ? 1 : 0;
+}
+
+#line 899
+
+our( @Data_Stack, %Refs_Seen );
+my $DNE = bless [], 'Does::Not::Exist';
+
+sub _dne {
+    return ref $_[0] eq ref $DNE;
+}
+
+## no critic (Subroutines::RequireArgUnpacking)
+sub is_deeply {
+    my $tb = Test::More->builder;
+
+    unless( @_ == 2 or @_ == 3 ) {
+        my $msg = <<'WARNING';
+is_deeply() takes two or three args, you gave %d.
+This usually means you passed an array or hash instead
+of a reference to it
+WARNING
+        chop $msg;    # clip off newline so carp() will put in line/file
+
+        _carp sprintf $msg, scalar @_;
+
+        return $tb->ok(0);
+    }
+
+    my( $got, $expected, $name ) = @_;
+
+    $tb->_unoverload_str( \$expected, \$got );
+
+    my $ok;
+    if( !ref $got and !ref $expected ) {    # neither is a reference
+        $ok = $tb->is_eq( $got, $expected, $name );
+    }
+    elsif( !ref $got xor !ref $expected ) {    # one's a reference, one isn't
+        $ok = $tb->ok( 0, $name );
+        $tb->diag( _format_stack({ vals => [ $got, $expected ] }) );
+    }
+    else {                                     # both references
+        local @Data_Stack = ();
+        if( _deep_check( $got, $expected ) ) {
+            $ok = $tb->ok( 1, $name );
+        }
+        else {
+            $ok = $tb->ok( 0, $name );
+            $tb->diag( _format_stack(@Data_Stack) );
+        }
+    }
+
+    return $ok;
+}
+
+sub _format_stack {
+    my(@Stack) = @_;
+
+    my $var       = '$FOO';
+    my $did_arrow = 0;
+    foreach my $entry (@Stack) {
+        my $type = $entry->{type} || '';
+        my $idx = $entry->{'idx'};
+        if( $type eq 'HASH' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "{$idx}";
+        }
+        elsif( $type eq 'ARRAY' ) {
+            $var .= "->" unless $did_arrow++;
+            $var .= "[$idx]";
+        }
+        elsif( $type eq 'REF' ) {
+            $var = "\${$var}";
+        }
+    }
+
+    my @vals = @{ $Stack[-1]{vals} }[ 0, 1 ];
+    my @vars = ();
+    ( $vars[0] = $var ) =~ s/\$FOO/     \$got/;
+    ( $vars[1] = $var ) =~ s/\$FOO/\$expected/;
+
+    my $out = "Structures begin differing at:\n";
+    foreach my $idx ( 0 .. $#vals ) {
+        my $val = $vals[$idx];
+        $vals[$idx]
+          = !defined $val ? 'undef'
+          : _dne($val)    ? "Does not exist"
+          : ref $val      ? "$val"
+          :                 "'$val'";
+    }
+
+    $out .= "$vars[0] = $vals[0]\n";
+    $out .= "$vars[1] = $vals[1]\n";
+
+    $out =~ s/^/    /msg;
+    return $out;
+}
+
+sub _type {
+    my $thing = shift;
+
+    return '' if !ref $thing;
+
+    for my $type (qw(ARRAY HASH REF SCALAR GLOB CODE Regexp)) {
+        return $type if UNIVERSAL::isa( $thing, $type );
+    }
+
+    return '';
+}
+
+#line 1059
+
+sub diag {
+    return Test::More->builder->diag(@_);
+}
+
+sub note {
+    return Test::More->builder->note(@_);
+}
+
+#line 1085
+
+sub explain {
+    return Test::More->builder->explain(@_);
+}
+
+#line 1151
+
+## no critic (Subroutines::RequireFinalReturn)
+sub skip {
+    my( $why, $how_many ) = @_;
+    my $tb = Test::More->builder;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "skip() needs to know \$how_many tests are in the block"
+          unless $tb->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    if( defined $how_many and $how_many =~ /\D/ ) {
+        _carp
+          "skip() was passed a non-numeric number of tests.  Did you get the arguments backwards?";
+        $how_many = 1;
+    }
+
+    for( 1 .. $how_many ) {
+        $tb->skip($why);
+    }
+
+    no warnings 'exiting';
+    last SKIP;
+}
+
+#line 1238
+
+sub todo_skip {
+    my( $why, $how_many ) = @_;
+    my $tb = Test::More->builder;
+
+    unless( defined $how_many ) {
+        # $how_many can only be avoided when no_plan is in use.
+        _carp "todo_skip() needs to know \$how_many tests are in the block"
+          unless $tb->has_plan eq 'no_plan';
+        $how_many = 1;
+    }
+
+    for( 1 .. $how_many ) {
+        $tb->todo_skip($why);
+    }
+
+    no warnings 'exiting';
+    last TODO;
+}
+
+#line 1293
+
+sub BAIL_OUT {
+    my $reason = shift;
+    my $tb     = Test::More->builder;
+
+    $tb->BAIL_OUT($reason);
+}
+
+#line 1332
+
+#'#
+sub eq_array {
+    local @Data_Stack = ();
+    _deep_check(@_);
+}
+
+sub _eq_array {
+    my( $a1, $a2 ) = @_;
+
+    if( grep _type($_) ne 'ARRAY', $a1, $a2 ) {
+        warn "eq_array passed a non-array ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $max = $#$a1 > $#$a2 ? $#$a1 : $#$a2;
+    for( 0 .. $max ) {
+        my $e1 = $_ > $#$a1 ? $DNE : $a1->[$_];
+        my $e2 = $_ > $#$a2 ? $DNE : $a2->[$_];
+
+        push @Data_Stack, { type => 'ARRAY', idx => $_, vals => [ $e1, $e2 ] };
+        $ok = _deep_check( $e1, $e2 );
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+sub _deep_check {
+    my( $e1, $e2 ) = @_;
+    my $tb = Test::More->builder;
+
+    my $ok = 0;
+
+    # Effectively turn %Refs_Seen into a stack.  This avoids picking up
+    # the same referenced used twice (such as [\$a, \$a]) to be considered
+    # circular.
+    local %Refs_Seen = %Refs_Seen;
+
+    {
+        # Quiet uninitialized value warnings when comparing undefs.
+        no warnings 'uninitialized';
+
+        $tb->_unoverload_str( \$e1, \$e2 );
+
+        # Either they're both references or both not.
+        my $same_ref = !( !ref $e1 xor !ref $e2 );
+        my $not_ref = ( !ref $e1 and !ref $e2 );
+
+        if( defined $e1 xor defined $e2 ) {
+            $ok = 0;
+        }
+        elsif( !defined $e1 and !defined $e2 ) {
+            # Shortcut if they're both defined.
+            $ok = 1;
+        }
+        elsif( _dne($e1) xor _dne($e2) ) {
+            $ok = 0;
+        }
+        elsif( $same_ref and( $e1 eq $e2 ) ) {
+            $ok = 1;
+        }
+        elsif($not_ref) {
+            push @Data_Stack, { type => '', vals => [ $e1, $e2 ] };
+            $ok = 0;
+        }
+        else {
+            if( $Refs_Seen{$e1} ) {
+                return $Refs_Seen{$e1} eq $e2;
+            }
+            else {
+                $Refs_Seen{$e1} = "$e2";
+            }
+
+            my $type = _type($e1);
+            $type = 'DIFFERENT' unless _type($e2) eq $type;
+
+            if( $type eq 'DIFFERENT' ) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = 0;
+            }
+            elsif( $type eq 'ARRAY' ) {
+                $ok = _eq_array( $e1, $e2 );
+            }
+            elsif( $type eq 'HASH' ) {
+                $ok = _eq_hash( $e1, $e2 );
+            }
+            elsif( $type eq 'REF' ) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = _deep_check( $$e1, $$e2 );
+                pop @Data_Stack if $ok;
+            }
+            elsif( $type eq 'SCALAR' ) {
+                push @Data_Stack, { type => 'REF', vals => [ $e1, $e2 ] };
+                $ok = _deep_check( $$e1, $$e2 );
+                pop @Data_Stack if $ok;
+            }
+            elsif($type) {
+                push @Data_Stack, { type => $type, vals => [ $e1, $e2 ] };
+                $ok = 0;
+            }
+            else {
+                _whoa( 1, "No type in _deep_check" );
+            }
+        }
+    }
+
+    return $ok;
+}
+
+sub _whoa {
+    my( $check, $desc ) = @_;
+    if($check) {
+        die <<"WHOA";
+WHOA!  $desc
+This should never happen!  Please contact the author immediately!
+WHOA
+    }
+}
+
+#line 1465
+
+sub eq_hash {
+    local @Data_Stack = ();
+    return _deep_check(@_);
+}
+
+sub _eq_hash {
+    my( $a1, $a2 ) = @_;
+
+    if( grep _type($_) ne 'HASH', $a1, $a2 ) {
+        warn "eq_hash passed a non-hash ref";
+        return 0;
+    }
+
+    return 1 if $a1 eq $a2;
+
+    my $ok = 1;
+    my $bigger = keys %$a1 > keys %$a2 ? $a1 : $a2;
+    foreach my $k ( keys %$bigger ) {
+        my $e1 = exists $a1->{$k} ? $a1->{$k} : $DNE;
+        my $e2 = exists $a2->{$k} ? $a2->{$k} : $DNE;
+
+        push @Data_Stack, { type => 'HASH', idx => $k, vals => [ $e1, $e2 ] };
+        $ok = _deep_check( $e1, $e2 );
+        pop @Data_Stack if $ok;
+
+        last unless $ok;
+    }
+
+    return $ok;
+}
+
+#line 1522
+
+sub eq_set {
+    my( $a1, $a2 ) = @_;
+    return 0 unless @$a1 == @$a2;
+
+    no warnings 'uninitialized';
+
+    # It really doesn't matter how we sort them, as long as both arrays are
+    # sorted with the same algorithm.
+    #
+    # Ensure that references are not accidentally treated the same as a
+    # string containing the reference.
+    #
+    # Have to inline the sort routine due to a threading/sort bug.
+    # See [rt.cpan.org 6782]
+    #
+    # I don't know how references would be sorted so we just don't sort
+    # them.  This means eq_set doesn't really work with refs.
+    return eq_array(
+        [ grep( ref, @$a1 ), sort( grep( !ref, @$a1 ) ) ],
+        [ grep( ref, @$a2 ), sort( grep( !ref, @$a2 ) ) ],
+    );
+}
+
+#line 1735
+
+1;
Index: 0.8/modules/nginx-echo/test/valgrind.suppress
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/test/valgrind.suppress	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,88 @@
+{
+   init_request_leak
+   Memcheck:Leak
+   fun:memalign
+   fun:posix_memalign
+   fun:ngx_memalign
+   fun:ngx_palloc_block
+   fun:ngx_palloc
+   fun:ngx_pcalloc
+   fun:ngx_create_temp_buf
+   fun:ngx_http_init_request
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   nginx-core-process-init
+   Memcheck:Leak
+   fun:malloc
+   fun:ngx_alloc
+   fun:ngx_event_process_init
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   nginx-core-crc32-init
+   Memcheck:Leak
+   fun:malloc
+   fun:ngx_alloc
+   fun:ngx_crc32_table_init
+   fun:main
+}
+{
+   palloc_large_for_init_request
+   Memcheck:Leak
+   fun:malloc
+   fun:ngx_alloc
+   fun:ngx_palloc_large
+   fun:ngx_palloc
+   fun:ngx_pcalloc
+   fun:ngx_http_init_request
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   palloc_large_for_create_temp_buf
+   Memcheck:Leak
+   fun:malloc
+   fun:ngx_alloc
+   fun:ngx_palloc_large
+   fun:ngx_palloc
+   fun:ngx_create_temp_buf
+   fun:ngx_http_init_request
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   accept_create_pool
+   Memcheck:Leak
+   fun:memalign
+   fun:posix_memalign
+   fun:ngx_memalign
+   fun:ngx_create_pool
+   fun:ngx_event_accept
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+   fun:ngx_single_process_cycle
+   fun:main
+}
+{
+   create_pool_for_init_req
+   Memcheck:Leak
+   fun:memalign
+   fun:posix_memalign
+   fun:ngx_memalign
+   fun:ngx_create_pool
+   fun:ngx_http_init_request
+   fun:ngx_epoll_process_events
+   fun:ngx_process_events_and_timers
+   fun:ngx_single_process_cycle
+   fun:main
+}
+
Index: 0.8/modules/nginx-echo/util/build.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/util/build.sh	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,66 @@
+#!/bin/bash
+
+# this file is mostly meant to be used by the author himself.
+
+root=`pwd`
+cd ~/work
+version=$1
+opts=$2
+home=~
+
+if [ ! -s "nginx-$version.tar.gz" ]; then
+    wget "http://sysoev.ru/nginx/nginx-$version.tar.gz" -O nginx-$version.tar.gz || exit 1
+    tar -xzvf nginx-$version.tar.gz || exit 1
+    if [ "$version" = "0.8.41" ]; then
+        cp $root/../no-pool-nginx/nginx-$version-no_pool.patch ./
+        patch -p0 < nginx-$version-no_pool.patch || exit 1
+    fi
+fi
+
+#tar -xzvf nginx-$version.tar.gz || exit 1
+#cp $root/../no-pool-nginx/nginx-0.8.41-no_pool.patch ./
+#patch -p0 < nginx-0.8.41-no_pool.patch || exit 1
+
+cd nginx-$version/
+if [[ "$BUILD_CLEAN" -eq 1 || ! -f Makefile \
+        || "$root/config" -nt Makefile
+        || "$root/util/build.sh" -nt Makefile ]]; then
+    ./configure --prefix=/opt/nginx \
+            --with-cc-opt="-DDEBUG_MALLOC" \
+            --with-http_stub_status_module \
+            --without-mail_pop3_module \
+            --without-mail_imap_module \
+            --without-mail_smtp_module \
+            --without-http_upstream_ip_hash_module \
+            --without-http_empty_gif_module \
+            --without-http_memcached_module \
+            --without-http_referer_module \
+            --without-http_autoindex_module \
+            --without-http_auth_basic_module \
+            --without-http_userid_module \
+          --with-http_addition_module \
+          --add-module=$root/../ndk-nginx-module \
+          --add-module=$root/../set-misc-nginx-module \
+          --add-module=$root/../eval-nginx-module \
+          --add-module=$root/../xss-nginx-module \
+          --add-module=$root/../rds-json-nginx-module \
+          --add-module=$root/../headers-more-nginx-module \
+          --add-module=$root $opts \
+          --with-debug
+          #--add-module=$root/../lz-session-nginx-module \
+          #--add-module=$home/work/ndk \
+          #--add-module=$home/work/ndk/examples/http/set_var \
+          #--add-module=$root/../eval-nginx-module \
+          #--add-module=/home/agentz/work/nginx_eval_module-1.0.1 \
+  #--without-http_ssi_module  # we cannot disable ssi because echo_location_async depends on it (i dunno why?!)
+
+fi
+if [ -f /opt/nginx/sbin/nginx ]; then
+    rm -f /opt/nginx/sbin/nginx
+fi
+if [ -f /opt/nginx/logs/nginx.pid ]; then
+    kill `cat /opt/nginx/logs/nginx.pid`
+fi
+make -j3
+make install
+
Index: 0.8/modules/nginx-echo/util/releng
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/util/releng	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,7 @@
+#!/bin/bash
+
+./update-readme
+ack '(?<=\#define)\s*DDEBUG\s*[12]' src
+echo =======================================
+ack '(?<=This document describes echo-nginx-module v)\d+\.\d+' README
+
Index: 0.8/modules/nginx-echo/util/update-readme.sh
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/util/update-readme.sh	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,6 @@
+#!/bin/bash
+
+perl util/wiki2pod.pl doc/manpage.wiki > /tmp/a.pod \
+    && pod2text /tmp/a.pod > README \
+    && perl -i -pe 's{(https?://.*?)>}{$1 >}g' README
+
Index: 0.8/modules/nginx-echo/util/wiki2pod.pl
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ 0.8/modules/nginx-echo/util/wiki2pod.pl	2010-10-31 07:35:23.648338001 +0000
@@ -0,0 +1,131 @@
+#!/usr/bin/env perl
+
+use strict;
+use warnings;
+use bytes;
+
+my @nl_counts;
+my $last_nl_count_level;
+
+my @bl_counts;
+my $last_bl_count_level;
+
+sub fmt_pos ($) {
+    (my $s = $_[0]) =~ s{\#(.*)}{/"$1"};
+    $s;
+}
+
+sub fmt_mark ($$) {
+    my ($tag, $s) = @_;
+    my $max_level = 0;
+    while ($s =~ /([<>])\1*/g) {
+        my $level = length $&;
+        if ($level > $max_level) {
+            $max_level = $level;
+        }
+    }
+
+    my $times = $max_level + 1;
+    if ($times > 1) {
+        $s = " $s ";
+    }
+    return $tag . ('<' x $times) . $s . ('>' x $times);
+}
+
+print "=encoding utf-8\n\n";
+
+while (<>) {
+    if ($. == 1) {
+        # strip the leading U+FEFF byte in MS-DOS text files
+        my $first = ord(substr($_, 0, 1));
+        #printf STDERR "0x%x", $first;
+        #my $second = ord(substr($_, 2, 1));
+        #printf STDERR "0x%x", $second;
+        if ($first == 0xEF) {
+            substr($_, 0, 1, '');
+            #warn "Hit!";
+        }
+    }
+    s{\[(http[^ \]]+) ([^\]]*)\]}{$2 (L<$1>)}gi;
+    s{ \[\[ ( [^\]\|]+ ) \| ([^\]]*) \]\] }{"L<$2|" . fmt_pos($1) . ">"}gixe;
+    s{<code>(.*?)</code>}{fmt_mark('C', $1)}gie;
+    s{'''(.*?)'''}{fmt_mark('B', $1)}ge;
+    s{''(.*?)''}{fmt_mark('I', $1)}ge;
+    if (s{^\s*<[^>]+>\s*$}{}) {
+        next;
+    }
+
+    if (/^\s*$/) {
+        print "\n";
+        next;
+    }
+
+=begin cmt
+
+    if ($. == 1) {
+        warn $_;
+        for my $i (0..length($_) - 1) {
+            my $chr = substr($_, $i, 1);
+            warn "chr ord($i): ".ord($chr)." \"$chr\"\n";
+        }
+    }
+
+=end cmt
+=cut
+
+    if (/(=+) (.*) \1$/) {
+        #warn "HERE! $_" if $. == 1;
+        my ($level, $title) = (length $1, $2);
+        collapse_lists();
+
+        print "\n=head$level $title\n\n";
+    } elsif (/^(\#+) (.*)/) {
+        my ($level, $txt) = (length($1) - 1, $2);
+        if (defined $last_nl_count_level && $level != $last_nl_count_level) {
+            print "\n=back\n\n";
+        }
+        $last_nl_count_level = $level;
+        $nl_counts[$level] ||= 0;
+        if ($nl_counts[$level] == 0) {
+            print "\n=over\n\n";
+        }
+        $nl_counts[$level]++;
+        print "\n=item $nl_counts[$level].\n\n";
+        print "$txt\n";
+    } elsif (/^(\*+) (.*)/) {
+        my ($level, $txt) = (length($1) - 1, $2);
+        if (defined $last_bl_count_level && $level != $last_bl_count_level) {
+            print "\n=back\n\n";
+        }
+        $last_bl_count_level = $level;
+        $bl_counts[$level] ||= 0;
+        if ($bl_counts[$level] == 0) {
+            print "\n=over\n\n";
+        }
+        $bl_counts[$level]++;
+        print "\n=item *\n\n";
+        print "$txt\n";
+    } else {
+        collapse_lists();
+        print;
+    }
+}
+
+collapse_lists();
+
+sub collapse_lists {
+    while (defined $last_nl_count_level && $last_nl_count_level >= 0) {
+        print "\n=back\n\n";
+        $last_nl_count_level--;
+    }
+    undef $last_nl_count_level;
+    undef @nl_counts;
+
+    while (defined $last_bl_count_level && $last_bl_count_level >= 0) {
+        print "\n=back\n\n";
+        $last_bl_count_level--;
+    }
+    undef $last_bl_count_level;
+    undef @bl_counts;
+}
+
